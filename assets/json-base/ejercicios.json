{
  "paradigma-funcional": {
    "ejercicio-1": {
      "description": "¡Bienvenido al paradigma funcional! Nos enfocamos en expresiones puras que siempre dan el mismo resultado. Imagina que Ana planifica varios viajes, sumando distancias recorridas en diferentes tramos, como 5 km + 3 km, 2 km + 7 km, o 10 km + 4 km. Usa la operación primitiva de suma para calcular las distancias totales, mostrando cómo el funcional resuelve problemas cotidianos, como combinar tramos de caminatas, con cálculos predecibles y sin modificar estado.",
      "racket": {
        "code": "(+ 5 3)\n(+ 2 7)\n(+ 10 4)\n(+ 1 6)\n(+ 8 2)"
      },
      "ocaml": {
        "code": "5 + 3\n2 + 7\n10 + 4\n1 + 6\n8 + 2"
      },
      "answer": "8\n9\n14\n7\n10"
    },
    "ejercicio-2": {
      "description": "En programación funcional, las expresiones son clave. Carlos organiza eventos y verifica si cantidades de sillas, como 7, 4, 9, 6 o 3, son impares para decidir si añadir una extra. Usa el módulo (resto de dividir por 2) para determinar paridad, obteniendo 1 para impares y 0 para pares. Esta operación primitiva muestra cómo evaluar condiciones simples, como organizar asientos, de forma pura y determinista.",
      "racket": {
        "code": "(remainder 7 2)\n(remainder 4 2)\n(remainder 9 2)\n(remainder 6 2)\n(remainder 3 2)"
      },
      "ocaml": {
        "code": "7 mod 2\n4 mod 2\n9 mod 2\n6 mod 2\n3 mod 2"
      },
      "answer": "1\n0\n1\n0\n1"
    },
    "ejercicio-3": {
      "description": "Las expresiones funcionales son deterministas. Sofía gestiona una tienda y compara si el inventario total, después de sumar nuevas unidades, es mayor que el de la competencia, como 12 + 4 > 15, 5 + 5 > 12, o 15 + 3 > 10. Usa la comparación mayor que en expresiones compuestas, que retorna true si el resultado es mayor, o false si no. Esta operación primitiva muestra cómo el funcional toma decisiones puras en escenarios más elaborados, como gestionar inventarios con adiciones, sin alterar nada.",
      "racket": {
        "code": "(> (+ 12 4) 15)\n(> (+ 5 5) 12)\n(> (+ 15 3) 10)\n(> (+ 3 3) 6)\n(> (+ 9 6) 8)"
      },
      "ocaml": {
        "code": "12 + 4 > 15\n5 + 5 > 12\n15 + 3 > 10\n3 + 3 > 6\n9 + 6 > 8"
      },
      "answer": "#t\n#f\n#t\n#f\n#t"
    },
    "ejercicio-4": {
      "description": "El funcional resuelve problemas prácticos. Luis reparte ganancias netas, calculadas restando costos de las brutas, entre equipos, como (20 - 10) / 2, (15 - 3) / 4, o (18 - 10) / 2. Usa la operación primitiva de división en expresiones con sumas y restas para calcular cuánto recibe cada uno, obteniendo resultados como 5, 3, o 4. Esto muestra cómo el funcional realiza cálculos directos para distribuciones equitativas en escenarios más complejos, manteniendo todo inmutable y predecible.",
      "racket": {
        "code": "(/ (- 20 10) 2)\n(/ (- 15 3) 4)\n(/ (- 18 10) 2)\n(/ (- 12 3) 3)\n(/ (- 24 4) 5)"
      },
      "ocaml": {
        "code": "(20 - 10) / 2\n(15 - 3) / 4\n(18 - 10) / 2\n(12 - 3) / 3\n(24 - 4) / 5"
      },
      "answer": "5\n3\n4\n3\n4"
    },
    "ejercicio-5": {
      "description": "Las comparaciones son esenciales en el funcional. Marta verifica si el resultado de cálculos más elaborados, involucrando sumas, restas y multiplicaciones, es igual a un valor esperado, como (5 + 3 - 1) = 7, (2 * 3) = 7, o ((4 * 2) + 1) = 9. Usa la operación de igualdad en expresiones compuestas, que retorna true si son iguales, o false si no. Esta expresión pura muestra cómo validar equivalencias en escenarios complejos, como en inventarios con operaciones múltiples, con cálculos que no alteran el estado.",
      "racket": {
        "code": "(= (- (+ 5 3) 1) 7)\n(= (* 2 3) 7)\n(= (+ (* 4 2) 1) 9)\n(= (- 10 3) 6)\n(= (* 5 1) 5)"
      },
      "ocaml": {
        "code": "(5 + 3 - 1) = 7\n(2 * 3) = 7\n((4 * 2) + 1) = 9\n(10 - 3) = 6\n(5 * 1) = 5"
      },
      "answer": "#t\n#f\n#t\n#f\n#t"
    },
    "ejercicio-6": {
      "description": "Exploramos funciones matemáticas. Un excursionista mide desviaciones complejas respecto a un punto base, involucrando sumas, restas y multiplicaciones, como abs(5 + 3 - 10), abs(-2 * 3), o abs(4 - (1 + 6)), y necesita distancias absolutas. Usa el valor absoluto en expresiones anidadas para obtener valores positivos, como 2, 6, o 3. Esta operación primitiva enseña cómo el funcional maneja números negativos en mediciones más elaboradas, como en mapas con cálculos compuestos, con resultados predecibles y sin efectos secundarios.",
      "racket": {
        "code": "(abs (- (+ 5 3) 10))\n(abs (* -2 3))\n(abs (- 4 (+ 1 6)))\n(abs (abs (- (* 3 4) 15)))\n(abs (- (abs (- 12 18)) 2))"
      },
      "ocaml": {
        "code": "abs (5 + 3 - 10)\nabs (-2 * 3)\nabs (4 - (1 + 6))\nabs (abs ((3 * 4) - 15))\nabs ((abs (12 - 18)) - 2)"
      },
      "answer": "2\n6\n3\n3\n4"
    },
    "ejercicio-7": {
      "description": "El funcional aborda cálculos avanzados. Un ingeniero diseña estructuras y calcula la hipotenusa en triángulos rectángulos con lados como 3 y 4, 5 y 12, o 8 y 6 metros, usando expresiones aún más complejas con raíces cuadradas anidadas, sumas y multiplicaciones. Usa la raíz cuadrada en composiciones anidadas con operaciones intermedias para obtener valores como 5, 13 o 10. Esta operación primitiva muestra cómo resolver problemas reales y desafiantes, como diseño estructural con teorema de Pitágoras, empleando expresiones puras, precisas y deterministas.",
      "racket": {
        "code": "(sqrt (+ (* 3 3) (* 4 4)))\n(sqrt (+ (sqrt (+ (* 5 5) (* 12 12))) 1))\n(sqrt (+ (* (sqrt 8) (sqrt 8)) (* 6 6)))\n(sqrt (+ (* 7 7) (sqrt (+ (* 24 24) 1))))\n(sqrt (sqrt (+ (* 20 20) (* 21 21))))"
      },
      "ocaml": {
        "code": "sqrt (3.0 *. 3.0 +. 4.0 *. 4.0)\nsqrt (sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) +. 1.0)\nsqrt ((sqrt 8.0) *. (sqrt 8.0) +. 6.0 *. 6.0)\nsqrt (7.0 *. 7.0 +. sqrt (24.0 *. 24.0 +. 1.0))\nsqrt (sqrt (20.0 *. 20.0 +. 21.0 *. 21.0)))"
      },
      "answer": "5\n≈13.03\n10\n≈25.02\n≈29.00"
    }
  },
  "expresiones": {
    "ejercicio-1": {
      "description": "¡Bienvenidos al paradigma funcional! Las expresiones puras siempre producen el mismo resultado sin alterar estado. Clara verifica si varios paquetes tienen el mismo número de galletas, como 8 vs. 8, 5 vs. 6, o 7 vs. 7. Usa la operación primitiva de igualdad para obtener resultados booleanos, mostrando cómo validar equivalencias en inventarios con cálculos simples y deterministas.",
      "racket": {
        "code": "(= 8 8)\n(= 5 6)\n(= 7 7)\n(= 3 3)\n(= 9 10)"
      },
      "ocaml": {
        "code": "8 = 8\n5 = 6\n7 = 7\n3 = 3\n9 = 10"
      },
      "answer": "#t\n#f\n#t\n#t\n#f"
    },
    "ejercicio-2": {
      "description": "Las comparaciones son esenciales en el funcional. Jorge revisa si varios presupuestos, como 15, 8, 12, 10, o 20 dólares, superan diferentes límites, como 10, 9, 5, 10, o 15 dólares. Usa la operación mayor que para obtener resultados booleanos, mostrando cómo evaluar condiciones en planificación financiera con expresiones puras y predecibles.",
      "racket": {
        "code": "(> 15 10)\n(> 8 9)\n(> 12 5)\n(> 10 10)\n(> 20 15)"
      },
      "ocaml": {
        "code": "15 > 10\n8 > 9\n12 > 5\n10 > 10\n20 > 15"
      },
      "answer": "#t\n#f\n#t\n#f\n#t"
    },
    "ejercicio-3": {
      "description": "La suma resuelve problemas cotidianos. Lucía calcula distancias totales de caminatas combinando tramos, como 7 km + 5 km, 3 km + 4 km, o 6 km + 8 km. Usa la operación primitiva de suma para obtener las distancias, mostrando cómo el funcional realiza cálculos aritméticos simples para viajes, manteniendo resultados consistentes y sin efectos secundarios.",
      "racket": {
        "code": "(+ 7 5)\n(+ 3 4)\n(+ 6 8)\n(+ 2 9)\n(+ 10 3)"
      },
      "ocaml": {
        "code": "7 + 5\n3 + 4\n6 + 8\n2 + 9\n10 + 3"
      },
      "answer": "12\n7\n14\n11\n13"
    },
    "ejercicio-4": {
      "description": "La resta calcula sobrantes. Raúl distribuye caramelos, empezando con cantidades como 20, 15, 12, 8, o 10, y da 6, 4, 3, 2, o 5 respectivamente. Usa la operación primitiva de resta para determinar cuántos caramelos quedan, mostrando cómo el funcional maneja diferencias en distribución de recursos con pureza y determinismo.",
      "racket": {
        "code": "(- 20 6)\n(- 15 4)\n(- 12 3)\n(- 8 2)\n(- 10 5)"
      },
      "ocaml": {
        "code": "20 - 6\n15 - 4\n12 - 3\n8 - 2\n10 - 5"
      },
      "answer": "14\n11\n9\n6\n5"
    },
    "ejercicio-5": {
      "description": "El módulo verifica patrones. Ana organiza libros en grupos de diferentes tamaños, como 10 libros en grupos de 3, 8 en grupos de 2, o 7 en grupos de 4. Calcula el resto con el módulo para saber cuántos libros sobran, mostrando cómo el funcional evalúa restos en organización de objetos con resultados fijos y sin efectos secundarios.",
      "racket": {
        "code": "(remainder 10 3)\n(remainder 8 2)\n(remainder 7 4)\n(remainder 12 5)\n(remainder 9 3)"
      },
      "ocaml": {
        "code": "10 mod 3\n8 mod 2\n7 mod 4\n12 mod 5\n9 mod 3"
      },
      "answer": "1\n0\n3\n2\n0"
    },
    "ejercicio-6": {
      "description": "La división reparte recursos, pero ahora combinamos divisiones con raíces y redondeos para explorar cálculos más ricos. Un chef divide ingredientes en proporciones más precisas, usando divisiones puras y anidadas para representar exactitud y balance.",
      "racket": {
        "code": "(/ 12 3)\n(/ (sqrt 81) 3)\n(/ (round 15.6) 5)\n(/ 6 (sqrt 4))\n(/ (+ 9 3) 3)"
      },
      "ocaml": {
        "code": "12 / 3\nint_of_float ((sqrt 81.0) /. 3.0)\nint_of_float ((Float.round 15.6) /. 5.0)\nint_of_float (6.0 /. (sqrt 4.0))\nint_of_float ((9.0 +. 3.0) /. 3.0)"
      },
      "answer": "4\n3\n3\n3\n4"
    },
    "ejercicio-7": {
      "description": "Combinamos operaciones con trigonometría, potencias, raíces, y redondeos para modelar comparaciones estructurales complejas. Un arquitecto evalúa longitudes ajustadas mediante 'sqrt', 'tan', 'sin', 'round' y 'remainder', mostrando cómo el razonamiento funcional combina cálculos precisos y puros.",
      "racket": {
        "code": "(> (- (sqrt (+ (* 3 3) (* 4 4))) 2) 5)\n(> (- (round (sqrt (+ (* 4 4) (* 12 12)))) 1) 7)\n(> (- (expt 2 2) (remainder 3 2)) 1)\n(> (- (round (* (tan 1.5) 5)) 5) 10)\n(> (- (expt 6 2) (round (sin 2))) 15)"
      },
      "ocaml": {
        "code": "((sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) -. 2.0) >. 5.0)\n((Float.round (sqrt (4.0 *. 4.0 +. 12.0 *. 12.0)) -. 1.0) >. 7.0)\n(((2.0 ** 2.0) -. float_of_int (3 mod 2)) >. 1.0)\n((Float.round (Float.tan 1.5 *. 5.0) -. 5.0) >. 10.0)\n((6.0 ** 2.0 -. Float.round (Float.sin 2.0)) >. 15.0)"
      },
      "answer": "#f\n#t\n#t\n#t\n#t"
    }
  },
  "funciones": {
    "ejercicio-1": {
      "description": "Un agricultor mide un terreno rectangular de 10 metros de largo por 7 metros de ancho para instalar un sistema de riego. Define una función que calcule el área multiplicando base por altura. Evalúa con 10 y 7. Este ejercicio introduce funciones básicas para cálculos geométricos simples, esenciales en planificación agrícola. La fórmula es base * altura. Paso a paso: 10 * 7 = 70 metros cuadrados, que representa el área a regar. El resultado esperado es 70, útil para estimar la cantidad de tuberías necesarias.",
      "racket": {
        "code": "(define (rectangle-area base height)\n  (* base height)\n)\n(rectangle-area 10 7)"
      },
      "ocaml": {
        "code": "let rectangle_area base height =\n  base * height\nin\nrectangle_area 10 7"
      },
      "answer": "70"
    },
    "ejercicio-2": {
      "description": "Un organizador de eventos calcula cuántas veces se repite un espectáculo de luces cada 5 segundos en un período de 25 segundos, ajustando el resultado con un margen de 2 segundos por retrasos técnicos. Define una función que divida el tiempo total entre el intervalo y reste el margen. Evalúa con 25 y 5. Este ejercicio introduce división y resta, aumentando la complejidad al combinar dos operaciones. Paso a paso: 25 / 5 = 5 repeticiones, menos 2 segundos de margen da 5 - 2 = 3 repeticiones ajustadas. El resultado esperado es 3, útil para planificar cronogramas.",
      "racket": {
        "code": "(define (adjusted-event-count total-time interval)\n  (let ((count (/ total-time interval))\n        (margin 2))\n    (- count margin))\n)\n(adjusted-event-count 25 5)"
      },
      "ocaml": {
        "code": "let adjusted_event_count total_time interval =\n  let count = total_time / interval in\n  let margin = 2 in\n  count - margin\nin\nadjusted_event_count 25 5"
      },
      "answer": "3"
    },
    "ejercicio-3": {
      "description": "Un diseñador de videojuegos calcula el daño de un ataque basado en el nivel del personaje (nivel 8), usando la fórmula nivel^2 + 2 * nivel. Define una función que compute el cuadrado del nivel y sume el doble del nivel. Evalúa con 8. Este ejercicio añade exponentes y suma, aumentando la robustez con dos términos. Paso a paso: nivel = 8, cuadrado = 8 * 8 = 64, doble = 2 * 8 = 16, total = 64 + 16 = 80. El resultado esperado es 80, modelando un daño que crece no linealmente, común en mecánicas de juegos.",
      "racket": {
        "code": "(define (damage level)\n  (let ((square (* level level))\n        (double (* 2 level)))\n    (+ square double))\n)\n(damage 8)"
      },
      "ocaml": {
        "code": "let damage level =\n  let square = level * level in\n  let double = 2 * level in\n  square + double\nin\ndamage 8"
      },
      "answer": "80"
    },
    "ejercicio-4": {
      "description": "Un ingeniero diseña un soporte triangular con catetos de 6 y 8 metros. Calcula la hipotenusa usando la fórmula de Pitágoras: sqrt(a^2 + b^2). Define una función que eleve al cuadrado ambos catetos, los sume y tome la raíz cuadrada. Evalúa con 6 y 8. Este ejercicio combina multiplicaciones, suma y raíz cuadrada, usando más operaciones que los anteriores. Paso a paso: a = 6, b = 8, a^2 = 36, b^2 = 64, suma = 36 + 64 = 100, raíz = sqrt(100) = 10. El resultado esperado es 10, crucial para diseño estructural.",
      "racket": {
        "code": "(define (hypotenuse a b)\n  (let ((a-square (* a a))\n        (b-square (* b b)))\n    (sqrt (+ a-square b-square)))\n)\n(hypotenuse 6 8)"
      },
      "ocaml": {
        "code": "let hypotenuse a b =\n  let a_square = a *. a in\n  let b_square = b *. b in\n  sqrt (a_square +. b_square)\nin\nhypotenuse 6.0 8.0"
      },
      "answer": "10"
    },
    "ejercicio-5": {
      "description": "Un chef diseña una olla esférica de radio 0.3 metros, calculando su volumen con la fórmula (4/3) * pi * r^3, donde pi = 3.14159. Define una función que compute el cubo del radio, lo multiplique por pi, y ajuste por la fracción 4/3. Evalúa con 0.3. Este ejercicio aumenta la complejidad con exponentes cúbicos, constantes y fracciones. Paso a paso: r = 0.3, r^3 = 0.3 * 0.3 * 0.3 = 0.027, pi * r^3 = 3.14159 * 0.027 ≈ 0.08482293, (4/3) * 0.08482293 ≈ 0.11309724. El resultado esperado es aproximadamente 0.11309724 metros cúbicos, útil para determinar capacidad.",
      "racket": {
        "code": "(define (sphere-volume r)\n  (let ((cube (* r r r))\n        (pi 3.14159)\n        (fraction (/ 4 3)))\n    (* fraction pi cube))\n)\n(sphere-volume 0.3)"
      },
      "ocaml": {
        "code": "let sphere_volume r =\n  let cube = r *. r *. r in\n  let pi = 3.14159 in\n  let fraction = 4.0 /. 3.0 in\n  fraction *. pi *. cube\nin\nsphere_volume 0.3"
      },
      "answer": "0.11309724"
    },
    "ejercicio-6": {
      "description": "Un financiero calcula el valor futuro de 1000 dólares con una tasa de interés compuesto del 4% anual, aplicada mensualmente durante 3 años, ajustada por una tarifa fija de 50 dólares, usando la fórmula p * (1 + r/n)^(n*t) - fee. Define una función que compute el factor de interés, eleve al número de períodos, multiplique por el principal y reste la tarifa. Evalúa con 1000, 0.04, 12, 3. Este ejercicio combina exponentes, divisiones, multiplicaciones y resta, con cuatro parámetros. Paso a paso: p = 1000, r = 0.04, n = 12, t = 3, factor = 1 + 0.04/12 ≈ 1.00333333, períodos = 12 * 3 = 36, factor^36 ≈ 1.12749786, valor = 1000 * 1.12749786 ≈ 1127.49786, menos 50 = 1077.49786. El resultado esperado es aproximadamente 1077.49786 dólares.",
      "racket": {
        "code": "(define (compound-interest p r n t)\n  (let ((rate-factor (+ 1 (/ r n)))\n        (periods (* n t))\n        (fee 50))\n    (- (* p (expt rate-factor periods)) fee))\n)\n(compound-interest 1000 0.04 12 3)"
      },
      "ocaml": {
        "code": "let compound_interest p r n t =\n  let rate_factor = 1.0 +. (r /. n) in\n  let periods = n *. t in\n  let fee = 50.0 in\n  (p *. (rate_factor ** periods)) -. fee\nin\ncompound_interest 1000.0 0.04 12.0 3.0"
      },
      "answer": "1077.49786"
    },
    "ejercicio-7": {
      "description": "Un astrónomo calcula la distancia entre dos puntos estelares en un sistema tridimensional con coordenadas (x1, y1, z1) = (2, 3, 4) y (x2, y2, z2) = (5, 7, 8), usando la fórmula de distancia euclidiana 3D: sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2). Define una función que compute las diferencias, sus cuadrados, la suma y la raíz cuadrada. Evalúa con 2, 3, 4, 5, 7, 8. Este ejercicio es el más robusto, con seis parámetros, múltiples restas, cuadrados, suma y raíz cuadrada, modelando geometría espacial avanzada. Paso a paso: x2 - x1 = 5 - 2 = 3, y2 - y1 = 7 - 3 = 4, z2 - z1 = 8 - 4 = 4, cuadrados: 3^2 = 9, 4^2 = 16, 4^2 = 16, suma = 9 + 16 + 16 = 41, raíz = sqrt(41) ≈ 6.403124237. El resultado esperado es aproximadamente 6.403124237, útil en astronomía y navegación.",
      "racket": {
        "code": "(define (distance-3d x1 y1 z1 x2 y2 z2)\n  (let ((dx (- x2 x1))\n        (dy (- y2 y1))\n        (dz (- z2 z1)))\n    (let ((dx-square (* dx dx))\n          (dy-square (* dy dy))\n          (dz-square (* dz dz)))\n      (sqrt (+ dx-square dy-square dz-square))))\n)\n(distance-3d 2 3 4 5 7 8)"
      },
      "ocaml": {
        "code": "let distance_3d x1 y1 z1 x2 y2 z2 =\n  let dx = x2 -. x1 in\n  let dy = y2 -. y1 in\n  let dz = z2 -. z1 in\n  let dx_square = dx *. dx in\n  let dy_square = dy *. dy in\n  let dz_square = dz *. dz in\n  sqrt (dx_square +. dy_square +. dz_square)\nin\ndistance_3d 2.0 3.0 4.0 5.0 7.0 8.0"
      },
      "answer": "6.403124237"
    }
  },
  "funciones-multiples": {
    "ejercicio-1": {
      "description": "Un artista pinta un mural triangular con base 8 metros y altura 5 metros. Define una función que calcule el área (base * altura / 2). Evalúa con 8 y 5. Esto introduce funciones con múltiples parámetros para cálculos geométricos simples.",
      "racket": {
        "code": "(define (triangle-area base height)\n  (/ (* base height) 2)\n)\n(triangle-area 8 5)"
      },
      "ocaml": {
        "code": "let triangle_area base height =\n  (base *. height) /. 2.0\nin\ntriangle_area 8.0 5.0"
      },
      "answer": "20"
    },
    "ejercicio-2": {
      "description": "Tres tareas toman 2, 3 y 4 minutos. Define una función que verifique si están en orden ascendente estricto. Usa pasos intermedios para comparar los tiempos. Evalúa con 2, 3 y 4. Esto muestra cómo combinar comparaciones lógicas con múltiples parámetros.",
      "racket": {
        "code": "(define (ascending? a b c)\n  (let ((ab (< a b))\n        (bc (< b c)))\n    (and ab bc))\n)\n(ascending? 2 3 4)"
      },
      "ocaml": {
        "code": "let ascending a b c =\n  let ab = a < b in\n  let bc = b < c in\n  ab && bc\nin\nascending 2 3 4"
      },
      "answer": "true"
    },
    "ejercicio-3": {
      "description": "Un estudiante camina de (1,2) a (4,6). Define una función para la distancia euclidiana: raíz de ((x2-x1)^2 + (y2-y1)^2). Evalúa con (1,2) y (4,6). Esto introduce cálculos geométricos complejos con cuatro parámetros.",
      "racket": {
        "code": "(define (distance x1 y1 x2 y2)\n  (sqrt (+ (expt (- x2 x1) 2)\n           (expt (- y2 y1) 2))\n  )\n)\n(distance 1 2 4 6)"
      },
      "ocaml": {
        "code": "let distance x1 y1 x2 y2 =\n  sqrt ((x2 -. x1) ** 2.0 +.\n        (y2 -. y1) ** 2.0)\nin\ndistance 1.0 2.0 4.0 6.0"
      },
      "answer": "5"
    },
    "ejercicio-4": {
      "description": "En un torneo, los puntajes son 6, 8 y 4. Define una función que encuentre el máximo de tres valores, usando pasos intermedios para comparar. Evalúa con 6, 8 y 4. Esto muestra cómo manejar selecciones complejas con múltiples parámetros.",
      "racket": {
        "code": "(define (max-of-three a b c)\n  (let ((bc (max b c))\n        (max-abc (max a bc)))\n    max-abc)\n)\n(max-of-three 6 8 4)"
      },
      "ocaml": {
        "code": "let max_of_three a b c =\n  let bc = max b c in\n  let max_abc = max a bc in\n  max_abc\nin\nmax_of_three 6 8 4"
      },
      "answer": "8"
    },
    "ejercicio-5": {
      "description": "Tres amigos gastan 10, 15 y 20 dólares. Define una función que calcule el promedio de tres valores, desglosando la suma y la división en pasos intermedios. Evalúa con 10, 15 y 20. Esto extiende los cálculos con múltiples parámetros para promedios robustos.",
      "racket": {
        "code": "(define (average-three a b c)\n  (let ((sum (+ a b c))\n        (avg (/ sum 3)))\n    avg)\n)\n(average-three 10 15 20)"
      },
      "ocaml": {
        "code": "let average_three a b c =\n  let sum = a + b + c in\n  let avg = sum / 3 in\n  avg\nin\naverage_three 10 15 20"
      },
      "answer": "15"
    },
    "ejercicio-6": {
      "description": "Un laboratorio mide presiones de 2, 3 y 4 kPa. Define una función que verifique si todas son positivas y están en orden ascendente, usando pasos intermedios para las validaciones. Evalúa con 2, 3 y 4. Esto combina múltiples validaciones lógicas con tres parámetros.",
      "racket": {
        "code": "(define (positive-and-ascending? a b c)\n  (let ((pos-a (> a 0))\n        (pos-b (> b 0))\n        (pos-c (> c 0))\n        (asc-ab (< a b))\n        (asc-bc (< b c)))\n    (and pos-a pos-b pos-c asc-ab asc-bc))\n)\n(positive-and-ascending? 2 3 4)"
      },
      "ocaml": {
        "code": "let positive_and_ascending a b c =\n  let pos_a = a > 0 in\n  let pos_b = b > 0 in\n  let pos_c = c > 0 in\n  let asc_ab = a < b in\n  let asc_bc = b < c in\n  pos_a && pos_b && pos_c && asc_ab && asc_bc\nin\npositive_and_ascending 2 3 4"
      },
      "answer": "true"
    },
    "ejercicio-7": {
      "description": "Una empresa calcula el volumen útil de una caja con dimensiones 3, 2, 4 metros y un margen de 0.1 metros en cada lado. Define una función que calcule el volumen útil (largo - 2*margen) * (ancho - 2*margen) * (alto - 2*margen). Evalúa con 3, 2, 4 y 0.1. Esto combina múltiples parámetros y pasos para cálculos prácticos avanzados.",
      "racket": {
        "code": "(define (useful-cuboid-volume l w h margin)\n  (let ((adj-l (- l (* 2 margin)))\n        (adj-w (- w (* 2 margin)))\n        (adj-h (- h (* 2 margin)))\n        (lw (* adj-l adj-w))\n        (volume (* lw adj-h)))\n    volume)\n)\n(useful-cuboid-volume 3 2 4 0.1)"
      },
      "ocaml": {
        "code": "let useful_cuboid_volume l w h margin =\n  let adj_l = l -. (2.0 *. margin) in\n  let adj_w = w -. (2.0 *. margin) in\n  let adj_h = h -. (2.0 *. margin) in\n  let lw = adj_l *. adj_w in\n  let volume = lw *. adj_h in\n  volume\nin\nuseful_cuboid_volume 3.0 2.0 4.0 0.1"
      },
      "answer": "19.008"
    }
  },
  "condicionales": {
    "ejercicio-1": {
      "description": "Las condicionales permiten decisiones. En una subasta, las ofertas son 10 y 7 dólares. Define una función que seleccione el mayor. Evalúa con 10 y 7. Esto introduce `if` para elegir valores basados en condiciones, manteniendo la pureza funcional.",
      "racket": {
        "code": "(define (max-two a b)\n  (if (> a b)\n      a\n      b\n  )\n)\n(max-two 10 7)"
      },
      "ocaml": {
        "code": "let max_two a b =\n  if a > b then\n    a\n  else\n    b\nin\nmax_two 10 7"
      },
      "answer": "10"
    },
    "ejercicio-2": {
      "description": "Clasificación con condicionales. Un sensor mide 3 grados Celsius. Define una función que clasifique como positivo, negativo o cero. Evalúa con 3. Esto muestra cómo usamos `cond` o `if-else` para categorizar valores.",
      "racket": {
        "code": "(define (classify-number x)\n  (cond\n    [(> x 0) 'positive]\n    [(< x 0) 'negative]\n    [else 'zero]\n  )\n)\n(classify-number 3)"
      },
      "ocaml": {
        "code": "let classify_number x =\n  if x > 0 then\n    \"positive\"\n  else if x < 0 then\n    \"negative\"\n  else\n    \"zero\"\nin\nclassify_number 3"
      },
      "answer": "positive"
    },
    "ejercicio-3": {
      "description": "Condiciones complejas. Para 2024, verifica si es bisiesto (divisible por 4, no por 100, salvo por 400). Define una función y evalúa con 2024. Esto muestra cómo anidamos condicionales para lógica avanzada.",
      "racket": {
        "code": "(define (leap-year? year)\n  (cond\n    [(= (remainder year 400) 0) #t]\n    [(= (remainder year 100) 0) #f]\n    [(= (remainder year 4) 0) #t]\n    [else #f]\n  )\n)\n(leap-year? 2024)"
      },
      "ocaml": {
        "code": "let leap_year year =\n  if year mod 400 = 0 then\n    true\n  else if year mod 100 = 0 then\n    false\n  else if year mod 4 = 0 then\n    true\n  else\n    false\nin\nleap_year 2024"
      },
      "answer": "true"
    },
    "ejercicio-4": {
      "description": "Clasificación numérica. Una reseña tiene puntuación -2. Define una función que devuelva el signo (1, -1, 0). Evalúa con -2. Esto refuerza cómo las condicionales producen valores basados en casos.",
      "racket": {
        "code": "(define (sign x)\n  (cond\n    [(> x 0) 1]\n    [(< x 0) -1]\n    [else 0]\n  )\n)\n(sign -2)"
      },
      "ocaml": {
        "code": "let sign x =\n  if x > 0 then\n    1\n  else if x < 0 then\n    -1\n  else\n    0\nin\nsign (-2)"
      },
      "answer": "-1"
    },
    "ejercicio-5": {
      "description": "Sistemas de calificación con anidación. Una estudiante obtiene 92.3. Define una función que primero clasifique según rangos, y dentro de cada rango, indique si está cerca del límite superior ('+') o inferior ('-'). Evalúa con 92.3. Esto muestra condicionales anidados con varias decisiones internas.",
      "racket": {
        "code": "(define (grade score)\n  (let ((rounded (round score)))\n    (cond\n      [(>= rounded 90)\n       (if (>= rounded 95)\n           'A+\n           'A-)]\n      [(>= rounded 80)\n       (if (>= rounded 85)\n           'B+\n           'B-)]\n      [(>= rounded 70)\n       (if (>= rounded 75)\n           'C+\n           'C-)]\n      [(>= rounded 60)\n       (if (>= rounded 65)\n           'D+\n           'D-)]\n      [else 'F]\n    )\n  )\n)\n(grade 92.3)"
      },
      "ocaml": {
        "code": "let grade score =\n  let rounded = int_of_float (Float.round score) in\n  if rounded >= 90 then\n    if rounded >= 95 then \"A+\" else \"A-\"\n  else if rounded >= 80 then\n    if rounded >= 85 then \"B+\" else \"B-\"\n  else if rounded >= 70 then\n    if rounded >= 75 then \"C+\" else \"C-\"\n  else if rounded >= 60 then\n    if rounded >= 65 then \"D+\" else \"D-\"\n  else\n    \"F\"\nin\ngrade 92.3"
      },
      "answer": "A-"
    },
    "ejercicio-6": {
      "description": "Condiciones lógicas anidadas. Una alarma se activa si el número es divisible por 2 y 3. Si no lo es, verifica si la raíz cuadrada redondeada es divisible por 5 o 7. Evalúa con 12. Esto muestra anidación de 'if' y uso mixto de 'and' y 'or'.",
      "racket": {
        "code": "(define (activate-alarm? x)\n  (if (and (= (remainder x 2) 0)\n           (= (remainder x 3) 0))\n      #t\n      (if (or (= (remainder (round (sqrt x)) 5) 0)\n              (= (remainder (round (sqrt x)) 7) 0))\n          #t\n          #f)))\n(activate-alarm? 12)"
      },
      "ocaml": {
        "code": "let activate_alarm x =\n  if x mod 2 = 0 && x mod 3 = 0 then\n    true\n  else if ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 5 = 0)\n       || ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 7 = 0) then\n    true\n  else\n    false\nin\nactivate_alarm 12"
      },
      "answer": "true"
    },
    "ejercicio-7": {
      "description": "Clasificación geométrica compleja. Un triángulo tiene lados 3, 3, 3. La función primero valida si los lados forman un triángulo. Si es válido, anida otra evaluación para clasificarlo en equilátero, isósceles o escaleno, y además indica si es pequeño (todos los lados < 5). Evalúa con 3, 3, 3. Esto muestra condicionales múltiples y anidados.",
      "racket": {
        "code": "(define (triangle-type a b c)\n  (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n      (cond\n        [(and (= a b) (= b c))\n         (if (< a 5)\n             'small-equilateral\n             'equilateral)]\n        [(or (= a b) (= b c) (= a c))\n         (if (< a 5)\n             'small-isosceles\n             'isosceles)]\n        [else\n         (if (< a 5)\n             'small-scalene\n             'scalene)])\n      'invalid))\n(triangle-type 3 3 3)"
      },
      "ocaml": {
        "code": "let triangle_type a b c =\n  if a + b > c && a + c > b && b + c > a then\n    if a = b && b = c then\n      if a < 5 then \"small-equilateral\" else \"equilateral\"\n    else if a = b || b = c || a = c then\n      if a < 5 then \"small-isosceles\" else \"isosceles\"\n    else\n      if a < 5 then \"small-scalene\" else \"scalene\"\n  else\n    \"invalid\"\nin\ntriangle_type 3 3 3"
      },
      "answer": "small-equilateral"
    }
  },
  "recursion": {
    "ejercicio-1": {
      "description": "La recursión reemplaza bucles. Un comerciante suma ventas de 1 a 4 dólares en 4 días. Define una función recursiva para sumar los primeros n números. Evalúa con 4. Esto muestra cómo la recursión acumula resultados sin estado.",
      "racket": {
        "code": "(define (sum-n n)\n  (if (<= n 0)\n      0\n      (+ n (sum-n (- n 1)))\n  )\n)\n(sum-n 4)"
      },
      "ocaml": {
        "code": "let rec sum_n n =\n  if n <= 0 then\n    0\n  else\n    n + sum_n (n - 1)\nin\nsum_n 4"
      },
      "answer": "10"
    },
    "ejercicio-2": {
      "description": "Recursión para potencias. Una inversión de 2 dólares se duplica 4 veces. Define una función recursiva para calcular 2^4. Evalúa con 2 y 4. Esto refuerza cómo la recursión maneja cálculos repetitivos.",
      "racket": {
        "code": "(define (power base exp)\n  (if (= exp 0)\n      1\n      (* base (power base (- exp 1)))\n  )\n)\n(power 2 4)"
      },
      "ocaml": {
        "code": "let rec power base exp =\n  if exp = 0 then\n    1\n  else\n    base * power base (exp - 1)\nin\npower 2 4"
      },
      "answer": "16"
    },
    "ejercicio-3": {
      "description": "Factoriales con recursión. Un gerente calcula formas de organizar 4 cajas (4!). Define una función recursiva para el factorial. Evalúa con 4. Esto muestra cómo la recursión resuelve problemas combinatorios.",
      "racket": {
        "code": "(define (factorial n)\n  (if (<= n 1)\n      1\n      (* n (factorial (- n 1)))\n  )\n)\n(factorial 4)"
      },
      "ocaml": {
        "code": "let rec factorial n =\n  if n <= 1 then\n    1\n  else\n    n * factorial (n - 1)\nin\nfactorial 4"
      },
      "answer": "24"
    },
    "ejercicio-4": {
      "description": "Secuencias recursivas. Un biólogo calcula el número de Fibonacci para el mes 6. Define una función recursiva para Fibonacci. Evalúa con 6. Esto introduce recursión doble para secuencias naturales.",
      "racket": {
        "code": "(define (fibonacci n)\n  (if (<= n 1)\n      n\n      (+ (fibonacci (- n 1))\n         (fibonacci (- n 2))\n      )\n  )\n)\n(fibonacci 6)"
      },
      "ocaml": {
        "code": "let rec fibonacci n =\n  if n <= 1 then\n    n\n  else\n    fibonacci (n - 1) +\n    fibonacci (n - 2)\nin\nfibonacci 6"
      },
      "answer": "8"
    },
    "ejercicio-5": {
      "description": "Procesamiento numérico. Un código postal 12345 se valida sumando sus dígitos. Define una función recursiva para sumar dígitos. Evalúa con 12345. Esto muestra cómo la recursión descompone números.",
      "racket": {
        "code": "(define (sum-digits n)\n  (if (< n 10)\n      n\n      (+ (remainder n 10)\n         (sum-digits (quotient n 10))\n      )\n  )\n)\n(sum-digits 12345)"
      },
      "ocaml": {
        "code": "let rec sum_digits n =\n  if n < 10 then\n    n\n  else\n    (n mod 10) +\n    sum_digits (n / 10)\nin\nsum_digits 12345"
      },
      "answer": "15"
    },
    "ejercicio-6": {
      "description": "Productos recursivos. Un matemático calcula el producto de los primeros 3 impares (1, 3, 5). Define una función recursiva para esto. Evalúa con 3. Esto extiende la recursión a productos específicos.",
      "racket": {
        "code": "(define (product-odds n)\n  (if (<= n 0)\n      1\n      (* (+ (* 2 n) -1)\n         (product-odds (- n 1))\n      )\n  )\n)\n(product-odds 3)"
      },
      "ocaml": {
        "code": "let rec product_odds n =\n  if n <= 0 then\n    1\n  else\n    (2 * n - 1) *\n    product_odds (n - 1)\nin\nproduct_odds 3"
      },
      "answer": "15"
    },
    "ejercicio-7": {
      "description": "Contar dígitos. Un número de teléfono 1234 se valida contando sus dígitos. Define una función recursiva para contar dígitos. Evalúa con 1234. Esto muestra cómo la recursión maneja descomposición numérica.",
      "racket": {
        "code": "(define (count-digits n)\n  (if (< n 10)\n      1\n      (+ 1 (count-digits (quotient n 10)))\n  )\n)\n(count-digits 1234)"
      },
      "ocaml": {
        "code": "let rec count_digits n =\n  if n < 10 then\n    1\n  else\n    1 + count_digits (n / 10)\nin\ncount_digits 1234"
      },
      "answer": "4"
    }
  },
  "listas": {
    "ejercicio-1": {
      "description": "Una organizadora tiene tareas (1 2 3 4). Define una función recursiva para contar elementos en una lista. Evalúa con (1 2 3 4). Esto introduce listas y recursión básica para procesarlas, ideal para principiantes.",
      "racket": {
        "code": "(define (length lst)\n  (if (empty? lst)\n      0\n      (+ 1 (length (rest lst)))\n  )\n)\n(length '(1 2 3 4))"
      },
      "ocaml": {
        "code": "let rec length lst =\n  if lst = [] then\n    0\n  else\n    1 + length (List.tl lst)\nin\nlength [1; 2; 3; 4]"
      },
      "answer": "4"
    },
    "ejercicio-2": {
      "description": "Un gerente prioriza las dos primeras tareas de (5 6 7 8 9). Define una función recursiva para obtener los dos primeros elementos de una lista, usando pasos intermedios para manejar casos vacíos y longitud. Evalúa con (5 6 7 8 9). Esto muestra cómo extraer múltiples datos con robustez.",
      "racket": {
        "code": "(define (first-two-elements lst)\n  (let ((len (length lst)))\n    (if (< len 1)\n        null\n        (let ((first-el (first lst))\n              (rest-lst (rest lst)))\n          (if (empty? rest-lst)\n              (list first-el)\n              (list first-el (first rest-lst))))))\n)\n(first-two-elements '(5 6 7 8 9))"
      },
      "ocaml": {
        "code": "let rec first_two_elements lst =\n  let len = List.length lst in\n  if len < 1 then\n    []\n  else\n    let first_el = List.hd lst in\n    let rest_lst = List.tl lst in\n    if rest_lst = [] then\n      [first_el]\n    else\n      [first_el; List.hd rest_lst]\nin\nfirst_two_elements [5; 6; 7; 8; 9]"
      },
      "answer": "(5 6)"
    },
    "ejercicio-3": {
      "description": "En una cola (1 2 3 4 5), el último cliente espera más. Define una función recursiva para obtener el último elemento, con pasos intermedios para verificar la longitud y manejar sublistas. Evalúa con (1 2 3 4 5). Esto introduce recursión más robusta para navegar listas largas.",
      "racket": {
        "code": "(define (last-element lst)\n  (let ((len (length lst)))\n    (if (< len 1)\n        null\n        (let ((rest-lst (rest lst))\n              (len-rest (length rest-lst)))\n          (if (= len-rest 0)\n              (first lst)\n              (last-element rest-lst)))))\n)\n(last-element '(1 2 3 4 5))"
      },
      "ocaml": {
        "code": "let rec last_element lst =\n  let len = List.length lst in\n  if len < 1 then\n    None\n  else\n    let rest_lst = List.tl lst in\n    let len_rest = List.length rest_lst in\n    if len_rest = 0 then\n      Some (List.hd lst)\n    else\n      last_element rest_lst\nin\nlast_element [1; 2; 3; 4; 5]"
      },
      "answer": "5"
    },
    "ejercicio-4": {
      "description": "Un mercado une frutas (1 2), verduras (3 4), y lácteos (5 6). Define una función recursiva para concatenar tres listas, con pasos intermedios para verificar longitud y combinar listas. Evalúa con (1 2), (3 4), (5 6). Esto aumenta la complejidad al manejar múltiples listas.",
      "racket": {
        "code": "(define (append-three lst1 lst2 lst3)\n  (let ((len1 (length lst1))\n        (append12 (if (empty? lst1)\n                      lst2\n                      (cons (first lst1)\n                            (append-three (rest lst1) lst2 lst3)))))\n    (if (empty? append12)\n        lst3\n        (let ((first-12 (first append12))\n              (rest-12 (rest append12)))\n          (cons first-12 (append-three rest-12 lst3 '())))))\n)\n(append-three '(1 2) '(3 4) '(5 6))"
      },
      "ocaml": {
        "code": "let rec append_three lst1 lst2 lst3 =\n  let len1 = List.length lst1 in\n  let append12 = if lst1 = [] then\n                   lst2\n                 else\n                   List.hd lst1 :: append_three (List.tl lst1) lst2 lst3 in\n  if append12 = [] then\n    lst3\n  else\n    let first_12 = List.hd append12 in\n    let rest_12 = List.tl append12 in\n    first_12 :: append_three rest_12 lst3 []\nin\nappend_three [1; 2] [3; 4] [5; 6]"
      },
      "answer": "(1 2 3 4 5 6)"
    },
    "ejercicio-5": {
      "description": "Un estudiante completa la primera y última tarea de (1 2 3 4 5 6). Define una función recursiva para obtener los elementos intermedios (sin el primero ni el último), con pasos intermedios para longitud y sublistas. Evalúa con (1 2 3 4 5 6). Esto aumenta la robustez al manipular listas largas.",
      "racket": {
        "code": "(define (middle-elements lst)\n  (let ((len (length lst))\n        (rest-lst (if (empty? lst) null (rest lst))))\n    (if (< len 2)\n        null\n        (let ((len-rest (length rest-lst))\n              (middle-rest (if (empty? rest-lst) null (rest rest-lst))))\n          (if (<= len-rest 1)\n              null\n              (cons (first rest-lst) (middle-elements rest-lst))))))\n)\n(middle-elements '(1 2 3 4 5 6))"
      },
      "ocaml": {
        "code": "let rec middle_elements lst =\n  let len = List.length lst in\n  let rest_lst = if lst = [] then [] else List.tl lst in\n  if len < 2 then\n    []\n  else\n    let len_rest = List.length rest_lst in\n    let middle_rest = if rest_lst = [] then [] else List.tl rest_lst in\n    if len_rest <= 1 then\n      []\n    else\n      List.hd rest_lst :: middle_elements rest_lst\nin\nmiddle_elements [1; 2; 3; 4; 5; 6]"
      },
      "answer": "(2 3 4 5)"
    },
    "ejercicio-6": {
      "description": "Una aplicación verifica si todas las sublistas en ((1 2) () (3 4) ()) son vacías, con pasos intermedios para contar elementos y manejar sublistas recursivamente. Evalúa con ((1 2) () (3 4) ()). Esto combina recursión anidada y verificaciones complejas en listas de listas.",
      "racket": {
        "code": "(define (all-empty? lst)\n  (let ((len (length lst))\n        (first-sublist (if (empty? lst) null (first lst)))\n        (rest-sublists (if (empty? lst) null (rest lst))))\n    (if (= len 0)\n        true\n        (let ((len-first (length first-sublist))\n              (rest-empty (all-empty? rest-sublists)))\n          (and (= len-first 0) rest-empty))))\n)\n(all-empty? '((1 2) () (3 4) ()))"
      },
      "ocaml": {
        "code": "let rec all_empty lst =\n  let len = List.length lst in\n  let first_sublist = if lst = [] then [] else List.hd lst in\n  let rest_sublists = if lst = [] then [] else List.tl lst in\n  if len = 0 then\n    true\n  else\n    let len_first = List.length first_sublist in\n    let rest_empty = all_empty rest_sublists in\n    len_first = 0 && rest_empty\nin\nall_empty [[1; 2]; []; [3; 4]; []]"
      },
      "answer": "false"
    },
    "ejercicio-7": {
      "description": "Un programador transforma un elemento y lo añade a (1 2 3 4), multiplicándolo por 2 (0*2=0), con pasos intermedios para transformar, verificar longitud, y construir la lista recursivamente usando una función auxiliar. Evalúa con 0 y (1 2 3 4). Esto combina transformación, recursión y construcción de listas dinámicas.",
      "racket": {
        "code": "(define (cons-transformed-aux x lst acc)\n  (let ((transformed (* x 2))\n        (len (length lst))\n        (new-lst (cons transformed lst)))\n    (if (empty? new-lst)\n        acc\n        (let ((first-el (first new-lst))\n              (rest-el (rest new-lst))\n              (len-rest (length rest-el)))\n          (cons-transformed-aux 0 rest-el (cons first-el acc))))\n)\n(define (cons-transformed x lst)\n  (cons-transformed-aux x lst null)\n)\n(cons-transformed 0 '(1 2 3 4))"
      },
      "ocaml": {
        "code": "let rec cons_transformed_aux x lst acc =\n  let transformed = x * 2 in\n  let len = List.length lst in\n  let new_lst = transformed :: lst in\n  if new_lst = [] then\n    List.rev acc\n  else\n    let first_el = List.hd new_lst in\n    let rest_el = List.tl new_lst in\n    let len_rest = List.length rest_el in\n    cons_transformed_aux 0 rest_el (first_el :: acc)\nlet cons_transformed x lst =\n  cons_transformed_aux x lst []\nin\ncons_transformed 0 [1; 2; 3; 4]"
      },
      "answer": "(0 1 2 3 4)"
    }
  },
  "funciones-orden-superior": {
    "ejercicio-1": {
      "description": "Introducción a funciones de orden superior con transformaciones simples. Una tienda aplica un descuento del 15% a una lista de precios de productos: (100 200 300). Define una función que use 'map' para aplicar el descuento multiplicando cada precio por 0.85. Maneja listas vacías devolviendo una lista vacía. Evalúa con (100 200 300). Este ejercicio introduce el paso de funciones como argumentos para transformaciones básicas.",
      "racket": {
        "code": "(define (apply-discount lst)\n  (if (empty? lst)\n      '()\n      (map (lambda (x) (* x 0.85)) lst)\n  )\n)\n(apply-discount '(100 200 300))"
      },
      "ocaml": {
        "code": "let apply_discount lst =\n  if lst = [] then\n    []\n  else\n    List.map (fun x -> x *. 0.85) lst\nin\napply_discount [100; 200; 300]"
      },
      "answer": "(85.0 170.0 255.0)"
    },
    "ejercicio-2": {
      "description": "Filtrado con condiciones compuestas. Un inventario filtra productos con stock mayor a 5 y precio menor a 50: (10 60 30 40 70). Define una función que use 'filter' con un predicado compuesto para seleccionar elementos que cumplan ambas condiciones. Asegura manejo de listas vacías. Evalúa con la lista dada. Este ejercicio avanza en el uso de predicados funcionales para filtrado selectivo.",
      "racket": {
        "code": "(define (filter-stock lst)\n  (if (empty? lst)\n      '()\n      (filter (lambda (x) (and (> x 5) (< x 50))) lst)\n  )\n)\n(filter-stock '(10 60 30 40 70))"
      },
      "ocaml": {
        "code": "let filter_stock lst =\n  if lst = [] then\n    []\n  else\n    List.filter (fun x -> x > 5 && x < 50) lst\nin\nfilter_stock [10; 60; 30; 40; 70]"
      },
      "answer": "(10 30 40)"
    },
    "ejercicio-3": {
      "description": "Transformación y filtrado combinados. Una empresa calcula costos de producción: (2 3 -4 5 -6). Filtra valores absolutos mayores a 3 y luego eleva al cuadrado los resultados. Usa 'filter' para seleccionar y 'map' para transformar. Maneja listas vacías y valores negativos. Evalúa con la lista dada. Este ejercicio introduce pipelines funcionales con múltiples transformaciones.",
      "racket": {
        "code": "(define (process-costs lst)\n  (if (empty? lst)\n      '()\n      (let ((filtered (filter (lambda (x) (> (abs x) 3)) lst)))\n        (map (lambda (x) (* (abs x) (abs x))) filtered)\n      )\n  )\n)\n(process-costs '(2 3 -4 5 -6))"
      },
      "ocaml": {
        "code": "let process_costs lst =\n  if lst = [] then\n    []\n  else\n    let filtered = List.filter (fun x -> abs x > 3) lst in\n    List.map (fun x -> (abs x) * (abs x)) filtered\nin\nprocess_costs [2; 3; -4; 5; -6]"
      },
      "answer": "(16 25 36)"
    },
    "ejercicio-4": {
      "description": "Acumulación con funciones de orden superior. Un sistema registra transacciones: (100 -50 200 -30 150). Calcula la suma de transacciones positivas mayores a 100 usando 'filter' y 'foldl' (o fold_left). Parametriza el umbral y la operación de acumulación. Maneja listas vacías devolviendo 0. Evalúa con la lista dada. Este ejercicio introduce acumuladores funcionales para procesar datos filtrados.",
      "racket": {
        "code": "(define (sum-transactions threshold lst)\n  (if (empty? lst)\n      0\n      (foldl + 0 (filter (lambda (x) (> x threshold)) lst))\n  )\n)\n(sum-transactions 100 '(100 -50 200 -30 150))"
      },
      "ocaml": {
        "code": "let sum_transactions threshold lst =\n  if lst = [] then\n    0\n  else\n    List.fold_left (+) 0 (List.filter (fun x -> x > threshold) lst)\nin\nsum_transactions 100 [100; -50; 200; -30; 150]"
      },
      "answer": "350"
    },
    "ejercicio-5": {
      "description": "Currying y funciones devueltas. Un sistema financiero procesa valores: (-200 300 -100 400), aplicando valor absoluto, filtrando mayores a 150, y sumándolos. Define una función de orden superior que tome un umbral y devuelva una función que realice el procesamiento (map para absoluto, filter para umbral, fold para suma). Maneja listas vacías devolviendo 0. Evalúa con umbral 150 y la lista dada. Este ejercicio explora cierres y configuraciones dinámicas.",
      "racket": {
        "code": "(define (make-financial-processor threshold)\n  (lambda (lst)\n    (if (empty? lst)\n        0\n        (foldl + 0\n               (filter (lambda (x) (> x threshold))\n                       (map abs lst)\n               )\n        )\n    )\n  )\n)\n((make-financial-processor 150) '(-200 300 -100 400))"
      },
      "ocaml": {
        "code": "let make_financial_processor threshold =\n  fun lst ->\n    if lst = [] then\n      0\n    else\n      List.fold_left (+) 0\n        (List.filter (fun x -> x > threshold)\n           (List.map abs lst)\n        )\nin\nmake_financial_processor 150 [-200; 300; -100; 400]"
      },
      "answer": "700"
    },
    "ejercicio-6": {
      "description": "Procesamiento de datos estructurados. Una base de datos almacena registros de ventas como parejas (monto . tipo): ((200 . \"venta\") (-50 . \"devolucion\") (300 . \"venta\") (-20 . \"devolucion\")). Filtra ventas positivas, extrae montos y calcula la suma total. Define una función que acepte un predicado y una función extractora, usando 'filter', 'map' y 'fold'. Maneja listas vacías devolviendo 0. Evalúa con la lista dada. Este ejercicio trabaja con estructuras complejas y abstracciones funcionales.",
      "racket": {
        "code": "(define (process-sales pred extractor lst)\n  (if (empty? lst)\n      0\n      (foldl + 0\n             (map extractor\n                  (filter pred lst)\n             )\n      )\n  )\n)\n(process-sales\n  (lambda (p) (and (string=? (cdr p) \"venta\") (> (car p) 0)))\n  car\n  '((200 . \"venta\") (-50 . \"devolucion\") (300 . \"venta\") (-20 . \"devolucion\"))\n)"
      },
      "ocaml": {
        "code": "let process_sales pred extractor lst =\n  if lst = [] then\n    0\n  else\n    List.fold_left (+) 0\n      (List.map extractor\n         (List.filter pred lst)\n      )\nin\nprocess_sales\n  (fun (m, t) -> t = \"venta\" && m > 0)\n  fst\n  [(200, \"venta\"); (-50, \"devolucion\"); (300, \"venta\"); (-20, \"devolucion\")]\n"
      },
      "answer": "500"
    },
    "ejercicio-7": {
      "description": "Pipelines complejos con datos anidados. Una escuela gestiona calificaciones en listas anidadas: ((70 80 90) (60 85 95) (50 60)). Filtra calificaciones aprobadas (>70) por estudiante, calcula el promedio por estudiante, y selecciona estudiantes con promedio mayor a 80. Usa 'map', 'filter' y 'fold' anidados, manejando listas vacías y sublistas vacías devolviendo resultados apropiados (0 para promedios vacíos, lista vacía para resultado final). Evalúa con la lista dada. Este ejercicio demuestra composición avanzada y manejo de datos multinivel.",
      "racket": {
        "code": "(define (process-grades lst)\n  (if (empty? lst)\n      '()\n      (filter (lambda (avg) (> avg 80))\n              (map (lambda (sublst)\n                     (if (empty? sublst)\n                         0\n                         (let ((approved (filter (lambda (g) (> g 70)) sublst)))\n                           (if (empty? approved)\n                               0\n                               (/ (foldl + 0 approved) (length approved))\n                           )\n                         )\n                     )\n                   lst\n              )\n      )\n  )\n)\n(process-grades '((70 80 90) (60 85 95) (50 60)))"
      },
      "ocaml": {
        "code": "let process_grades lst =\n  if lst = [] then\n    []\n  else\n    List.filter (fun avg -> avg > 80)\n      (List.map (fun sublst ->\n                   if sublst = [] then\n                     0\n                   else\n                     let approved = List.filter (fun g -> g > 70) sublst in\n                     if approved = [] then\n                       0\n                     else\n                       (List.fold_left (+) 0 approved) / (List.length approved)\n                ) lst\n      )\nin\nprocess_grades [[70; 80; 90]; [60; 85; 95]; [50; 60]]"
      },
      "answer": "(85 90)"
    }
  },
  "tipos-datos-simples": {
    "ejercicio-1": {
      "description": "Suma de tuplas con validación. Una empresa registra horas trabajadas como una tupla (5, 3). Define una función que sume los valores de una tupla, verificando que ambos sean números. Evalúa con (5, 3). Este ejercicio introduce el manejo de datos estructurados y validación básica en programación funcional.",
      "racket": {
        "code": "(define (sum-tuple t)\n  (if (and (pair? t) (number? (car t)) (number? (cdr t)))\n      (+ (car t) (cdr t))\n      (error \"Input must be a pair of numbers\"))\n)\n(sum-tuple '(5 . 3))"
      },
      "ocaml": {
        "code": "let sum_tuple (a, b) =\n  if (is_int a && is_int b) || (is_float a && is_float b) then\n    a +. (float_of_int b)\n  else\n    failwith \"Input must be a pair of numbers\"\nin\nsum_tuple (5, 3)"
      },
      "answer": "8"
    },
    "ejercicio-2": {
      "description": "Extracción segura de coordenadas. Una coordenada se representa como (7, 8). Define una función que extraiga el primer elemento, verificando que la entrada sea una tupla válida. Evalúa con (7, 8). Este ejercicio refuerza el acceso a datos estructurados con manejo de errores.",
      "racket": {
        "code": "(define (first-of-tuple t)\n  (if (pair? t)\n      (car t)\n      (error \"Input must be a pair\"))\n)\n(first-of-tuple '(7 . 8))"
      },
      "ocaml": {
        "code": "let first_of_tuple (a, _) =\n  a\nin\nfirst_of_tuple (7, 8)"
      },
      "answer": "7"
    },
    "ejercicio-3": {
      "description": "Registros personalizados con validación. Un registro de persona es ('Ana', 20). Define una función que extraiga la edad, asegurando que la entrada sea un registro válido y la edad un número positivo. Evalúa con ('Ana', 20). Este ejercicio introduce estructuras definidas por el usuario con robustez.",
      "racket": {
        "code": "(struct person (name age))\n(define (get-age p)\n  (if (and (person? p) (number? (person-age p)) (> (person-age p) 0))\n      (person-age p)\n      (error \"Invalid person or age\"))\n)\n(get-age (person \"Ana\" 20))"
      },
      "ocaml": {
        "code": "type person = { name: string; age: int }\nlet get_age p =\n  if p.age > 0 then\n    p.age\n  else\n    failwith \"Age must be positive\"\nin\nget_age { name = \"Ana\"; age = 20 }"
      },
      "answer": "20"
    },
    "ejercicio-4": {
      "description": "Volumen de una caja con tupla triple. Una caja tiene dimensiones (2, 3, 4). Define una función que calcule el volumen multiplicando los valores, verificando que sean números positivos. Evalúa con (2, 3, 4). Este ejercicio extiende el uso de tuplas con cálculos más complejos y validación.",
      "racket": {
        "code": "(define (product-triple t)\n  (if (and (list? t) (= (length t) 3)\n           (andmap number? t) (andmap positive? t))\n      (* (car t) (cadr t) (caddr t))\n      (error \"Input must be a list of three positive numbers\"))\n)\n(product-triple '(2 3 4))"
      },
      "ocaml": {
        "code": "let product_triple (a, b, c) =\n  if a > 0 && b > 0 && c > 0 then\n    a * b * c\n  else\n    failwith \"Dimensions must be positive\"\nin\nproduct_triple (2, 3, 4)"
      },
      "answer": "24"
    },
    "ejercicio-5": {
      "description": "Comparación robusta de tuplas. Un sistema compara coordenadas (1, 2) y (1, 2). Define una función que verifique si dos tuplas son iguales, asegurando que ambas sean tuplas válidas de números. Evalúa con (1, 2) y (1, 2). Este ejercicio introduce comparación de estructuras con validación.",
      "racket": {
        "code": "(define (equal-tuples? t1 t2)\n  (if (and (pair? t1) (pair? t2)\n           (number? (car t1)) (number? (cdr t1))\n           (number? (car t2)) (number? (cdr t2)))\n      (and (= (car t1) (car t2)) (= (cdr t1) (cdr t2)))\n      (error \"Inputs must be pairs of numbers\"))\n)\n(equal-tuples? '(1 . 2) '(1 . 2))"
      },
      "ocaml": {
        "code": "let equal_tuples (a1, b1) (a2, b2) =\n  if (is_int a1 && is_int b1 && is_int a2 && is_int b2) ||\n     (is_float a1 && is_float b1 && is_float a2 && is_float b2) then\n    a1 = a2 && b1 = b2\n  else\n    failwith \"Inputs must be pairs of numbers\"\nin\nequal_tuples (1, 2) (1, 2)"
      },
      "answer": "true"
    },
    "ejercicio-6": {
      "description": "Extracción avanzada de registros. Un censo registra personas con nombre, edad y ciudad ('Bob', 25, 'Paris'). Define una función que extraiga el nombre, verificando que sea un registro válido y el nombre no esté vacío. Evalúa con ('Bob', 25, 'Paris'). Este ejercicio refuerza el manejo de estructuras complejas con validación estricta.",
      "racket": {
        "code": "(struct person (name age city))\n(define (get-name p)\n  (if (and (person? p) (string? (person-name p)) (not (string=? (person-name p) \"\")))\n      (person-name p)\n      (error \"Invalid person or empty name\"))\n)\n(get-name (person \"Bob\" 25 \"Paris\"))"
      },
      "ocaml": {
        "code": "type person = { name: string; age: int; city: string }\nlet get_name p =\n  if p.name <> \"\" then\n    p.name\n  else\n    failwith \"Name must not be empty\"\nin\nget_name { name = \"Bob\"; age = 25; city = \"Paris\" }"
      },
      "answer": "Bob"
    },
    "ejercicio-7": {
      "description": "Construcción y procesamiento de registros anidados. Un sistema registra un estudiante con nombre, edad y notas ('Carlos', 22, (90, 85)). Define una función que cree un registro y devuelva una tupla con el nombre y el promedio de notas, validando que las notas sean números positivos. Evalúa con 'Carlos', 22, (90, 85). Este ejercicio combina creación de estructuras, cálculos y validación avanzada.",
      "racket": {
        "code": "(struct student (name age grades))\n(define (student-info name age grades)\n  (if (and (string? name) (not (string=? name \"\"))\n           (number? age) (> age 0)\n           (list? grades) (not (empty? grades)) (andmap positive? grades))\n      (let ((s (student name age grades)))\n        (cons (student-name s)\n              (/ (foldl + 0 grades) (length grades))))\n      (error \"Invalid input: name, age, or grades\"))\n)\n(student-info \"Carlos\" 22 '(90 85))"
      },
      "ocaml": {
        "code": "type student = { name: string; age: int; grades: int list }\nlet student_info name age grades =\n  if name <> \"\" && age > 0 && grades <> [] &&\n     List.for_all (fun x -> x > 0) grades then\n    let s = { name; age; grades } in\n    (s.name, (List.fold_left (+) 0 grades) / (List.length grades))\n  else\n    failwith \"Invalid input: name, age, or grades\"\nin\nstudent_info \"Carlos\" 22 [90; 85]"
      },
      "answer": "(Carlos 87)"
    }
  },
  "cadenas-y-caracteres": {
    "ejercicio-1": {
      "description": "Cadenas para texto. Una aplicación valida que 'admin' tenga 5 caracteres. Define una función para contar la longitud. Evalúa con 'admin'. Esto introduce el manejo de cadenas en funcional.",
      "racket": {
        "code": "(define (string-length str)\n  (string-length str)\n)\n(string-length \"admin\")"
      },
      "ocaml": {
        "code": "let string_length str =\n  String.length str\nin\nstring_length \"admin\""
      },
      "answer": "5"
    },
    "ejercicio-2": {
      "description": "Concatenar cadenas. Un sistema genera 'hola mundo' uniendo 'hola' y 'mundo' con un espacio. Define una función para esto. Evalúa con 'hola' y 'mundo'. Esto muestra cómo manipulamos texto.",
      "racket": {
        "code": "(define (concat-strings s1 s2)\n  (string-append s1 \" \" s2)\n)\n(concat-strings \"hola\" \"mundo\")"
      },
      "ocaml": {
        "code": "let concat_strings s1 s2 =\n  s1 ^ \" \" ^ s2\nin\nconcat_strings \"hola\" \"mundo\""
      },
      "answer": "hola mundo"
    },
    "ejercicio-3": {
      "description": "Acceder a caracteres. Un diseñador usa la inicial de 'gato' para un monograma. Define una función para obtener el primer carácter. Evalúa con 'gato'. Esto introduce el manejo de caracteres.",
      "racket": {
        "code": "(define (first-char str)\n  (string-ref str 0)\n)\n(first-char \"gato\")"
      },
      "ocaml": {
        "code": "let first_char str =\n  if str = \"\" then\n    None\n  else\n    Some (String.get str 0)\nin\nfirst_char \"gato\""
      },
      "answer": "g"
    },
    "ejercicio-4": {
      "description": "Transformar cadenas. Un cartel usa 'welcome' en mayúsculas. Define una función para convertir a mayúsculas. Evalúa con 'welcome'. Esto muestra cómo transformamos texto funcionalmente.",
      "racket": {
        "code": "(define (to-upper str)\n  (string-upcase str)\n)\n(to-upper \"welcome\")"
      },
      "ocaml": {
        "code": "let to_upper str =\n  String.uppercase_ascii str\nin\nto_upper \"welcome\""
      },
      "answer": "WELCOME"
    },
    "ejercicio-5": {
      "description": "Verificar cadenas. Un formulario comprueba si '' está vacío. Define una función para esto. Evalúa con ''. Esto introduce validaciones de cadenas en funcional.",
      "racket": {
        "code": "(define (empty-string? str)\n  (string=? str \"\")\n)\n(empty-string? \"\")"
      },
      "ocaml": {
        "code": "let empty_string str =\n  str = \"\"\nin\nempty_string \"\""
      },
      "answer": "true"
    },
    "ejercicio-6": {
      "description": "Extraer subcadenas. Un programador toma 'yth' de 'python' desde la posición 1 con longitud 3. Define una función para esto. Evalúa con 'python', 1, 3. Esto muestra manipulación precisa de cadenas.",
      "racket": {
        "code": "(define (substring-from str start len)\n  (substring str start (+ start len))\n)\n(substring-from \"python\" 1 3)"
      },
      "ocaml": {
        "code": "let substring_from str start len =\n  String.sub str start len\nin\nsubstring_from \"python\" 1 3"
      },
      "answer": "yth"
    },
    "ejercicio-7": {
      "description": "Contar vocales. Un juego cuenta vocales en 'hello'. Define una función para contar a, e, i, o, u. Evalúa con 'hello'. Esto combina listas y cadenas para procesamiento avanzado.",
      "racket": {
        "code": "(define (count-vowels str)\n  (length\n    (filter (lambda (c)\n              (member c '(#\\a #\\e #\\i #\\o #\\u))\n            )\n            (string->list str))\n  )\n)\n(count-vowels \"hello\")"
      },
      "ocaml": {
        "code": "let count_vowels str =\n  String.fold_left\n    (fun acc c ->\n       if List.mem c ['a'; 'e'; 'i'; 'o'; 'u'] then\n         acc + 1\n       else\n         acc\n    ) 0 str\nin\ncount_vowels \"hello\""
      },
      "answer": "2"
    }
  },
  "composicion-de-funciones": {
    "ejercicio-1": {
      "description": "Componer funciones es poderoso. Un demógrafo procesa una edad 5 sumando 1 y elevando al cuadrado. Define una función que componga estas operaciones. Evalúa con 5. Esto introduce composición para combinar cálculos.",
      "racket": {
        "code": "(define (compose-square-plus-one x)\n  ((compose (lambda (x) (* x x))\n            (lambda (x) (+ x 1))\n   )\n   x\n  )\n)\n(compose-square-plus-one 5)"
      },
      "ocaml": {
        "code": "let compose_square_plus_one x =\n  (fun x -> x * x)\n  ((fun x -> x + 1) x)\nin\ncompose_square_plus_one 5"
      },
      "answer": "36"
    },
    "ejercicio-2": {
      "description": "Composición para ajustes. Un salario de 10 dólares se ajusta restando 3 y duplicando. Define una función que componga duplicar después de restar 3. Evalúa con 10. Esto muestra cómo encadenamos transformaciones.",
      "racket": {
        "code": "(define (compose-double-minus-three x)\n  ((compose (lambda (x) (* x 2))\n            (lambda (x) (- x 3))\n   )\n   x\n  )\n)\n(compose-double-minus-three 10)"
      },
      "ocaml": {
        "code": "let compose_double_minus_three x =\n  (fun x -> x * 2)\n  ((fun x -> x - 3) x)\nin\ncompose_double_minus_three 10"
      },
      "answer": "14"
    },
    "ejercicio-3": {
      "description": "Composición múltiple. Un científico procesa 3: duplica, suma 1, eleva al cuadrado. Define una función que componga estas operaciones. Evalúa con 3. Esto extiende la composición a múltiples pasos.",
      "racket": {
        "code": "(define (compose-three x)\n  ((compose (lambda (x) (* x x))\n            (compose (lambda (x) (+ x 1))\n                     (lambda (x) (* x 2))\n            )\n   )\n   x\n  )\n)\n(compose-three 3)"
      },
      "ocaml": {
        "code": "let compose_three x =\n  (fun x -> x * x)\n  ((fun x -> x + 1)\n   ((fun x -> x * 2) x)\n  )\nin\ncompose_three 3"
      },
      "answer": "49"
    },
    "ejercicio-4": {
      "description": "Composición con condicionales. Un error de -3 se corrige sumando 5 y tomando el valor absoluto. Define una función que componga estas operaciones. Evalúa con -3. Esto combina lógica y composición.",
      "racket": {
        "code": "(define (compose-abs-plus-five x)\n  ((compose (lambda (x)\n              (if (< x 0)\n                  (- x)\n                  x\n              ))\n            (lambda (x) (+ x 5))\n   )\n   x\n  )\n)\n(compose-abs-plus-five -3)"
      },
      "ocaml": {
        "code": "let compose_abs_plus_five x =\n  (fun x ->\n     if x < 0 then\n       -x\n     else\n       x\n  )\n  ((fun x -> x + 5) x)\nin\ncompose_abs_plus_five (-3)"
      },
      "answer": "2"
    },
    "ejercicio-5": {
      "description": "Ajustes compuestos. Un bono de 4 dólares se calcula restando 1 y triplicando. Define una función que componga triplicar después de restar 1. Evalúa con 4. Esto refuerza la composición para transformaciones.",
      "racket": {
        "code": "(define (compose-triple-minus-one x)\n  ((compose (lambda (x) (* x 3))\n            (lambda (x) (- x 1))\n   )\n   x\n  )\n)\n(compose-triple-minus-one 4)"
      },
      "ocaml": {
        "code": "let compose_triple_minus_one x =\n  (fun x -> x * 3)\n  ((fun x -> x - 1) x)\nin\ncompose_triple_minus_one 4"
      },
      "answer": "9"
    },
    "ejercicio-6": {
      "description": "Composición con lógica. Un matemático verifica si el cuadrado de 3 es par. Define una función que componga paridad después de elevar al cuadrado. Evalúa con 3. Esto muestra composición con resultados booleanos.",
      "racket": {
        "code": "(define (compose-square-even x)\n  ((compose (lambda (x) (= (remainder x 2) 0))\n            (lambda (x) (* x x))\n   )\n   x\n  )\n)\n(compose-square-even 3)"
      },
      "ocaml": {
        "code": "let compose_square_even x =\n  (fun x -> x mod 2 = 0)\n  ((fun x -> x * x) x)\nin\ncompose_square_even 3"
      },
      "answer": "true"
    },
    "ejercicio-7": {
      "description": "Corrección compuesta. Un error de -4 se corrige tomando el valor absoluto y duplicando. Define una función que componga duplicar después del valor absoluto. Evalúa con -4. Esto combina condicionales y composición.",
      "racket": {
        "code": "(define (compose-double-abs x)\n  ((compose (lambda (x) (* x 2))\n            (lambda (x)\n              (if (< x 0)\n                  (- x)\n                  x\n              ))\n   )\n   x\n  )\n)\n(compose-double-abs -4)"
      },
      "ocaml": {
        "code": "let compose_double_abs x =\n  (fun x -> x * 2)\n  ((fun x ->\n      if x < 0 then\n        -x\n      else\n        x\n   ) x)\nin\ncompose_double_abs (-4)"
      },
      "answer": "8"
    }
  },
  "procesamiento-listas": {
    "ejercicio-1": {
      "description": "Procesar listas es clave en funcional. Un comerciante suma ventas (2 3 4). Define una función recursiva para sumar todos los elementos. Evalúa con (2 3 4). Esto combina listas y recursión para cálculos acumulados.",
      "racket": {
        "code": "(define (sum-list lst)\n  (if (empty? lst)\n      0\n      (+ (first lst)\n         (sum-list (rest lst)))\n  )\n)\n(sum-list '(2 3 4))"
      },
      "ocaml": {
        "code": "let rec sum_list lst =\n  if lst = [] then\n    0\n  else\n    List.hd lst + sum_list (List.tl lst)\nin\nsum_list [2; 3; 4]"
      },
      "answer": "9"
    },
    "ejercicio-2": {
      "description": "Transformar listas. Un chef triplica ingredientes (1 2 3). Define una función con map para multiplicar por 3. Evalúa con (1 2 3). Esto muestra cómo map aplica transformaciones a listas enteras.",
      "racket": {
        "code": "(define (triple-list lst)\n  (map (lambda (x) (* x 3))\n       lst\n  )\n)\n(triple-list '(1 2 3))"
      },
      "ocaml": {
        "code": "let triple_list lst =\n  List.map (fun x -> x * 3) lst\nin\ntriple_list [1; 2; 3]"
      },
      "answer": "(3 6 9)"
    },
    "ejercicio-3": {
      "description": "Filtrar listas. Un sorteo selecciona números impares de (1 2 3 4). Define una función con filter para impares. Evalúa con (1 2 3 4). Esto introduce filtrado para subconjuntos específicos.",
      "racket": {
        "code": "(define (odd-numbers lst)\n  (filter (lambda (x) (= (remainder x 2) 1))\n          lst\n  )\n)\n(odd-numbers '(1 2 3 4))"
      },
      "ocaml": {
        "code": "let odd_numbers lst =\n  List.filter (fun x -> x mod 2 = 1) lst\nin\nodd_numbers [1; 2; 3; 4]"
      },
      "answer": "(1 3)"
    },
    "ejercicio-4": {
      "description": "Invertir listas. Un sistema prioriza tareas recientes invirtiendo (1 2 3). Define una función recursiva para invertir. Evalúa con (1 2 3). Esto muestra cómo manipulamos el orden de listas.",
      "racket": {
        "code": "(define (reverse-list lst)\n  (if (empty? lst)\n      null\n      (append (reverse-list (rest lst))\n              (list (first lst)))\n  )\n)\n(reverse-list '(1 2 3))"
      },
      "ocaml": {
        "code": "let rec reverse_list lst =\n  if lst = [] then\n    []\n  else\n    reverse_list (List.tl lst) @ [List.hd lst]\nin\nreverse_list [1; 2; 3]"
      },
      "answer": "(3 2 1)"
    },
    "ejercicio-5": {
      "description": "Acumulación con fold. Una tienda suma ventas (10 20 30). Define una función con foldl para sumar. Evalúa con (10 20 30). Esto introduce fold para acumulaciones en listas.",
      "racket": {
        "code": "(define (sum-fold lst)\n  (foldl + 0 lst)\n)\n(sum-fold '(10 20 30))"
      },
      "ocaml": {
        "code": "let sum_fold lst =\n  List.fold_left (+) 0 lst\nin\nsum_fold [10; 20; 30]"
      },
      "answer": "60"
    },
    "ejercicio-6": {
      "description": "Filtrar booleanos. Un organizador selecciona tareas completadas (true false true). Define una función con filter para valores true. Evalúa con (true false true). Esto muestra filtrado de booleanos.",
      "racket": {
        "code": "(define (true-values lst)\n  (filter (lambda (x) x) lst)\n)\n(true-values '(#t #f #t))"
      },
      "ocaml": {
        "code": "let true_values lst =\n  List.filter (fun x -> x) lst\nin\ntrue_values [true; false; true]"
      },
      "answer": "(true true)"
    },
    "ejercicio-7": {
      "description": "Transformaciones masivas. Un analista multiplica precios (2 3 4) por 10. Define una función con map para multiplicar por 10. Evalúa con (2 3 4). Esto refuerza map para ajustes en listas.",
      "racket": {
        "code": "(define (times-ten lst)\n  (map (lambda (x) (* x 10))\n       lst\n  )\n)\n(times-ten '(2 3 4))"
      },
      "ocaml": {
        "code": "let times_ten lst =\n  List.map (fun x -> x * 10) lst\nin\ntimes_ten [2; 3; 4]"
      },
      "answer": "(20 30 40)"
    }
  }
}
