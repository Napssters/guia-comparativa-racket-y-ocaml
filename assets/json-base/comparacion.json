{
  "paradigma-funcional": {
    "ejercicio-1": {
      "title": "Sumar distancias de un viaje",
      "racket": {
        "lines": ["(+ 5 3)", "(+ 2 7)", "(+ 10 4)", "(+ 1 6)", "(+ 8 2)"]
      },
      "ocaml": {
        "lines": ["5 + 3", "2 + 7", "10 + 4", "1 + 6", "8 + 2"]
      },
      "explanations_racket": [
        "Calcula la distancia sumando 5 km y 3 km con '+', resultando en 8. La notación prefija (+ 5 3) en Racket enfatiza la suma como función pura, ideal para modelar tramos de un viaje, como ir a la escuela y volver, con resultados predecibles y sin estado.",
        "Suma 2 km y 7 km con '+', dando 9. La notación (+ 2 7) muestra cómo Racket trata la suma como función, útil para caminatas cortas, como de casa al parque, manteniendo inmutabilidad.",
        "Suma 10 km y 4 km, resultando en 14. La expresión (+ 10 4) refuerza la pureza funcional, modelando viajes largos con determinismo para principiantes.",
        "Suma 1 km y 6 km, dando 7. La notación (+ 1 6) es clara para tramos pequeños, como ir a una tienda, sin alterar estado.",
        "Suma 8 km y 2 km, resultando en 10. (+ 8 2) enseña cómo sumar distancias, como paseos matutinos y vespertinos, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula la distancia sumando 5 km y 3 km con '+', dando 8. La notación infija 5 + 3 en OCaml es intuitiva, como matemáticas escolares, ideal para modelar tramos de un viaje con pureza y sin efectos secundarios.",
        "Suma 2 km y 7 km, resultando en 9. La expresión 2 + 7 es simple, como sumar distancias de caminatas diarias, con tipado estático asegurando enteros.",
        "Suma 10 km y 4 km, dando 14. La expresión 10 + 4 modela viajes largos, manteniendo determinismo y facilidad para principiantes.",
        "Suma 1 km y 6 km, resultando en 7. La notación 1 + 6 es clara para tramos cortos, como ir al mercado, con pureza funcional.",
        "Suma 8 km y 2 km, dando 10. La expresión 8 + 2 representa caminatas combinadas, con OCaml asegurando resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan 5 + 3 = 8, con pureza funcional, usando suma para modelar distancias de un viaje. Diferencias: Racket usa notación prefija (+ 5 3) con paréntesis, explícita como función, mientras que OCaml usa infija 5 + 3, más concisa y matemática. Racket tiene tipado dinámico, OCaml infiere enteros.",
        "Similitudes: Ambas calculan 2 + 7 = 9, con pureza funcional, para caminatas cortas. Diferencias: Racket usa prefija (+ 2 7), destacando la función, mientras que OCaml usa infija 2 + 7, más natural. Racket dinámico, OCaml estático, pero resultado idéntico.",
        "Similitudes: Ambas calculan 10 + 4 = 14, con pureza funcional, modelando viajes largos. Diferencias: Racket usa prefija (+ 10 4), explícita, mientras que OCaml usa infija 10 + 4, concisa. Tipado dinámico en Racket, estático en OCaml.",
        "Similitudes: Ambas calculan 1 + 6 = 7, con pureza funcional, para tramos pequeños. Diferencias: Racket usa prefija (+ 1 6), mientras que OCaml usa infija 1 + 6, más intuitiva. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 8 + 2 = 10, con pureza funcional, para paseos combinados. Diferencias: Racket usa prefija (+ 8 2), explícita, mientras que OCaml usa infija 8 + 2, concisa. Tipado dinámico vs. estático, pero idéntico."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar paridad con resto",
      "racket": {
        "lines": [
          "(remainder 7 2)",
          "(remainder 4 2)",
          "(remainder 9 2)",
          "(remainder 6 2)",
          "(remainder 3 2)"
        ]
      },
      "ocaml": {
        "lines": ["7 mod 2", "4 mod 2", "9 mod 2", "6 mod 2", "3 mod 2"]
      },
      "explanations_racket": [
        "Calcula el resto de 7 ÷ 2 con 'remainder', dando 1 (impar). La notación prefija (remainder 7 2) muestra la operación como función pura, ideal para verificar si un número de sillas deja sobrantes en pares, manteniendo inmutabilidad.",
        "Calcula 4 ÷ 2, dando 0 (par). (remainder 4 2) enseña paridad, como dividir dulces equitativamente, con pureza funcional y sin efectos secundarios.",
        "Calcula 9 ÷ 2, resultando en 1 (impar). (remainder 9 2) modela casos como organizar invitados, asegurando determinismo para principiantes.",
        "Calcula 6 ÷ 2, dando 0 (par). (remainder 6 2) es útil para dividir objetos en grupos, manteniendo la inmutabilidad del estado.",
        "Calcula 3 ÷ 2, dando 1 (impar). (remainder 3 2) refuerza paridad, como clasificar frutas, con pureza funcional y resultados predecibles."
      ],
      "explanations_ocaml": [
        "Calcula el resto de 7 ÷ 2 con 'mod', dando 1 (impar). La notación infija 7 mod 2 es intuitiva, como verificar sillas sobrantes, con pureza funcional y sin efectos secundarios.",
        "Calcula 4 ÷ 2, dando 0 (par). 4 mod 2 modela división equitativa, como repartir dulces, con tipado estático asegurando enteros.",
        "Calcula 9 ÷ 2, resultando en 1 (impar). 9 mod 2 es útil para organizar grupos, manteniendo determinismo y facilidad para principiantes.",
        "Calcula 6 ÷ 2, dando 0 (par). 6 mod 2 enseña división en pares, como clasificar objetos, con pureza funcional.",
        "Calcula 3 ÷ 2, dando 1 (impar). 3 mod 2 modela paridad, como contar frutas sobrantes, con resultados predecibles y sin estado."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan resto de 7 ÷ 2 = 1, con pureza funcional, verificando imparidad. Diferencias: Racket usa 'remainder' prefija, explícita, mientras que OCaml usa 'mod' infija, concisa. Racket dinámico, OCaml estático, pero resultado idéntico.",
        "Similitudes: Ambas calculan 4 ÷ 2 = 0, con pureza funcional, verificando paridad. Diferencias: Racket usa 'remainder' prefija, mientras que OCaml usa 'mod' infija. Tipado dinámico vs. estático, pero idéntico.",
        "Similitudes: Ambas calculan 9 ÷ 2 = 1, con pureza funcional, para imparidad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 6 ÷ 2 = 0, con pureza funcional, para paridad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 3 ÷ 2 = 1, con pureza funcional, verificando imparidad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-3": {
      "title": "Comparar inventarios con sumas",
      "racket": {
        "lines": [
          "(> (+ 12 4) 15)",
          "(> (+ 5 5) 12)",
          "(> (+ 15 3) 10)",
          "(> (+ 3 3) 6)",
          "(> (+ 9 6) 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "12 + 4 > 15",
          "5 + 5 > 12",
          "15 + 3 > 10",
          "3 + 3 > 6",
          "9 + 6 > 8"
        ]
      },
      "explanations_racket": [
        "Compara el resultado de 12 + 4 = 16 con 15 usando '>', dando #t. La notación prefija (> (+ 12 4) 15) en Racket muestra la comparación como función pura, ideal para evaluar inventarios con nuevas unidades frente a la competencia, manteniendo inmutabilidad.",
        "Compara 5 + 5 = 10 con 12, dando #f. (> (+ 5 5) 12) enseña decisiones funcionales, como verificar existencias, con determinismo y sin efectos secundarios.",
        "Compara 15 + 3 = 18 con 10, resultando en #t. (> (+ 15 3) 10) modela comparar cantidades de productos, asegurando pureza funcional.",
        "Compara 3 + 3 = 6 con 6, dando #f. (> (+ 3 3) 6) enseña que igual no es mayor, útil para inventarios equilibrados, con resultados predecibles.",
        "Compara 9 + 6 = 15 con 8, dando #t. (> (+ 9 6) 8) modela comparar ventas con adiciones, manteniendo la inmutabilidad del estado."
      ],
      "explanations_ocaml": [
        "Compara 12 + 4 = 16 con 15 usando '>', dando true. La notación infija 12 + 4 > 15 es intuitiva, como comparar inventarios con nuevas unidades, con pureza funcional y sin efectos secundarios.",
        "Compara 5 + 5 = 10 con 12, dando false. 5 + 5 > 12 modela decisiones de stock, con tipado estático asegurando enteros y determinismo.",
        "Compara 15 + 3 = 18 con 10, dando true. 15 + 3 > 10 es útil para comparar cantidades, manteniendo pureza funcional para principiantes.",
        "Compara 3 + 3 = 6 con 6, dando false. 3 + 3 > 6 enseña que igual no es mayor, con pureza y sin estado.",
        "Compara 9 + 6 = 15 con 8, dando true. 9 + 6 > 8 modela comparar ventas con adiciones, asegurando resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan 12 + 4 = 16 > 15, dando #t/true, con pureza funcional, para inventarios con sumas. Diferencias: Racket usa '>' prefija con paréntesis anidados (> (+ 12 4) 15), explícita, mientras que OCaml usa infija 12 + 4 > 15, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 5 + 5 = 10 > 12, dando #f/false, con pureza funcional, para existencias. Diferencias: Racket usa '>' prefija (> (+ 5 5) 12), OCaml infija 5 + 5 > 12. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 15 + 3 = 18 > 10, dando #t/true, con pureza funcional, para cantidades. Diferencias: Racket usa '>' prefija (> (+ 15 3) 10), OCaml infija 15 + 3 > 10. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 3 + 3 = 6 > 6, dando #f/false, con pureza funcional, para inventarios equilibrados. Diferencias: Racket usa '>' prefija (> (+ 3 3) 6), OCaml infija 3 + 3 > 6. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 9 + 6 = 15 > 8, dando #t/true, con pureza funcional, para ventas. Diferencias: Racket usa '>' prefija (> (+ 9 6) 8), OCaml infija 9 + 6 > 8. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-4": {
      "title": "Dividir ganancias netas",
      "racket": {
        "lines": [
          "(/ (- 20 10) 2)",
          "(/ (- 15 3) 4)",
          "(/ (- 18 10) 2)",
          "(/ (- 12 3) 3)",
          "(/ (- 24 4) 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "(20 - 10) / 2",
          "(15 - 3) / 4",
          "(18 - 10) / 2",
          "(12 - 3) / 3",
          "(24 - 4) / 5"
        ]
      },
      "explanations_racket": [
        "Calcula (20 - 10) / 2 con '/', dando 5. La notación prefija (/ (- 20 10) 2) en Racket muestra la división como función pura, ideal para repartir ganancias netas entre 2 personas, con inmutabilidad y determinismo.",
        "Calcula (15 - 3) / 4, dando 3. (/ (- 15 3) 4) modela dividir ganancias entre 4 personas, con pureza funcional y sin efectos secundarios.",
        "Calcula (18 - 10) / 2, resultando en 4. (/ (- 18 10) 2) enseña cómo dividir ingresos netos, como en proyectos, manteniendo inmutabilidad.",
        "Calcula (12 - 3) / 3, dando 3. (/ (- 12 3) 3) modela repartir beneficios entre 3, con resultados predecibles y sin estado.",
        "Calcula (24 - 4) / 5, dando 4. (/ (- 24 4) 5) representa dividir ganancias entre 5, con pureza funcional para escenarios más complejos."
      ],
      "explanations_ocaml": [
        "Calcula (20 - 10) / 2 con '/', dando 5. La notación infija (20 - 10) / 2 es intuitiva, como repartir ganancias netas entre 2, con pureza funcional y sin efectos secundarios.",
        "Calcula (15 - 3) / 4, dando 3. (15 - 3) / 4 modela dividir beneficios entre 4, con tipado estático asegurando enteros y determinismo.",
        "Calcula (18 - 10) / 2, resultando en 4. (18 - 10) / 2 enseña repartir ingresos netos, manteniendo pureza funcional.",
        "Calcula (12 - 3) / 3, dando 3. (12 - 3) / 3 modela dividir entre 3, con resultados predecibles y sin estado.",
        "Calcula (24 - 4) / 5, dando 4. (24 - 4) / 5 representa repartir entre 5, con OCaml asegurando cálculos predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan (20 - 10) / 2 = 5, con pureza funcional, para repartir ganancias. Diferencias: Racket usa '/' prefija (/ (- 20 10) 2), explícita, mientras que OCaml usa infija (20 - 10) / 2, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan (15 - 3) / 4 = 3, con pureza funcional, para beneficios. Diferencias: Racket usa '/' prefija (/ (- 15 3) 4), OCaml infija (15 - 3) / 4. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan (18 - 10) / 2 = 4, con pureza funcional, para ingresos netos. Diferencias: Racket usa '/' prefija (/ (- 18 10) 2), OCaml infija (18 - 10) / 2. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan (12 - 3) / 3 = 3, con pureza funcional, para dividir beneficios. Diferencias: Racket usa '/' prefija (/ (- 12 3) 3), OCaml infija (12 - 3) / 3. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan (24 - 4) / 5 = 4, con pureza funcional, para repartir entre 5. Diferencias: Racket usa '/' prefija (/ (- 24 4) 5), OCaml infija (24 - 4) / 5. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-5": {
      "title": "Comparar cálculos con igualdad",
      "racket": {
        "lines": [
          "(= (- (+ 5 3) 1) 7)",
          "(= (* 2 3) 7)",
          "(= (+ (* 4 2) 1) 9)",
          "(= (- 10 3) 6)",
          "(= (* 5 1) 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "(5 + 3 - 1) = 7",
          "(2 * 3) = 7",
          "((4 * 2) + 1) = 9",
          "(10 - 3) = 6",
          "(5 * 1) = 5"
        ]
      },
      "explanations_racket": [
        "Compara (5 + 3 - 1) = 7 con '=', dando #t (7 = 7). La notación prefija (= (- (+ 5 3) 1) 7) muestra igualdad como función pura, ideal para validar inventarios con operaciones compuestas, con inmutabilidad.",
        "Compara (2 * 3) = 7, dando #f (6 ≠ 7). (= (* 2 3) 7) enseña verificar resultados, como en cálculos de stock, con pureza funcional.",
        "Compara (4 * 2 + 1) = 9, dando #t (9 = 9). (= (+ (* 4 2) 1) 9) modela validar operaciones complejas, como en inventarios, sin efectos secundarios.",
        "Compara (10 - 3) = 6, dando #f (7 ≠ 6). (= (- 10 3) 6) enseña verificar diferencias, con resultados predecibles.",
        "Compara (5 * 1) = 5, dando #t (5 = 5). (= (* 5 1) 5) modela validar cálculos simples, manteniendo inmutabilidad."
      ],
      "explanations_ocaml": [
        "Compara (5 + 3 - 1) = 7 con '=', dando true (7 = 7). La notación infija (5 + 3 - 1) = 7 es intuitiva, como validar inventarios con operaciones, con pureza funcional.",
        "Compara (2 * 3) = 7, dando false (6 ≠ 7). (2 * 3) = 7 modela verificar cálculos, con tipado estático asegurando enteros.",
        "Compara ((4 * 2) + 1) = 9, dando true (9 = 9). ((4 * 2) + 1) = 9 valida operaciones complejas, manteniendo determinismo.",
        "Compara (10 - 3) = 6, dando false (7 ≠ 6). (10 - 3) = 6 enseña verificar diferencias, con pureza funcional.",
        "Compara (5 * 1) = 5, dando true (5 = 5). (5 * 1) = 5 modela validar cálculos simples, con resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan (5 + 3 - 1) = 7, dando #t/true, con pureza funcional, para validar inventarios. Diferencias: Racket usa '=' prefija (= (- (+ 5 3) 1) 7), explícita, mientras que OCaml usa infija (5 + 3 - 1) = 7, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan (2 * 3) = 7, dando #f/false, con pureza funcional, para cálculos. Diferencias: Racket usa '=' prefija (= (* 2 3) 7), OCaml infija (2 * 3) = 7. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan (4 * 2 + 1) = 9, dando #t/true, con pureza funcional, para operaciones complejas. Diferencias: Racket usa '=' prefija (= (+ (* 4 2) 1) 9), OCaml infija ((4 * 2) + 1) = 9. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan (10 - 3) = 6, dando #f/false, con pureza funcional, para diferencias. Diferencias: Racket usa '=' prefija (= (- 10 3) 6), OCaml infija (10 - 3) = 6. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan (5 * 1) = 5, dando #t/true, con pureza funcional, para cálculos simples. Diferencias: Racket usa '=' prefija (= (* 5 1) 5), OCaml infija (5 * 1) = 5. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-6": {
      "title": "Calcular distancias absolutas con anidaciones",
      "racket": {
        "lines": [
          "(abs (- (+ 5 3) 10))",
          "(abs (* -2 3))",
          "(abs (- 4 (+ 1 6)))",
          "(abs (abs (- (* 3 4) 15)))",
          "(abs (- (abs (- 12 18)) 2))"
        ]
      },
      "ocaml": {
        "lines": [
          "abs (5 + 3 - 10)",
          "abs (-2 * 3)",
          "abs (4 - (1 + 6))",
          "abs (abs ((3 * 4) - 15))",
          "abs ((abs (12 - 18)) - 2)"
        ]
      },
      "explanations_racket": [
        "Calcula |5 + 3 - 10| con 'abs', dando 2 (|8 - 10| = |-2|). (abs (- (+ 5 3) 10)) representa una desviación base entre mediciones positivas y negativas, garantizando pureza funcional.",
        "Calcula |-2 * 3| con 'abs', dando 6 (|-6|). (abs (* -2 3)) muestra cómo convertir productos negativos en distancias positivas, útil en cálculos direccionales.",
        "Calcula |4 - (1 + 6)|, dando 3 (|4 - 7| = |-3|). (abs (- 4 (+ 1 6))) enseña composición funcional simple con suma anidada, manteniendo determinismo.",
        "Calcula ||(3 * 4) - 15|| con 'abs' anidado, dando 3. (abs (abs (- (* 3 4) 15))) ilustra valor absoluto doble, demostrando idempotencia de 'abs' sobre resultados positivos.",
        "Calcula |(|12 - 18| - 2)| con 'abs' anidado, dando 4 (|6 - 2| = 4). (abs (- (abs (- 12 18)) 2)) combina restas y valores absolutos internos, ejemplo de anidación coherente."
      ],
      "explanations_ocaml": [
        "Calcula |5 + 3 - 10| con 'abs', dando 2 (|8 - 10| = |-2|). abs (5 + 3 - 10) mantiene claridad infija y pureza funcional para desviaciones aritméticas.",
        "Calcula |-2 * 3| con 'abs', dando 6 (|-6|). abs (-2 * 3) muestra corrección de signos en multiplicaciones negativas, asegurando determinismo.",
        "Calcula |4 - (1 + 6)| con 'abs', dando 3. abs (4 - (1 + 6)) usa estructura infija clara, con resultados predecibles.",
        "Calcula ||(3 * 4) - 15||, dando 3. abs (abs ((3 * 4) - 15)) demuestra composición funcional pura, ya que 'abs' aplicado dos veces produce el mismo valor.",
        "Calcula |(|12 - 18| - 2)|, dando 4. abs ((abs (12 - 18)) - 2) muestra cómo las anidaciones producen resultados correctos incluso con negativos internos."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan |5 + 3 - 10| = 2 con pureza funcional. Diferencias: Racket usa notación prefija (abs (- (+ 5 3) 10)), OCaml usa infija abs (5 + 3 - 10). Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan |-2 * 3| = 6, preservando pureza. Diferencias: Racket usa 'abs' prefija (abs (* -2 3)), OCaml usa abs (-2 * 3) infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan |4 - (1 + 6)| = 3. Diferencias: Notación prefija vs. infija; Racket más explícito, OCaml más conciso. Ambos son deterministas.",
        "Similitudes: Ambas aplican 'abs' doblemente para obtener 3, ilustrando idempotencia. Diferencias: Racket (abs (abs (- (* 3 4) 15))) vs. OCaml abs (abs ((3 * 4) - 15)), expresividad vs. concisión.",
        "Similitudes: Ambas calculan |(|12 - 18| - 2)| = 4, demostrando anidación funcional. Diferencias: Prefija en Racket, infija en OCaml; ambos mantienen pureza funcional."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular hipotenusas con raíces cuadradas anidadas",
      "racket": {
        "lines": [
          "(sqrt (+ (* 3 3) (* 4 4)))",
          "(sqrt (+ (sqrt (+ (* 5 5) (* 12 12))) 1))",
          "(sqrt (+ (* (sqrt 8) (sqrt 8)) (* 6 6)))",
          "(sqrt (+ (* 7 7) (sqrt (+ (* 24 24) 1))))",
          "(sqrt (sqrt (+ (* 20 20) (* 21 21))))"
        ]
      },
      "ocaml": {
        "lines": [
          "sqrt (3.0 *. 3.0 +. 4.0 *. 4.0)",
          "sqrt (sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) +. 1.0)",
          "sqrt ((sqrt 8.0) *. (sqrt 8.0) +. 6.0 *. 6.0)",
          "sqrt (7.0 *. 7.0 +. sqrt (24.0 *. 24.0 +. 1.0))",
          "sqrt (sqrt (20.0 *. 20.0 +. 21.0 *. 21.0)))"
        ]
      },
      "explanations_racket": [
        "Calcula √(3² + 4²) = √(9 + 16) = 5. (sqrt (+ (* 3 3) (* 4 4))) representa la hipotenusa clásica, ideal para estructuras simples.",
        "Calcula √(√(5² + 12²) + 1) ≈ √(√169 + 1) ≈ √(13 + 1) ≈ 3.74. (sqrt (+ (sqrt (+ (* 5 5) (* 12 12))) 1)) demuestra uso de raíz doble para obtener resultados compuestos.",
        "Calcula √((√8 * √8) + 6²) = √(8 + 36) = √44 ≈ 6.63. (sqrt (+ (* (sqrt 8) (sqrt 8)) (* 6 6))) aplica raíz dentro de multiplicación para mantener coherencia matemática.",
        "Calcula √(7² + √(24² + 1)) = √(49 + √577) ≈ √(49 + 24.02) = √73.02 ≈ 8.54. (sqrt (+ (* 7 7) (sqrt (+ (* 24 24) 1)))) ejemplifica mezcla de niveles de raíces.",
        "Calcula √(√(20² + 21²)) = √(√(400 + 441)) = √(√841) = √29 ≈ 5.38. (sqrt (sqrt (+ (* 20 20) (* 21 21)))) muestra composición extrema de raíces anidadas."
      ],
      "explanations_ocaml": [
        "Calcula √(3.0² + 4.0²) = √(9 + 16) = 5. sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) representa la hipotenusa clásica, usando operadores flotantes.",
        "Calcula √(√(5.0² + 12.0²) + 1.0) ≈ 3.74. sqrt (sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) +. 1.0) aplica raíz doble, mostrando expresividad funcional.",
        "Calcula √((√8.0 *. √8.0) + 6.0²) ≈ 6.63. sqrt ((sqrt 8.0) *. (sqrt 8.0) +. 6.0 *. 6.0) mantiene exactitud en flotantes.",
        "Calcula √(7.0² + √(24.0² + 1.0)) ≈ 8.54. sqrt (7.0 *. 7.0 +. sqrt (24.0 *. 24.0 +. 1.0)) muestra composición jerárquica con precisión decimal.",
        "Calcula √(√(20.0² + 21.0²)) ≈ 5.38. sqrt (sqrt (20.0 *. 20.0 +. 21.0 *. 21.0))) ejemplifica raíces dobles en OCaml con flotantes precisos."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan √(3² + 4²) = 5. Diferencias: Racket usa notación prefija explícita, OCaml infija con operadores flotantes (*. +.).",
        "Similitudes: Ambas aplican doble raíz √(√(5² + 12²) + 1) ≈ 3.74. Diferencias: Prefija en Racket, infija en OCaml, ambas puras y deterministas.",
        "Similitudes: Ambas calculan √((√8 * √8) + 6²) ≈ 6.63, con pureza funcional. Diferencias: Prefija Racket vs. infija OCaml, ambas con precisión matemática.",
        "Similitudes: Ambas resuelven √(7² + √(24² + 1)) ≈ 8.54, representando composición jerárquica. Diferencias: OCaml declara flotantes explícitamente.",
        "Similitudes: Ambas calculan √(√(20² + 21²)) ≈ 5.38, demostrando raíces anidadas. Diferencias: Prefija Racket (sqrt (sqrt ...)), infija OCaml (sqrt (sqrt ...)), con precisión numérica distinta."
      ]
    }
  },
  "expresiones": {
    "ejercicio-1": {
      "title": "Verificar igualdad de paquetes",
      "racket": {
        "lines": ["(= 8 8)", "(= 5 6)", "(= 7 7)", "(= 3 3)", "(= 9 10)"]
      },
      "ocaml": {
        "lines": ["8 = 8", "5 = 6", "7 = 7", "3 = 3", "9 = 10"]
      },
      "explanations_racket": [
        "Verifica si 8 = 8 con '=', dando #t. La notación prefija (= 8 8) en Racket muestra igualdad como función pura, ideal para comparar paquetes de galletas en inventarios.",
        "Verifica 5 = 6, dando #f. (= 5 6) enseña comparar cantidades distintas, como cajas de productos, con determinismo.",
        "Verifica 7 = 7, dando #t. (= 7 7) modela validar medidas iguales, como en control de calidad, con inmutabilidad.",
        "Verifica 3 = 3, dando #t. (= 3 3) es útil para confirmar inventarios, sin efectos secundarios.",
        "Verifica 9 = 10, dando #f. (= 9 10) enseña comparar cantidades distintas, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Verifica 8 = 8 con '=', dando true. La notación infija 8 = 8 es intuitiva, como comparar galletas, con pureza funcional.",
        "Verifica 5 = 6, dando false. 5 = 6 modela comparar cantidades, con tipado estático asegurando enteros.",
        "Verifica 7 = 7, dando true. 7 = 7 enseña validar medidas, con determinismo.",
        "Verifica 3 = 3, dando true. 3 = 3 es útil para inventarios, sin efectos secundarios.",
        "Verifica 9 = 10, dando false. 9 = 10 modela comparar cantidades distintas, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican 8 = 8, dando #t/true, con pureza funcional, para comparar galletas. Diferencias: Racket usa '=' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas verifican 5 = 6, dando #f/false, con pureza funcional, para cantidades distintas. Diferencias: Racket usa '=' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas verifican 7 = 7, dando #t/true, con pureza funcional, para medidas. Diferencias: Racket usa '=' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas verifican 3 = 3, dando #t/true, con pureza funcional, para inventarios. Diferencias: Racket usa '=' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas verifican 9 = 10, dando #f/false, con pureza funcional, para cantidades distintas. Diferencias: Racket usa '=' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-2": {
      "title": "Comparar presupuesto con límite",
      "racket": {
        "lines": ["(> 15 10)", "(> 8 9)", "(> 12 5)", "(> 10 10)", "(> 20 15)"]
      },
      "ocaml": {
        "lines": ["15 > 10", "8 > 9", "12 > 5", "10 > 10", "20 > 15"]
      },
      "explanations_racket": [
        "Compara 15 > 10 con '>', dando #t. La notación prefija (> 15 10) en Racket muestra comparación como función pura, ideal para verificar presupuestos en planificación financiera.",
        "Compara 8 > 9, dando #f. (> 8 9) enseña decisiones de límites, con determinismo.",
        "Compara 12 > 5, dando #t. (> 12 5) modela comparar gastos, sin efectos secundarios.",
        "Compara 10 > 10, dando #f. (> 10 10) enseña que igual no es mayor, útil para presupuestos equilibrados.",
        "Compara 20 > 15, dando #t. (> 20 15) modela verificar excedentes, con inmutabilidad."
      ],
      "explanations_ocaml": [
        "Compara 15 > 10 con '>', dando true. La notación infija 15 > 10 es intuitiva, como verificar presupuestos, con pureza funcional.",
        "Compara 8 > 9, dando false. 8 > 9 modela decisiones de límites, con tipado estático.",
        "Compara 12 > 5, dando true. 12 > 5 es útil para comparar gastos, con determinismo.",
        "Compara 10 > 10, dando false. 10 > 10 enseña que igual no es mayor, con pureza.",
        "Compara 20 > 15, dando true. 20 > 15 modela verificar excedentes, sin efectos secundarios."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan 15 > 10, dando #t/true, con pureza funcional, para presupuestos. Diferencias: Racket usa '>' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 8 > 9, dando #f/false, con pureza funcional, para límites. Diferencias: Racket usa '>' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 12 > 5, dando #t/true, con pureza funcional, para gastos. Diferencias: Racket usa '>' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 10 > 10, dando #f/false, con pureza funcional, para presupuestos equilibrados. Diferencias: Racket usa '>' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 20 > 15, dando #t/true, con pureza funcional, para excedentes. Diferencias: Racket usa '>' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-3": {
      "title": "Sumar distancias caminadas",
      "racket": {
        "lines": ["(+ 7 5)", "(+ 3 4)", "(+ 6 8)", "(+ 2 9)", "(+ 10 3)"]
      },
      "ocaml": {
        "lines": ["7 + 5", "3 + 4", "6 + 8", "2 + 9", "10 + 3"]
      },
      "explanations_racket": [
        "Calcula 7 + 5 con '+', dando 12. La notación prefija (+ 7 5) en Racket muestra suma como función pura, ideal para combinar distancias de caminatas.",
        "Suma 3 + 4, dando 7. (+ 3 4) modela tramos cortos, como ir al parque, con determinismo.",
        "Suma 6 + 8, dando 14. (+ 6 8) es útil para recorridos largos, sin efectos secundarios.",
        "Suma 2 + 9, dando 11. (+ 2 9) enseña sumar distancias variadas, con inmutabilidad.",
        "Suma 10 + 3, dando 13. (+ 10 3) modela combinar tramos, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 7 + 5 con '+', dando 12. La notación infija 7 + 5 es intuitiva, como sumar tramos de caminatas, con pureza funcional.",
        "Suma 3 + 4, dando 7. 3 + 4 modela tramos cortos, con tipado estático asegurando enteros.",
        "Suma 6 + 8, dando 14. 6 + 8 es útil para recorridos largos, con determinismo.",
        "Suma 2 + 9, dando 11. 2 + 9 enseña sumar distancias, sin efectos secundarios.",
        "Suma 10 + 3, dando 13. 10 + 3 modela combinar tramos, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan 7 + 5 = 12, con pureza funcional, para distancias de caminatas. Diferencias: Racket usa '+' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 3 + 4 = 7, con pureza funcional, para tramos cortos. Diferencias: Racket usa '+' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 6 + 8 = 14, con pureza funcional, para recorridos largos. Diferencias: Racket usa '+' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 2 + 9 = 11, con pureza funcional, para distancias variadas. Diferencias: Racket usa '+' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 10 + 3 = 13, con pureza funcional, para combinar tramos. Diferencias: Racket usa '+' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-4": {
      "title": "Calcular caramelos sobrantes",
      "racket": {
        "lines": ["(- 20 6)", "(- 15 4)", "(- 12 3)", "(- 8 2)", "(- 10 5)"]
      },
      "ocaml": {
        "lines": ["20 - 6", "15 - 4", "12 - 3", "8 - 2", "10 - 5"]
      },
      "explanations_racket": [
        "Calcula 20 - 6 con '-', dando 14. La notación prefija (- 20 6) en Racket muestra resta como función pura, ideal para calcular caramelos sobrantes.",
        "Resta 15 - 4, dando 11. (- 15 4) modela distribución de recursos, con determinismo.",
        "Resta 12 - 3, dando 9. (- 12 3) enseña calcular sobrantes, sin efectos secundarios.",
        "Resta 8 - 2, dando 6. (- 8 2) es útil para repartir objetos, con inmutabilidad.",
        "Resta 10 - 5, dando 5. (- 10 5) modela calcular sobrantes, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 20 - 6 con '-', dando 14. La notación infija 20 - 6 es intuitiva, como calcular caramelos sobrantes, con pureza funcional.",
        "Resta 15 - 4, dando 11. 15 - 4 modela distribución, con tipado estático.",
        "Resta 12 - 3, dando 9. 12 - 3 enseña calcular sobrantes, con determinismo.",
        "Resta 8 - 2, dando 6. 8 - 2 es útil para repartir objetos, sin efectos secundarios.",
        "Resta 10 - 5, dando 5. 10 - 5 modela sobrantes, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas restan 20 - 6 = 14, con pureza funcional, para caramelos sobrantes. Diferencias: Racket usa '-' prefija, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas restan 15 - 4 = 11, con pureza funcional, para distribución. Diferencias: Racket usa '-' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas restan 12 - 3 = 9, con pureza funcional, para sobrantes. Diferencias: Racket usa '-' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas restan 8 - 2 = 6, con pureza funcional, para repartir objetos. Diferencias: Racket usa '-' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas restan 10 - 5 = 5, con pureza funcional, para sobrantes. Diferencias: Racket usa '-' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-5": {
      "title": "Verificar divisibilidad de libros",
      "racket": {
        "lines": [
          "(remainder 10 3)",
          "(remainder 8 2)",
          "(remainder 7 4)",
          "(remainder 12 5)",
          "(remainder 9 3)"
        ]
      },
      "ocaml": {
        "lines": ["10 mod 3", "8 mod 2", "7 mod 4", "12 mod 5", "9 mod 3"]
      },
      "explanations_racket": [
        "Calcula resto de 10 ÷ 3 con 'remainder', dando 1. La notación prefija (remainder 10 3) en Racket muestra módulo como función pura, ideal para verificar sobrantes de libros.",
        "Calcula 8 ÷ 2, dando 0. (remainder 8 2) enseña divisibilidad exacta, con determinismo.",
        "Calcula 7 ÷ 4, dando 3. (remainder 7 4) modela sobrantes en grupos, sin efectos secundarios.",
        "Calcula 12 ÷ 5, dando 2. (remainder 12 5) es útil para organización, con inmutabilidad.",
        "Calcula 9 ÷ 3, dando 0. (remainder 9 3) modela división exacta, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula resto de 10 ÷ 3 con 'mod', dando 1. La notación infija 10 mod 3 es intuitiva, como verificar sobrantes de libros, con pureza funcional.",
        "Calcula 8 ÷ 2, dando 0. 8 mod 2 modela divisibilidad exacta, con tipado estático.",
        "Calcula 7 ÷ 4, dando 3. 7 mod 4 enseña sobrantes, con determinismo.",
        "Calcula 12 ÷ 5, dando 2. 12 mod 5 es útil para organización, sin efectos secundarios.",
        "Calcula 9 ÷ 3, dando 0. 9 mod 3 modela división exacta, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan resto de 10 ÷ 3 = 1, con pureza funcional, para sobrantes de libros. Diferencias: Racket usa 'remainder' prefija, explícita, mientras que OCaml usa 'mod' infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 8 ÷ 2 = 0, con pureza funcional, para divisibilidad exacta. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 7 ÷ 4 = 3, con pureza funcional, para sobrantes en grupos. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 12 ÷ 5 = 2, con pureza funcional, para organización. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 9 ÷ 3 = 0, con pureza funcional, para división exacta. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-6": {
      "title": "Repartir huevos entre personas",
      "racket": {
        "lines": ["(/ 12 3)", "(/ 8 2)", "(/ 15 5)", "(/ 6 2)", "(/ 9 3)"]
      },
      "ocaml": {
        "lines": ["12 / 3", "8 / 2", "15 / 5", "6 / 2", "9 / 3"]
      },
      "explanations_racket": [
        "Calcula 12 ÷ 3 con '/', dando 4. La notación prefija (/ 12 3) en Racket muestra división como función pura, ideal para repartir huevos entre personas.",
        "Divide 8 ÷ 2, dando 4. (/ 8 2) modela reparto equitativo, con determinismo.",
        "Divide 15 ÷ 5, dando 3. (/ 15 5) enseña distribución, sin efectos secundarios.",
        "Divide 6 ÷ 2, dando 3. (/ 6 2) es útil para repartir recursos, con inmutabilidad.",
        "Divide 9 ÷ 3, dando 3. (/ 9 3) modela reparto en recetas, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 12 ÷ 3 con '/', dando 4. La notación infija 12 / 3 es intuitiva, como repartir huevos, con pureza funcional.",
        "Divide 8 ÷ 2, dando 4. 8 / 2 modela reparto equitativo, con tipado estático.",
        "Divide 15 ÷ 5, dando 3. 15 / 5 enseña distribución, con determinismo.",
        "Divide 6 ÷ 2, dando 3. 6 / 2 es útil para repartir recursos, sin efectos secundarios.",
        "Divide 9 ÷ 3, dando 3. 9 / 3 modela reparto en recetas, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas dividen 12 ÷ 3 = 4, con pureza funcional, para repartir huevos. Diferencias: Racket usa '/' prefija, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas dividen 8 ÷ 2 = 4, con pureza funcional, para reparto equitativo. Diferencias: Racket usa '/' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas dividen 15 ÷ 5 = 3, con pureza funcional, para distribución. Diferencias: Racket usa '/' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas dividen 6 ÷ 2 = 3, con pureza funcional, para repartir recursos. Diferencias: Racket usa '/' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas dividen 9 ÷ 3 = 3, con pureza funcional, para recetas. Diferencias: Racket usa '/' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-7": {
      "title": "Comparar área ajustada con operaciones compuestas y trigonometría",
      "racket": {
        "lines": [
          "(> (- (sqrt (+ (* 3 3) (* 4 4))) 2) 5)",
          "(> (- (round (sqrt (+ (* 4 4) (* 12 12)))) 1) 7)",
          "(> (- (expt 2 2) (remainder 3 2)) 1)",
          "(> (- (round (* (tan 1.5) 5)) 5) 10)",
          "(> (- (expt 6 2) (round (sin 2))) 15)"
        ]
      },
      "ocaml": {
        "lines": [
          "((sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) -. 2.0) >. 5.0)",
          "((Float.round (sqrt (4.0 *. 4.0 +. 12.0 *. 12.0)) -. 1.0) >. 7.0)",
          "(((2.0 ** 2.0) -. float_of_int (3 mod 2)) >. 1.0)",
          "((Float.round (Float.tan 1.5 *. 5.0) -. 5.0) >. 10.0)",
          "((6.0 ** 2.0 -. Float.round (Float.sin 2.0)) >. 15.0)"
        ]
      },
      "explanations_racket": [
        "Calcula (> (- (sqrt (+ (* 3 3) (* 4 4))) 2) 5). Aquí sqrt(9 + 16) = 5; 5 - 2 = 3; 3 > 5 → #f. (Usa raíz clásica luego resta y comparación.)",
        "Calcula (> (- (round (sqrt (+ (* 4 4) (* 12 12)))) 1) 7). sqrt(16 + 144) ≈ 12.649…; round → 13; 13 - 1 = 12; 12 > 7 → #t. (Combina raíz y redondeo antes de comparar.)",
        "Calcula (> (- (expt 2 2) (remainder 3 2)) 1). expt 2 2 = 4; remainder 3 2 = 1; 4 - 1 = 3; 3 > 1 → #t. (Integra potencia con resto entero.)",
        "Calcula (> (- (round (* (tan 1.5) 5)) 5) 10). tan(1.5) ≈ 14.1014; *5 ≈ 70.507; round → 71; 71 - 5 = 66; 66 > 10 → #t. (Ejemplo de trigonometría, escala y redondeo antes de comparar.)",
        "Calcula (> (- (expt 6 2) (round (sin 2))) 15). expt 6 2 = 36; sin(2) ≈ 0.9093; round → 1; 36 - 1 = 35; 35 > 15 → #t. (Mezcla potencia y función trigonométrica con redondeo.)"
      ],
      "explanations_ocaml": [
        "Calcula ((sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) -. 2.0) >. 5.0). sqrt(9.0 + 16.0) = 5.0; 5.0 -. 2.0 = 3.0; 3.0 >. 5.0 → false. (Equivalente en flotantes.)",
        "Calcula ((Float.round (sqrt (4.0 *. 4.0 +. 12.0 *. 12.0)) -. 1.0) >. 7.0). sqrt(160.0) ≈ 12.649…; Float.round → 13.0; 13.0 -. 1.0 = 12.0; 12.0 >. 7.0 → true.",
        "Calcula (((2.0 ** 2.0) -. float_of_int (3 mod 2)) >. 1.0). 2.0 ** 2.0 = 4.0; 3 mod 2 = 1 -> float_of_int 1 = 1.0; 4.0 -. 1.0 = 3.0; 3.0 >. 1.0 → true.",
        "Calcula ((Float.round (Float.tan 1.5 *. 5.0) -. 5.0) >. 10.0). Float.tan 1.5 ≈ 14.1014; *5.0 ≈ 70.507; Float.round → 71.0; 71.0 -. 5.0 = 66.0; 66.0 >. 10.0 → true.",
        "Calcula ((6.0 ** 2.0 -. Float.round (Float.sin 2.0)) >. 15.0). 6.0 ** 2.0 = 36.0; Float.sin 2.0 ≈ 0.9093; Float.round → 1.0; 36.0 -. 1.0 = 35.0; 35.0 >. 15.0 → true."
      ],
      "comparisons": [
        "Similitudes: Ambas plataformas realizan la misma lógica: componer funciones (raíz, trigonometría, round, remainder) y comparar el resultado con un umbral. Las diferencias notacionales reflejan Racket prefija vs OCaml infija y el uso de operadores de punto para flotantes en OCaml (>., +., -., *.).",
        "Linea 1: Racket devuelve #f porque (sqrt(9+16)-2)=3 no supera 5; OCaml devuelve false por la misma razón (flotantes).",
        "Linea 2: Racket y OCaml devuelven verdadero (Racket #t / OCaml true) tras redondear sqrt(160) a 13 y comparar 12 > 7.",
        "Linea 3: Uso de potencia y resto entero: ambas dan verdadero (Racket #t / OCaml true) porque 4 - 1 = 3 > 1.",
        "Linea 4: La versión con tan + escala + round produce un gran entero tras redondeo (71), por tanto ambas evaluaciones son verdaderas. Racket usa (round ( * (tan 1.5) 5 )), OCaml usa Float.tan y Float.round.",
        "Linea 5: Mezcla expt y sin redondeado da verdadero (36 - 1 = 35 > 15). Notación diferente pero semántica equivalente."
      ]
    }
  },
  "funciones": {
    "ejercicio-1": {
      "title": "Calcular el Área de un Terreno Rectangular",
      "racket": {
        "lines": [
          "(define (rectangle-area base height)",
          "  (* base height)",
          ")",
          "(rectangle-area 10 7)"
        ]
      },
      "ocaml": {
        "lines": [
          "let rectangle_area base height =",
          "  base * height",
          "in",
          "rectangle_area 10 7"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función llamada `rectangle-area` que toma dos números, `base` y `height`, para calcular el área de un rectángulo. Imagina que eres un agricultor midiendo un terreno para saber cuánta manguera necesitas para el riego. En Racket, `(define (nombre params) cuerpo)` es como escribir una receta que puedes usar cada vez que quieras calcular un área.",
        "Aquí multiplicamos `base` por `height` con `(* base height)`, como medir un terreno de 10 metros de largo por 7 de ancho para obtener el área. En Racket, usamos paréntesis porque todo se escribe como una lista, lo que hace que las operaciones sean claras y ordenadas. Esta línea es el corazón del cálculo.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para que Racket entienda que la función está completa.",
        "Esta línea usa la función con los números 10 y 7, calculando `10 * 7 = 70`. Es como probar la receta con un terreno específico para saber que el área es 70 metros cuadrados, útil para planificar el riego."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `rectangle_area` que toma `base` y `height`, como si quisieras calcular el tamaño de un terreno para sembrar. En OCaml, `let nombre params = cuerpo` es como hacer una receta sencilla para calcular áreas. La función está lista para recibir dos números y multiplicarlos.",
        "Aquí multiplicamos `base` por `height` con `base * height`, como contar el espacio de un terreno de 10 por 7 metros. En OCaml, escribimos `*` como en matemáticas, lo que lo hace fácil de entender. Esta línea hace el cálculo principal y da el resultado.",
        "Esta línea usa `in` para decir que vamos a usar la función después, como preparar la receta antes de probarla. Es una regla de OCaml para organizar el código, no hace cálculos, pero es importante para la estructura.",
        "Esta línea aplica la función con 10 y 7, calculando `10 * 7 = 70`. Es como usar la receta para confirmar que el terreno tiene 70 metros cuadrados, perfecto para planificar cuánto material necesitas."
      ],
      "comparisons": [
        "Similitudes: Ambas líneas crean una función que calcula el área de un rectángulo tomando dos números, usando el mismo nombre y propósito. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, como una lista clara, mientras que OCaml usa `let nombre params = cuerpo`, más corto y sin paréntesis. Racket no necesita especificar si los números son enteros, pero OCaml asume que `base` y `height` son enteros automáticamente.",
        "Similitudes: Ambas multiplican `base` por `height` para obtener el área, dando el mismo resultado. Diferencias: Racket usa `(* base height)` con paréntesis, porque en Racket `*` es como una instrucción, mientras que OCaml usa `base * height`, que se ve como una multiplicación matemática. OCaml es más corto y parece más familiar para principiantes.",
        "Similitudes: Ambas son partes estructurales del código, sin cálculos. Diferencias: Racket cierra la función con `)`, porque todo en Racket usa paréntesis, mientras que OCaml usa `in` para indicar que viene el uso de la función, una diferencia en cómo organizan el código.",
        "Similitudes: Ambas aplican la función con 10 y 7, dando 70. Diferencias: Racket escribe `(rectangle-area 10 7)` con paréntesis, mientras que OCaml escribe `rectangle_area 10 7`, más simple y sin paréntesis. Ambos logran lo mismo, pero OCaml se ve más limpio."
      ]
    },
    "ejercicio-2": {
      "title": "Contar Eventos Ajustados por Retrasos",
      "racket": {
        "lines": [
          "(define (adjusted-event-count total-time interval)",
          "  (let ((count (/ total-time interval))",
          "        (margin 2))",
          "    (- count margin)))",
          ")",
          "(adjusted-event-count 25 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let adjusted_event_count total_time interval =",
          "  let count = total_time / interval in",
          "  let margin = 2 in",
          "  count - margin",
          "in",
          "adjusted_event_count 25 5"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función llamada `adjusted-event-count` que toma dos números: `total-time` (el tiempo total) y `interval` (cada cuánto ocurre algo). Imagina que organizas un espectáculo de luces que parpadea cada 5 segundos durante 25 segundos. En Racket, `(define (nombre params) cuerpo)` es como escribir una receta para contar los parpadeos.",
        "Aquí comenzamos un bloque `let` para crear dos cajas temporales: `count` guarda el resultado de dividir `total-time` por `interval` (como dividir 25 entre 5 para saber cuántas veces parpadea la luz). Es como anotar el primer paso en una libreta para no perder el cálculo.",
        "Esta línea define `margin` como 2, un ajuste por retrasos técnicos, como anotar en la libreta que restarás 2 parpadeos por posibles demoras.",
        "Esta línea resta `margin` (2) de `count` con `(- count margin)` para obtener el resultado final, como ajustar el conteo de parpadeos. Los paréntesis en Racket mantienen todo claro y ordenado.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para completar la función.",
        "Esta línea usa la función con 25 y 5, calculando `(25 / 5) - 2 = 3`. Es como probar la receta para saber que la luz parpadea 3 veces después de ajustar por retrasos."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `adjusted_event_count` que toma `total_time` y `interval`, como contar cuántas veces suena una alarma en 25 segundos si suena cada 5 segundos. En OCaml, `let nombre params = cuerpo` es como hacer una receta clara para este cálculo.",
        "Usamos `let count = total_time / interval in` para guardar la división en una caja llamada `count`, como calcular cuántas veces suena la alarma (25 / 5 = 5). El `in` dice que este valor se usará después.",
        "Esta línea guarda el número 2 en una caja llamada `margin`, como anotar un ajuste por retrasos. El `in` indica que este valor se usará en el siguiente paso.",
        "Aquí restamos `margin` (2) de `count` con `count - margin`, como ajustar el conteo de alarmas. La notación se ve como una resta normal, fácil de entender.",
        "Esta línea usa `in` para conectar la función con su uso, como decir 'ahora probemos la receta'. Es una regla de OCaml para organizar el código, sin cálculos.",
        "Esta línea aplica la función con 25 y 5, dando `(25 / 5) - 2 = 3`, como confirmar que la alarma suena 3 veces después del ajuste."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que toma dos números para contar eventos ajustados, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, como una lista, mientras que OCaml usa `let nombre params = cuerpo`, más directo. OCaml asume enteros para los parámetros, Racket no especifica tipos.",
        "Similitudes: Ambas guardan la división en una variable local `count` usando `let`, como una libreta temporal. Diferencias: Racket escribe `(let ((count (/ total-time interval)))` con paréntesis dobles, mientras que OCaml usa `let count = total_time / interval in`, más simple y con `in` para conectar.",
        "Similitudes: Ambas guardan el valor 2 en `margin` con `let`. Diferencias: Racket incluye `margin` en el mismo `let` que `count`, usando `(margin 2)`, mientras que OCaml usa una línea separada `let margin = 2 in`, lo que hace el código más largo pero claro.",
        "Similitudes: Ambas restan `margin` de `count` para el resultado final. Diferencias: Racket usa `(- count margin)` con paréntesis, mientras que OCaml usa `count - margin`, como una resta matemática. Ambos dan el mismo resultado, pero OCaml es más intuitivo para principiantes.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para indicar que viene la llamada de la función, una diferencia en la organización.",
        "Similitudes: Ambas aplican la función con 25 y 5, dando 3. Diferencias: Racket usa `(adjusted-event-count 25 5)` con paréntesis, mientras que OCaml usa `adjusted_event_count 25 5`, más corto y sin paréntesis."
      ]
    },
    "ejercicio-3": {
      "title": "Calcular Daño de Ataque en un Videojuego",
      "racket": {
        "lines": [
          "(define (damage level)",
          "  (let ((square (* level level))",
          "        (double (* 2 level)))",
          "    (+ square double)))",
          ")",
          "(damage 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "let damage level =",
          "  let square = level * level in",
          "  let double = 2 * level in",
          "  square + double",
          "in",
          "damage 8"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `damage` que toma un número `level`, como el nivel de un personaje en un videojuego. Imagina que eres un diseñador calculando cuánto daño hace un ataque. En Racket, `(define (nombre params) cuerpo)` es como hacer una receta para calcular el daño según el nivel.",
        "Aquí comenzamos un bloque `let` para crear dos cajas temporales: `square` guarda el cuadrado del nivel (`level * level`), como calcular la fuerza base del ataque. Es como anotar el primer paso en una libreta.",
        "Esta línea define `double` como `2 * level`, un bono extra por el nivel, como escribir el segundo paso en la libreta para no mezclar los números.",
        "Aquí sumamos `square` y `double` con `(+ square double)` para obtener el daño total, como combinar la fuerza base y el bono para el ataque final. Los paréntesis en Racket mantienen todo claro.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para completar la función.",
        "Esta línea usa la función con el nivel 8, calculando `(8 * 8) + (2 * 8) = 64 + 16 = 80`. Es como probar la receta para saber cuánto daño hace un personaje de nivel 8."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `damage` que toma `level`, como el nivel de un héroe en un juego. En OCaml, `let nombre params = cuerpo` es como hacer una receta para calcular el daño del ataque. La función está lista para recibir un número y procesarlo.",
        "Usamos `let square = level * level in` para guardar el cuadrado del nivel en una caja llamada `square`, como calcular la fuerza principal del ataque. El `in` dice que este valor se usará después.",
        "Esta línea guarda el doble del nivel (`2 * level`) en una caja llamada `double`, como un extra por la experiencia del héroe. El `in` indica que este valor se usará en el siguiente paso.",
        "Aquí sumamos `square` y `double` con `square + double`, como combinar la fuerza base y el extra para el daño total. En OCaml, la suma se escribe como en matemáticas, fácil de entender.",
        "Esta línea usa `in` para conectar la función con su uso, como decir 'ahora probemos la receta'. Es una regla de OCaml para organizar el código.",
        "Esta línea aplica la función con 8, dando `(8 * 8) + (2 * 8) = 64 + 16 = 80`, como confirmar el daño de un héroe de nivel 8."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el daño según el nivel, usando el mismo nombre y propósito. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml asume que `level` es un entero, Racket no especifica tipos.",
        "Similitudes: Ambas guardan el cuadrado del nivel en `square` usando `let`, como una libreta temporal. Diferencias: Racket usa `(let ((square (* level level)))` con paréntesis dobles, mientras que OCaml usa `let square = level * level in`, más simple y con `in`.",
        "Similitudes: Ambas guardan el doble del nivel en `double` con `let`. Diferencias: Racket incluye `double` en el mismo `let` que `square`, mientras que OCaml usa una línea separada `let double = 2 * level in`, haciendo el código más largo pero claro.",
        "Similitudes: Ambas suman `square` y `double` para el resultado final. Diferencias: Racket usa `(+ square double)` con paréntesis, mientras que OCaml usa `square + double`, como una suma matemática. Ambos dan el mismo resultado, pero OCaml es más intuitivo.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada, una diferencia en la organización.",
        "Similitudes: Ambas aplican la función con 8, dando 80. Diferencias: Racket usa `(damage 8)` con paréntesis, mientras que OCaml usa `damage 8`, más corto."
      ]
    },
    "ejercicio-4": {
      "title": "Calcular la Hipotenusa de un Triángulo",
      "racket": {
        "lines": [
          "(define (hypotenuse a b)",
          "  (let ((a-square (* a a))",
          "        (b-square (* b b)))",
          "    (sqrt (+ a-square b-square)))",
          ")",
          "(hypotenuse 6 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "let hypotenuse a b =",
          "  let a_square = a *. a in",
          "  let b_square = b *. b in",
          "  sqrt (a_square +. b_square)",
          "in",
          "hypotenuse 6.0 8.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `hypotenuse` que toma dos números, `a` y `b`, los lados de un triángulo. Imagina que eres un ingeniero diseñando un puente y necesitas la longitud de un soporte diagonal. En Racket, `(define (nombre params) cuerpo)` es como hacer una receta para este cálculo.",
        "Aquí comenzamos un bloque `let` para crear dos cajas: `a-square` guarda el cuadrado de `a` (`a * a`), como calcular una parte de la fórmula de Pitágoras. Es como anotar el primer paso en una libreta.",
        "Esta línea define `b-square` como `b * b`, el cuadrado del otro lado, como el segundo paso en la libreta para mantener los cálculos organizados.",
        "Aquí sumamos `a-square` y `b-square` con `(+ a-square b-square)`, luego tomamos la raíz cuadrada con `sqrt`, como encontrar la longitud del soporte diagonal. Los paréntesis en Racket hacen que todo esté claro.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con 6 y 8, calculando `sqrt((6 * 6) + (8 * 8)) = sqrt(36 + 64) = 10`. Es como probar la receta para un triángulo con lados de 6 y 8 metros."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `hypotenuse` que toma `a` y `b`, como los lados de un triángulo para un soporte. En OCaml, `let nombre params = cuerpo` es como hacer una receta para calcular la longitud diagonal. La función está lista para recibir dos números.",
        "Usamos `let a_square = a *. a in` para guardar el cuadrado de `a` en una caja llamada `a_square`, como un paso de la fórmula de Pitágoras. El `*.` es para números con decimales, y `in` dice que usaremos este valor después.",
        "Esta línea guarda el cuadrado de `b` (`b *. b`) en `b_square`, como otro paso de la fórmula. El `in` indica que este valor se usará a continuación.",
        "Aquí sumamos `a_square` y `b_square` con `+.`, luego tomamos la raíz cuadrada con `sqrt`, como calcular la longitud final del soporte. En OCaml, usamos `+.` para sumas con decimales, y la notación es como en matemáticas.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta para probarla. Es una regla de OCaml para organizar el código.",
        "Esta línea aplica la función con 6.0 y 8.0, dando `sqrt((6.0 * 6.0) + (8.0 * 8.0)) = 10`. Es como confirmar la longitud del soporte para un triángulo de 6 y 8 metros."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula la hipotenusa con dos números, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere números con decimales (6.0, 8.0), Racket acepta enteros.",
        "Similitudes: Ambas guardan el cuadrado de `a` en `a_square` usando `let`. Diferencias: Racket usa `(let ((a-square (* a a)))` con paréntesis, mientras que OCaml usa `let a_square = a *. a in`, con `*.` para decimales y `in` para conectar.",
        "Similitudes: Ambas guardan el cuadrado de `b` en `b_square`. Diferencias: Racket incluye `b-square` en el mismo `let`, mientras que OCaml usa una línea separada `let b_square = b *. b in`, más clara pero más larga.",
        "Similitudes: Ambas suman los cuadrados y toman la raíz cuadrada. Diferencias: Racket usa `(sqrt (+ a-square b-square))` con paréntesis, mientras que OCaml usa `sqrt (a_square +. b_square)` con `+.` para decimales. OCaml es más parecido a una fórmula matemática.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada, una diferencia en la organización.",
        "Similitudes: Ambas aplican la función con 6 y 8, dando 10. Diferencias: Racket usa `(hypotenuse 6 8)` con enteros, mientras que OCaml usa `hypotenuse 6.0 8.0` con decimales, porque OCaml es más estricto con los tipos."
      ]
    },
    "ejercicio-5": {
      "title": "Calcular el Volumen de una Olla Esférica",
      "racket": {
        "lines": [
          "(define (sphere-volume r)",
          "  (let ((cube (* r r r))",
          "        (pi 3.14159)",
          "        (fraction (/ 4 3)))",
          "    (* fraction pi cube)))",
          ")",
          "(sphere-volume 0.3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let sphere_volume r =",
          "  let cube = r *. r *. r in",
          "  let pi = 3.14159 in",
          "  let fraction = 4.0 /. 3.0 in",
          "  fraction *. pi *. cube",
          "in",
          "sphere_volume 0.3"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `sphere-volume` que toma un número `r` (radio), como si fueras un chef diseñando una olla redonda. En Racket, `(define (nombre params) cuerpo)` es como hacer una receta para calcular cuánto cabe en la olla.",
        "Aquí comenzamos un bloque `let` para crear tres cajas: `cube` guarda el cubo del radio (`r * r * r`), como calcular una parte de la fórmula del volumen. Es como anotar el primer paso en una libreta.",
        "Esta línea define `pi` como 3.14159, una constante para cálculos circulares, como un número mágico en la receta.",
        "Esta línea define `fraction` como `4/3`, otro paso de la fórmula, como anotar una proporción en la libreta.",
        "Aquí multiplicamos `fraction`, `pi`, y `cube` con `(* fraction pi cube)` para obtener el volumen, como mezclar todos los ingredientes para saber cuánto cabe en la olla. Los paréntesis mantienen todo ordenado.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con 0.3, calculando `(4/3) * 3.14159 * (0.3 * 0.3 * 0.3) ≈ 0.11309724`. Es como probar la receta para una olla con radio de 0.3 metros."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `sphere_volume` que toma `r`, como calcular el espacio en una olla esférica. En OCaml, `let nombre params = cuerpo` es como hacer una receta para el volumen. La función está lista para recibir un número.",
        "Usamos `let cube = r *. r *. r in` para guardar el cubo del radio en `cube`, como un paso de la fórmula. El `*.` es para números con decimales, y `in` dice que usaremos este valor después.",
        "Esta línea guarda 3.14159 en `pi`, como un número especial para cálculos de círculos. El `in` indica que se usará a continuación.",
        "Esta línea guarda `4.0 / 3.0` en `fraction`, como otro paso de la fórmula. El `/.` es para divisiones con decimales.",
        "Aquí multiplicamos `fraction`, `pi`, y `cube` con `fraction *. pi *. cube`, como combinar los pasos para el volumen final. En OCaml, usamos `*.` para multiplicaciones con decimales.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. Es una regla de OCaml.",
        "Esta línea aplica la función con 0.3, dando `(4.0 / 3.0) * 3.14159 * (0.3 * 0.3 * 0.3) ≈ 0.11309724`, como confirmar el volumen de la olla."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el volumen de una esfera, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (0.3), Racket acepta números sin especificar tipo.",
        "Similitudes: Ambas guardan el cubo del radio en `cube` usando `let`. Diferencias: Racket usa `(let ((cube (* r r r)))` con paréntesis, mientras que OCaml usa `let cube = r *. r *. r in` con `*.` para decimales y `in` para conectar.",
        "Similitudes: Ambas guardan 3.14159 en `pi`. Diferencias: Racket incluye `pi` en el mismo `let`, mientras que OCaml usa una línea separada `let pi = 3.14159 in`, más clara pero más larga.",
        "Similitudes: Ambas guardan `4/3` en `fraction`. Diferencias: Racket usa `(/ 4 3)` como fracción, mientras que OCaml usa `4.0 /. 3.0` con decimales y `/.` para división.",
        "Similitudes: Ambas multiplican `fraction`, `pi`, y `cube` para el volumen. Diferencias: Racket usa `(* fraction pi cube)` con paréntesis, mientras que OCaml usa `fraction *. pi *. cube` con `*.` para decimales, más parecido a una fórmula matemática.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada.",
        "Similitudes: Ambas aplican la función con 0.3, dando ≈0.11309724. Diferencias: Racket usa `(sphere-volume 0.3)`, OCaml usa `sphere_volume 0.3` con decimal explícito."
      ]
    },
    "ejercicio-6": {
      "title": "Calcular Interés Compuesto con Tarifa",
      "racket": {
        "lines": [
          "(define (compound-interest p r n t)",
          "  (let ((rate-factor (+ 1 (/ r n)))",
          "        (periods (* n t))",
          "        (fee 50))",
          "    (- (* p (expt rate-factor periods)) fee)))",
          ")",
          "(compound-interest 1000 0.04 12 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compound_interest p r n t =",
          "  let rate_factor = 1.0 +. (r /. n) in",
          "  let periods = n *. t in",
          "  let fee = 50.0 in",
          "  (p *. (rate_factor ** periods)) -. fee",
          "in",
          "compound_interest 1000.0 0.04 12.0 3.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `compound-interest` que toma cuatro números: `p` (dinero inicial), `r` (tasa de interés), `n` (veces que se aplica al año), y `t` (años). Imagina que eres un financiero calculando cuánto crecerá 1000 dólares. En Racket, `(define (nombre params) cuerpo)` es como una receta para este cálculo.",
        "Aquí comenzamos un bloque `let` para crear tres cajas: `rate-factor` guarda `1 + (r / n)`, como el crecimiento por período. Es como anotar el primer paso en una libreta.",
        "Esta línea define `periods` como `n * t`, como contar cuántas veces se aplica el interés, un segundo paso en la libreta.",
        "Esta línea define `fee` como 50, una tarifa fija que se resta al final, como un tercer paso en la libreta.",
        "Aquí multiplicamos `p` por `rate-factor` elevado a `periods` con `(expt rate-factor periods)`, luego restamos `fee`, como calcular el dinero final menos la tarifa. Los paréntesis mantienen todo ordenado.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con 1000, 0.04, 12, y 3, dando ≈1077.49786. Es como probar la receta para saber cuánto dinero tendrás después de 3 años."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `compound_interest` que toma `p`, `r`, `n`, y `t`, como calcular cuánto crecerá un ahorro. En OCaml, `let nombre params = cuerpo` es como una receta para este cálculo financiero.",
        "Usamos `let rate_factor = 1.0 +. (r /. n) in` para guardar el factor de crecimiento por período, como un paso de la fórmula. Los operadores `+.` y `/.` son para decimales, y `in` dice que usaremos este valor después.",
        "Esta línea guarda `n * t` en `periods`, como contar los períodos de interés. El `*.` es para multiplicaciones con decimales.",
        "Esta línea guarda 50.0 en `fee`, como una tarifa que se resta al final. El `in` organiza el cálculo.",
        "Aquí multiplicamos `p` por `rate-factor` elevado a `periods` con `(rate_factor ** periods)`, luego restamos `fee` con `-.`, como calcular el dinero final. En OCaml, usamos operadores para decimales.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. Es una regla de OCaml.",
        "Esta línea aplica la función con 1000.0, 0.04, 12.0, y 3.0, dando ≈1077.49786, como confirmar el crecimiento del dinero."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función para calcular interés compuesto, usando el mismo nombre y cuatro parámetros. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (1000.0, 0.04), Racket acepta números sin especificar tipo.",
        "Similitudes: Ambas guardan el factor de interés en `rate_factor` con `let`. Diferencias: Racket usa `(let ((rate-factor (+ 1 (/ r n))))` con paréntesis, mientras que OCaml usa `let rate_factor = 1.0 +. (r /. n) in` con operadores para decimales y `in`.",
        "Similitudes: Ambas guardan `n * t` en `periods`. Diferencias: Racket incluye `periods` en el mismo `let`, mientras que OCaml usa una línea separada `let periods = n *. t in`, más clara pero más larga.",
        "Similitudes: Ambas guardan 50 en `fee`. Diferencias: Racket usa `(fee 50)`, OCaml usa `let fee = 50.0 in` con decimal explícito.",
        "Similitudes: Ambas calculan `p * (rate-factor ^ periods) - fee`. Diferencias: Racket usa `(* p (expt rate-factor periods))` y `(- ... fee)` con paréntesis, mientras que OCaml usa `(p *. (rate_factor ** periods)) -. fee` con operadores para decimales, más parecido a matemáticas.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada.",
        "Similitudes: Ambas aplican la función con los mismos valores, dando ≈1077.49786. Diferencias: Racket usa `(compound-interest 1000 0.04 12 3)`, OCaml usa `compound_interest 1000.0 0.04 12.0 3.0` con decimales."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular Distancia entre Estrellas en 3D",
      "racket": {
        "lines": [
          "(define (distance-3d x1 y1 z1 x2 y2 z2)",
          "  (let ((dx (- x2 x1))",
          "        (dy (- y2 y1))",
          "        (dz (- z2 z1)))",
          "    (let ((dx-square (* dx dx))",
          "          (dy-square (* dy dy))",
          "          (dz-square (* dz dz)))",
          "      (sqrt (+ dx-square dy-square dz-square))))",
          ")",
          "(distance-3d 2 3 4 5 7 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "let distance_3d x1 y1 z1 x2 y2 z2 =",
          "  let dx = x2 -. x1 in",
          "  let dy = y2 -. y1 in",
          "  let dz = z2 -. z1 in",
          "  let dx_square = dx *. dx in",
          "  let dy_square = dy *. dy in",
          "  let dz_square = dz *. dz in",
          "  sqrt (dx_square +. dy_square +. dz_square)",
          "in",
          "distance_3d 2.0 3.0 4.0 5.0 7.0 8.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `distance-3d` que toma seis números (coordenadas de dos puntos en el espacio: `x1, y1, z1` y `x2, y2, z2`). Imagina que eres un astrónomo midiendo la distancia entre dos estrellas. En Racket, `(define (nombre params) cuerpo)` es como una receta para este cálculo complejo.",
        "Aquí comenzamos un bloque `let` para crear tres cajas: `dx` guarda la diferencia `x2 - x1`, como medir cuánto se mueven las estrellas en la dirección horizontal. Es como anotar el primer paso en una libreta.",
        "Esta línea define `dy` como `y2 - y1`, la diferencia en la dirección vertical, como un segundo paso en la libreta.",
        "Esta línea define `dz` como `z2 - z1`, la diferencia en profundidad, completando las diferencias en las tres direcciones.",
        "Aquí comenzamos otro bloque `let` para crear tres cajas más: `dx-square` guarda el cuadrado de `dx`, como calcular una parte de la fórmula de distancia. Es como un nuevo paso en la libreta.",
        "Esta línea define `dy-square` como el cuadrado de `dy`, la diferencia vertical al cuadrado, como otro paso.",
        "Esta línea define `dz-square` como el cuadrado de `dz`, la diferencia en profundidad al cuadrado, completando los cuadrados.",
        "Aquí sumamos `dx-square`, `dy-square`, y `dz-square` con `(+ dx-square dy-square dz-square)`, luego tomamos la raíz cuadrada con `sqrt`, como encontrar la distancia final entre las estrellas. Los paréntesis mantienen todo claro.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con las coordenadas (2, 3, 4) y (5, 7, 8), dando ≈6.403124237. Es como probar la receta para medir la distancia entre dos estrellas."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `distance_3d` que toma seis números, las coordenadas de dos puntos, como medir la distancia entre dos planetas. En OCaml, `let nombre params = cuerpo` es como una receta para este cálculo.",
        "Usamos `let dx = x2 -. x1 in` para guardar la diferencia horizontal en `dx`, como un paso de la fórmula. El `-.` es para restas con decimales, y `in` dice que usaremos este valor.",
        "Esta línea guarda la diferencia vertical en `dy`, como medir cuánto se mueve un planeta hacia arriba.",
        "Esta línea guarda la diferencia en profundidad en `dz`, completando las diferencias en las tres direcciones.",
        "Usamos `let dx_square = dx *. dx in` para guardar el cuadrado de `dx`, como un paso para la fórmula de distancia.",
        "Esta línea guarda el cuadrado de `dy` en `dy_square`, como otro paso.",
        "Esta línea guarda el cuadrado de `dz` en `dz_square`, completando los cuadrados.",
        "Aquí sumamos `dx_square`, `dy_square`, y `dz_square` con `+.`, luego tomamos la raíz cuadrada con `sqrt`, como calcular la distancia final. En OCaml, usamos `+.` para sumas con decimales.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con (2.0, 3.0, 4.0) y (5.0, 7.0, 8.0), dando ≈6.403124237, como confirmar la distancia entre planetas."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula la distancia 3D con seis parámetros, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (2.0, 3.0, etc.), Racket acepta enteros.",
        "Similitudes: Ambas guardan la diferencia horizontal en `dx` con `let`. Diferencias: Racket usa `(let ((dx (- x2 x1)))` con paréntesis, mientras que OCaml usa `let dx = x2 -. x1 in` con `-.` para decimales y `in`.",
        "Similitudes: Ambas guardan la diferencia vertical en `dy`. Diferencias: Racket incluye `dy` en el mismo `let`, mientras que OCaml usa una línea separada, más clara pero más larga.",
        "Similitudes: Ambas guardan la diferencia en profundidad en `dz`. Diferencias: Como antes, Racket usa un solo `let`, OCaml usa líneas separadas.",
        "Similitudes: Ambas guardan el cuadrado de `dx` en `dx_square`. Diferencias: Racket usa un segundo `let` con paréntesis, OCaml usa una nueva línea con `*.` para decimales.",
        "Similitudes: Ambas guardan el cuadrado de `dy`. Diferencias: Racket incluye `dy-square` en el segundo `let`, OCaml usa una línea separada.",
        "Similitudes: Ambas guardan el cuadrado de `dz`. Diferencias: Igual que con `dy-square`, OCaml usa más líneas, Racket es más compacto.",
        "Similitudes: Ambas suman los cuadrados y toman la raíz cuadrada. Diferencias: Racket usa `(sqrt (+ dx-square dy-square dz-square))` con paréntesis, mientras que OCaml usa `sqrt (dx_square +. dy_square +. dz_square)` con `+.` para decimales, más matemático.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada.",
        "Similitudes: Ambas aplican la función con las mismas coordenadas, dando ≈6.403124237. Diferencias: Racket usa `(distance-3d 2 3 4 5 7 8)` con enteros, OCaml usa `distance_3d 2.0 3.0 4.0 5.0 7.0 8.0` con decimales."
      ]
    }
  },
  "funciones-multiples": {
    "ejercicio-1": {
      "title": "Calcular el Área de un Mural Triangular",
      "racket": {
        "lines": [
          "(define (triangle-area base height)",
          "  (/ (* base height) 2)",
          ")",
          "(triangle-area 8 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let triangle_area base height =",
          "  (base *. height) /. 2.0",
          "in",
          "triangle_area 8.0 5.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `triangle-area` que toma dos parámetros, `base` y `height`, para calcular el área de un triángulo. Imagina que eres un artista pintando un mural triangular de 8 metros de base y 5 de altura. En Racket, `(define (nombre params) cuerpo)` es como escribir una receta sencilla para saber cuánta pintura necesitas.",
        "Aquí multiplicamos `base` por `height` con `(* base height)` y dividimos por 2 con `(/ ... 2)`, como calcular el área (base * altura / 2). Los paréntesis organizan la operación en una línea clara, dando el resultado final.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para completar la función.",
        "Esta línea aplica la función con 8 y 5, dando `(8 * 5) / 2 = 20`. Es como probar la receta para confirmar que el mural requiere pintura para 20 metros cuadrados."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `triangle_area` que toma `base` y `height`, como calcular el área de un mural triangular. En OCaml, `let nombre params = cuerpo` es como una receta sencilla. La función está lista para recibir dos números.",
        "Aquí multiplicamos `base` por `height` con `base *. height` y dividimos por 2.0 con `/.`, como calcular el área (base * altura / 2). El `*.` y `/.` son para números con decimales, dando un resultado preciso.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta antes de probarla. Es una regla de OCaml, sin cálculos.",
        "Esta línea aplica la función con 8.0 y 5.0, dando `(8.0 * 5.0) / 2.0 = 20.0`. Es como confirmar el área del mural para planificar la pintura."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el área de un triángulo con dos parámetros, con el mismo propósito y resultado (20). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (8.0, 5.0), Racket acepta enteros.",
        "Similitudes: Ambas realizan la multiplicación y división en una línea, dando el mismo resultado. Diferencias: Racket usa `(/ (* base height) 2)` con notación prefija y paréntesis, mientras que OCaml usa `(base *. height) /. 2.0` con notación infija, más parecida a matemáticas. OCaml usa operadores `*.` y `/.` para decimales.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para conectar con la evaluación.",
        "Similitudes: Ambas aplican la función con 8 y 5, dando 20. Diferencias: Racket usa `(triangle-area 8 5)` con paréntesis y enteros, mientras que OCaml usa `triangle_area 8.0 5.0` sin paréntesis y con decimales."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar si Tres Tiempos de Tareas Están en Orden Ascendente",
      "racket": {
        "lines": [
          "(define (ascending? a b c)",
          "  (let ((ab (< a b))",
          "        (bc (< b c)))",
          "    (and ab bc))",
          ")",
          "(ascending? 2 3 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let ascending a b c =",
          "  let ab = a < b in",
          "  let bc = b < c in",
          "  ab && bc",
          "in",
          "ascending 2 3 4"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `ascending?` que toma tres parámetros, `a`, `b`, `c`, como tiempos de tareas (2, 3, 4 minutos). Imagina que eres un organizador verificando si las tareas toman tiempos crecientes. En Racket, `(define (nombre params) cuerpo)` es como una receta para esta validación lógica.",
        "Aquí comenzamos un bloque `let` para crear una variable `ab` que guarda si `a` es menor que `b` con `(< a b)`. Es como anotar en una libreta si la primera tarea es más corta que la segunda.",
        "Esta línea define `bc` como `(< b c)`, verificando si `b` es menor que `c`. Es como anotar si la segunda tarea es más corta que la tercera.",
        "Aquí combinamos `ab` y `bc` con `and` para verificar que ambas condiciones son ciertas, retornando `true` si los tiempos están en orden ascendente. Es como revisar la libreta para confirmar el orden.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta.",
        "Esta línea aplica la función con 2, 3, 4, verificando `2 < 3` y `3 < 4`, dando `true`. Es como probar la receta para confirmar el orden ascendente."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `ascending` que toma `a`, `b`, `c`, como tiempos de tareas. En OCaml, `let nombre params = cuerpo` es como una receta para verificar si los tiempos crecen. La función está lista para tres números.",
        "Aquí definimos `ab` como `a < b`, verificando si `a` es menor que `b`. Es como anotar si la primera tarea es más corta que la segunda. El `in` indica que usaremos este valor después.",
        "Esta línea define `bc` como `b < c`, verificando si `b` es menor que `c`. Es como anotar si la segunda tarea es más corta que la tercera.",
        "Aquí combinamos `ab` y `bc` con `&&`, retornando `true` si ambas son ciertas. Es como revisar las anotaciones para confirmar el orden ascendente.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. No hace cálculos.",
        "Esta línea aplica la función con 2, 3, 4, verificando `2 < 3` y `3 < 4`, dando `true`. Es como confirmar el orden de las tareas."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que verifica si tres números están en orden ascendente, con el mismo propósito y resultado (`true`). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis y `ascending?` (con ? para booleano), mientras que OCaml usa `let nombre params = cuerpo` y `ascending`, más corto.",
        "Similitudes: Ambas definen una variable para `a < b`. Diferencias: Racket usa `(let ((ab (< a b)))` con paréntesis y notación prefija, mientras que OCaml usa `let ab = a < b in` con notación infija y `in` para conectar pasos.",
        "Similitudes: Ambas definen una variable para `b < c`. Diferencias: Racket incluye `bc` en el mismo `let`, mientras OCaml usa una línea separada `let bc = b < c in`, más clara para principiantes.",
        "Similitudes: Ambas combinan las condiciones con un operador lógico (`and` en Racket, `&&` en OCaml). Diferencias: Racket usa `(and ab bc)` con paréntesis, mientras que OCaml usa `ab && bc`, más simple y matemático.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in` para la evaluación.",
        "Similitudes: Ambas aplican la función con 2, 3, 4, dando `true`. Diferencias: Racket usa `(ascending? 2 3 4)` con paréntesis, OCaml usa `ascending 2 3 4`, más corto."
      ]
    },
    "ejercicio-3": {
      "title": "Calcular la Distancia Euclidiana entre Dos Puntos",
      "racket": {
        "lines": [
          "(define (distance x1 y1 x2 y2)",
          "  (sqrt (+ (expt (- x2 x1) 2)",
          "           (expt (- y2 y1) 2))",
          "  )",
          ")",
          "(distance 1 2 4 6)"
        ]
      },
      "ocaml": {
        "lines": [
          "let distance x1 y1 x2 y2 =",
          "  sqrt ((x2 -. x1) ** 2.0 +.",
          "        (y2 -. y1) ** 2.0)",
          "in",
          "distance 1.0 2.0 4.0 6.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `distance` que toma cuatro parámetros, `x1`, `y1`, `x2`, `y2`, como coordenadas de dos puntos (1,2) y (4,6). Imagina que eres un estudiante midiendo cuánto caminaste entre esos puntos. En Racket, `(define (nombre params) cuerpo)` es como una receta para calcular la distancia euclidiana.",
        "Aquí calculamos la raíz cuadrada con `sqrt` de una suma. La suma incluye `(expt (- x2 x1) 2)`, que calcula el cuadrado de la diferencia horizontal (x2-x1). Es como medir cuánto te moviste en horizontal.",
        "Esta línea agrega `(expt (- y2 y1) 2)`, el cuadrado de la diferencia vertical (y2-y1), completando la fórmula `sqrt((x2-x1)^2 + (y2-y1)^2)`. Es como medir el movimiento vertical y combinarlo.",
        "Esta línea cierra el bloque `sqrt` con un paréntesis, asegurando que la suma se calcule primero. No hace cálculos, pero organiza la fórmula.",
        "Esta línea cierra la definición de la función con otro paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 1, 2, 4, 6, dando `sqrt((4-1)^2 + (6-2)^2) = sqrt(9 + 16) = 5`. Es como probar la receta para medir la caminata."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `distance` que toma `x1`, `y1`, `x2`, `y2`, como coordenadas. En OCaml, `let nombre params = cuerpo` es como una receta para calcular la distancia. La función está lista para cuatro números.",
        "Aquí calculamos la raíz cuadrada con `sqrt` de una suma. `(x2 -. x1) ** 2.0` calcula el cuadrado de la diferencia horizontal, usando `-.` y `**` para decimales. Es como medir el movimiento horizontal.",
        "Esta línea agrega `(y2 -. y1) ** 2.0` con `+.`, completando la fórmula `sqrt((x2-x1)^2 + (y2-y1)^2)`. Es como medir el movimiento vertical y sumarlo.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. No hace cálculos.",
        "Esta línea aplica la función con 1.0, 2.0, 4.0, 6.0, dando `sqrt((4.0-1.0)^2 + (6.0-2.0)^2) = 5.0`. Es como confirmar la distancia de la caminata."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula la distancia euclidiana con cuatro parámetros, con el mismo propósito y resultado (5). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales, Racket acepta enteros.",
        "Similitudes: Ambas calculan el cuadrado de la diferencia horizontal dentro de una raíz. Diferencias: Racket usa `(expt (- x2 x1) 2)` con notación prefija, mientras que OCaml usa `(x2 -. x1) ** 2.0` con notación infija y operadores `-.` y `**` para decimales.",
        "Similitudes: Ambas suman el cuadrado de la diferencia vertical para completar la fórmula. Diferencias: Racket usa `(+ ...)` con paréntesis, mientras que OCaml usa `+.` para suma con decimales, más intuitiva como ecuación matemática.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `sqrt` con `)`, OCaml usa `in` para la evaluación.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml no necesita un cierre adicional aquí.",
        "Similitudes: Ambas aplican la función con 1, 2, 4, 6, dando 5. Diferencias: Racket usa `(distance 1 2 4 6)` con paréntesis y enteros, OCaml usa `distance 1.0 2.0 4.0 6.0` con decimales."
      ]
    },
    "ejercicio-4": {
      "title": "Encontrar el Máximo de Tres Puntajes en un Torneo",
      "racket": {
        "lines": [
          "(define (max-of-three a b c)",
          "  (let ((bc (max b c))",
          "        (max-abc (max a bc)))",
          "    max-abc)",
          ")",
          "(max-of-three 6 8 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let max_of_three a b c =",
          "  let bc = max b c in",
          "  let max_abc = max a bc in",
          "  max_abc",
          "in",
          "max_of_three 6 8 4"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `max-of-three` que toma tres parámetros, `a`, `b`, `c`, como puntajes en un torneo (6, 8, 4). Imagina que eres un juez buscando el puntaje más alto. En Racket, `(define (nombre params) cuerpo)` es como una receta para esta comparación.",
        "Aquí comenzamos un bloque `let` y definimos `bc` como `(max b c)`, que encuentra el mayor entre `b` y `c`. Es como anotar en una libreta cuál de los dos últimos puntajes es mayor.",
        "Esta línea define `max-abc` como `(max a bc)`, comparando `a` con el resultado anterior. Es como decidir si el primer puntaje supera al mayor de los otros dos.",
        "Aquí retornamos `max-abc`, el puntaje más alto. Es como entregar el resultado final de la comparación.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 6, 8, 4, dando `max(6, max(8, 4)) = max(6, 8) = 8`. Es como probar la receta para encontrar el puntaje más alto."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `max_of_three` que toma `a`, `b`, `c`, como puntajes. En OCaml, `let nombre params = cuerpo` es como una receta para encontrar el máximo. La función está lista para tres números.",
        "Aquí definimos `bc` como `max b c`, que encuentra el mayor entre `b` y `c`. Es como anotar cuál de los dos últimos puntajes es mayor. El `in` indica que usaremos este valor.",
        "Esta línea define `max_abc` como `max a bc`, comparando `a` con el resultado anterior. Es como verificar si el primer puntaje es mayor.",
        "Aquí retornamos `max_abc`, el puntaje más alto. Es como entregar el resultado final.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 6, 8, 4, dando `max(6, max(8, 4)) = 8`. Es como confirmar el puntaje más alto."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que encuentra el máximo de tres números, con el mismo propósito y resultado (8). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml asume enteros, Racket no especifica tipos.",
        "Similitudes: Ambas definen una variable para el máximo de `b` y `c`. Diferencias: Racket usa `(let ((bc (max b c)))` con paréntesis, mientras que OCaml usa `let bc = max b c in` con notación infija y `in`.",
        "Similitudes: Ambas comparan `a` con el máximo anterior. Diferencias: Racket incluye `max-abc` en el mismo `let`, mientras que OCaml usa una línea separada `let max_abc = max a bc in`, más clara.",
        "Similitudes: Ambas retornan el resultado final (`max-abc`). Diferencias: Racket usa `max-abc` dentro del `let`, OCaml lo retorna directamente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 6, 8, 4, dando 8. Diferencias: Racket usa `(max-of-three 6 8 4)` con paréntesis, OCaml usa `max_of_three 6 8 4`, más corto."
      ]
    },
    "ejercicio-5": {
      "title": "Calcular el Promedio de Tres Gastos de Amigos",
      "racket": {
        "lines": [
          "(define (average-three a b c)",
          "  (let ((sum (+ a b c))",
          "        (avg (/ sum 3)))",
          "    avg)",
          ")",
          "(average-three 10 15 20)"
        ]
      },
      "ocaml": {
        "lines": [
          "let average_three a b c =",
          "  let sum = a + b + c in",
          "  let avg = sum / 3 in",
          "  avg",
          "in",
          "average_three 10 15 20"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `average-three` que toma tres parámetros, `a`, `b`, `c`, como gastos de amigos (10, 15, 20 dólares). Imagina que quieres saber cuánto gastaron en promedio. En Racket, `(define (nombre params) cuerpo)` es como una receta para calcular promedios.",
        "Aquí comenzamos un bloque `let` y definimos `sum` como `(+ a b c)`, sumando los tres gastos. Es como anotar en una libreta el total gastado por los amigos.",
        "Esta línea define `avg` como `(/ sum 3)`, dividiendo la suma por 3 para obtener el promedio. Es como calcular cuánto le toca a cada amigo si dividen el total.",
        "Aquí retornamos `avg`, el promedio final. Es como entregar el resultado de la división.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 10, 15, 20, dando `(10 + 15 + 20) / 3 = 15`. Es como probar la receta para confirmar el promedio."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `average_three` que toma `a`, `b`, `c`, como gastos. En OCaml, `let nombre params = cuerpo` es como una receta para promedios. La función está lista para tres números.",
        "Aquí definimos `sum` como `a + b + c`, sumando los gastos. Es como anotar el total en una libreta. El `in` indica que usaremos este valor.",
        "Esta línea define `avg` como `sum / 3`, dividiendo la suma por 3. Es como calcular el promedio por amigo.",
        "Aquí retornamos `avg`, el promedio final. Es como entregar el resultado.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 10, 15, 20, dando `(10 + 15 + 20) / 3 = 15`. Es como confirmar el promedio."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el promedio de tres números, con el mismo propósito y resultado (15). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml asume enteros, Racket no especifica tipos.",
        "Similitudes: Ambas suman los tres parámetros en una variable `sum`. Diferencias: Racket usa `(let ((sum (+ a b c)))` con paréntesis, mientras que OCaml usa `let sum = a + b + c in` con notación infija y `in`.",
        "Similitudes: Ambas dividen la suma por 3 para el promedio. Diferencias: Racket usa `(/ sum 3)` en el `let`, mientras que OCaml usa `let avg = sum / 3 in`, más clara.",
        "Similitudes: Ambas retornan el promedio (`avg`). Diferencias: Racket usa `avg` dentro del `let`, OCaml lo retorna directamente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 10, 15, 20, dando 15. Diferencias: Racket usa `(average-three 10 15 20)` con paréntesis, OCaml usa `average_three 10 15 20`, más corto."
      ]
    },
    "ejercicio-6": {
      "title": "Verificar si Tres Presiones Son Positivas y Ascendentes",
      "racket": {
        "lines": [
          "(define (positive-and-ascending? a b c)",
          "  (let ((pos-a (> a 0))",
          "        (pos-b (> b 0))",
          "        (pos-c (> c 0))",
          "        (asc-ab (< a b))",
          "        (asc-bc (< b c)))",
          "    (and pos-a pos-b pos-c asc-ab asc-bc))",
          ")",
          "(positive-and-ascending? 2 3 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let positive_and_ascending a b c =",
          "  let pos_a = a > 0 in",
          "  let pos_b = b > 0 in",
          "  let pos_c = c > 0 in",
          "  let asc_ab = a < b in",
          "  let asc_bc = b < c in",
          "  pos_a && pos_b && pos_c && asc_ab && asc_bc",
          "in",
          "positive_and_ascending 2 3 4"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `positive-and-ascending?` que toma tres parámetros, `a`, `b`, `c`, como presiones (2, 3, 4 kPa). Imagina que eres un científico verificando si todas son positivas y en orden ascendente. En Racket, `(define (nombre params) cuerpo)` es como una receta para esta validación compleja.",
        "Aquí comenzamos un bloque `let` y definimos `pos-a` como `> a 0`, verificando si `a` es positivo. Es como anotar si la primera presión es válida.",
        "Esta línea define `pos-b` como `> b 0`, verificando si `b` es positivo. Es como chequear la segunda presión.",
        "Esta línea define `pos-c` como `> c 0`, verificando si `c` es positivo. Es como confirmar la tercera presión.",
        "Esta línea define `asc-ab` como `(< a b)`, verificando si `a` es menor que `b`. Es como anotar si la primera presión es menor que la segunda.",
        "Esta línea define `asc-bc` como `(< b c)`, verificando si `b` es menor que `c`. Es como confirmar el orden ascendente.",
        "Aquí combinamos todas las condiciones con `and`, retornando `true` si todas son ciertas. Es como revisar la libreta para confirmar positividad y orden.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 2, 3, 4, verificando `2 > 0`, `3 > 0`, `4 > 0`, `2 < 3`, `3 < 4`, dando `true`. Es como probar la receta."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `positive_and_ascending` que toma `a`, `b`, `c`, como presiones. En OCaml, `let nombre params = cuerpo` es como una receta para verificar positividad y orden. La función está lista para tres números.",
        "Aquí definimos `pos_a` como `a > 0`, verificando si `a` es positivo. Es como anotar si la primera presión es válida. El `in` indica que usaremos este valor.",
        "Esta línea define `pos_b` como `b > 0`, verificando la segunda presión.",
        "Esta línea define `pos_c` como `c > 0`, verificando la tercera presión.",
        "Esta línea define `asc_ab` como `a < b`, verificando el orden entre la primera y segunda presión.",
        "Esta línea define `asc_bc` como `b < c`, verificando el orden entre la segunda y tercera presión.",
        "Aquí combinamos todas las condiciones con `&&`, retornando `true` si todas son ciertas. Es como revisar todas las anotaciones.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 2, 3, 4, verificando todas las condiciones, dando `true`. Es como confirmar la validez y orden de las presiones."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que verifica positividad y orden ascendente, con el mismo propósito y resultado (`true`). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis y `positive-and-ascending?` (con ? para booleano), mientras que OCaml usa `let nombre params = cuerpo` y `positive_and_ascending`.",
        "Similitudes: Ambas verifican si `a` es positivo. Diferencias: Racket usa `(let ((pos-a (> a 0)))` con paréntesis, OCaml usa `let pos_a = a > 0 in` con notación infija y `in`.",
        "Similitudes: Ambas verifican si `b` es positivo. Diferencias: Racket incluye `pos-b` en el mismo `let`, OCaml usa una línea separada `let pos_b = b > 0 in`.",
        "Similitudes: Ambas verifican si `c` es positivo. Diferencias: Racket usa el mismo `let`, OCaml usa `let pos_c = c > 0 in`.",
        "Similitudes: Ambas verifican si `a < b`. Diferencias: Racket usa `(< a b)`, OCaml usa `a < b` con `in`.",
        "Similitudes: Ambas verifican si `b < c`. Diferencias: Racket usa `(< b c)`, OCaml usa `b < c` con `in`.",
        "Similitudes: Ambas combinan condiciones con un operador lógico (`and` en Racket, `&&` en OCaml). Diferencias: Racket usa `(and ...)` con paréntesis, OCaml usa `&&` con notación infija.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 2, 3, 4, dando `true`. Diferencias: Racket usa `(positive-and-ascending? 2 3 4)` con paréntesis, OCaml usa `positive_and_ascending 2 3 4`."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular el Volumen Útil de una Caja con Márgenes",
      "racket": {
        "lines": [
          "(define (useful-cuboid-volume l w h margin)",
          "  (let ((adj-l (- l (* 2 margin)))",
          "        (adj-w (- w (* 2 margin)))",
          "        (adj-h (- h (* 2 margin)))",
          "        (lw (* adj-l adj-w))",
          "        (volume (* lw adj-h)))",
          "    volume)",
          ")",
          "(useful-cuboid-volume 3 2 4 0.1)"
        ]
      },
      "ocaml": {
        "lines": [
          "let useful_cuboid_volume l w h margin =",
          "  let adj_l = l -. (2.0 *. margin) in",
          "  let adj_w = w -. (2.0 *. margin) in",
          "  let adj_h = h -. (2.0 *. margin) in",
          "  let lw = adj_l *. adj_w in",
          "  let volume = lw *. adj_h in",
          "  volume",
          "in",
          "useful_cuboid_volume 3.0 2.0 4.0 0.1"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `useful-cuboid-volume` que toma cuatro parámetros, `l`, `w`, `h`, `margin`, como dimensiones de una caja (3, 2, 4 metros) y un margen (0.1 metros). Imagina que eres una empresa calculando el volumen útil de una caja, descontando márgenes en cada lado. En Racket, `(define (nombre params) cuerpo)` es como una receta compleja.",
        "Aquí comenzamos un bloque `let` y definimos `adj-l` como `(- l (* 2 margin))`, restando el doble del margen al largo. Es como anotar el largo útil después de descontar espacio en ambos lados.",
        "Esta línea define `adj-w` como `(- w (* 2 margin))`, ajustando el ancho. Es como calcular el ancho útil.",
        "Esta línea define `adj-h` como `(- h (* 2 margin))`, ajustando la altura. Es como obtener la altura útil.",
        "Esta línea define `lw` como `(* adj-l adj-w)`, multiplicando largo y ancho ajustados. Es como calcular el área útil de la base.",
        "Esta línea define `volume` como `(* lw adj-h)`, multiplicando el área por la altura ajustada. Es como obtener el volumen útil final.",
        "Aquí retornamos `volume`, el resultado final. Es como entregar el volumen útil de la caja.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 3, 2, 4, 0.1, dando `(3-2*0.1) * (2-2*0.1) * (4-2*0.1) = 2.8 * 1.8 * 3.8 = 19.008`. Es como probar la receta."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `useful_cuboid_volume` que toma `l`, `w`, `h`, `margin`, como dimensiones y un margen. En OCaml, `let nombre params = cuerpo` es como una receta para calcular el volumen útil. La función está lista para cuatro números.",
        "Aquí definimos `adj_l` como `l -. (2.0 *. margin)`, restando el doble del margen al largo. Es como anotar el largo útil. El `-.` y `*.` son para decimales.",
        "Esta línea define `adj_w` como `w -. (2.0 *. margin)`, ajustando el ancho útil.",
        "Esta línea define `adj_h` como `h -. (2.0 *. margin)`, ajustando la altura útil.",
        "Esta línea define `lw` como `adj_l *. adj_w`, calculando el área útil de la base.",
        "Esta línea define `volume` como `lw *. adj_h`, calculando el volumen útil final.",
        "Aquí retornamos `volume`, el resultado final.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 3.0, 2.0, 4.0, 0.1, dando `2.8 * 1.8 * 3.8 = 19.008`. Es como confirmar el volumen útil."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el volumen útil de una caja con cuatro parámetros, con el mismo propósito y resultado (19.008). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales, Racket acepta enteros.",
        "Similitudes: Ambas ajustan el largo restando el doble del margen. Diferencias: Racket usa `(- l (* 2 margin))` con paréntesis, OCaml usa `l -. (2.0 *. margin)` con notación infija y operadores `-.`, `*.`.",
        "Similitudes: Ambas ajustan el ancho. Diferencias: Racket incluye `adj-w` en el mismo `let`, OCaml usa `let adj_w = ... in`.",
        "Similitudes: Ambas ajustan la altura. Diferencias: Racket usa el mismo `let`, OCaml usa una línea separada.",
        "Similitudes: Ambas calculan el área de la base. Diferencias: Racket usa `(* adj-l adj-w)`, OCaml usa `adj_l *. adj_w` con `*.`.",
        "Similitudes: Ambas calculan el volumen final. Diferencias: Racket usa `(* lw adj-h)`, OCaml usa `lw *. adj_h`.",
        "Similitudes: Ambas retornan el volumen. Diferencias: Racket usa `volume` en el `let`, OCaml lo retorna directamente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 3, 2, 4, 0.1, dando 19.008. Diferencias: Racket usa `(useful-cuboid-volume 3 2 4 0.1)` con paréntesis, OCaml usa `useful_cuboid_volume 3.0 2.0 4.0 0.1`."
      ]
    }
  },
  "condicionales": {
    "ejercicio-1": {
      "title": "Máximo de dos números",
      "racket": {
        "lines": [
          "(define (max-two a b)",
          "  (if (> a b)",
          "      a",
          "      b",
          "  )",
          ")",
          "(max-two 10 7)"
        ]
      },
      "ocaml": {
        "lines": [
          "let max_two a b =",
          "  if a > b then",
          "    a",
          "  else",
          "    b",
          "in",
          "max_two 10 7"
        ]
      },
      "explanations_racket": [
        "Define una función `max-two` que toma dos parámetros (`a`, `b`) para encontrar el mayor. La sintaxis `(define (nombre params) cuerpo)` es funcional, como elegir el mayor de dos ofertas en una subasta.",
        "Inicia un condicional `if` que evalúa si `a > b` usando `>` en notación prefija. Es una expresión pura, como decidir cuál de dos precios es más alto.",
        "Si `a > b` es verdadero, retorna `a`, seleccionando el mayor valor, como elegir la oferta más alta.",
        "Si `a > b` es falso, retorna `b`, formando la rama 'else' del condicional.",
        "Cierra el bloque `if`, asegurando que la función retorne un valor puro.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `max-two` con 10 y 7, retornando 10 porque `10 > 7`, mostrando la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `max_two` con dos parámetros para encontrar el mayor, usando `let nombre params = cuerpo`. Es una abstracción funcional, como seleccionar la mayor puja en un mercado.",
        "Inicia un condicional `if` con `a > b` en notación infija, evaluando cuál es mayor. Es una expresión pura, como comparar dos cantidades.",
        "Si `a > b`, retorna `a`, seleccionando el mayor valor, como elegir el mejor precio.",
        "Introduce la rama `else`, necesaria en OCaml para garantizar un valor en todos los casos, retornando `b` si `a` no es mayor.",
        "Cierra la rama `else` con `b`, completando el condicional con un valor puro.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `max_two` con 10 y 7, retornando 10 porque `10 > 7`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para encontrar el máximo de dos números, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, reflejando su herencia Lisp, mientras que OCaml usa `let nombre params = cuerpo`, más conciso. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas evalúan `a > b` con pureza funcional. Diferencias: Racket usa `>` en notación prefija, más explícita, mientras que OCaml usa infija, más matemática y concisa.",
        "Similitudes: Ambas retornan `a` si es mayor, con pureza. Diferencias: Racket integra la rama 'then' en el `if`, mientras que OCaml usa `then` explícitamente, requiriendo una estructura más verbal.",
        "Similitudes: Ambas retornan `b` si `a` no es mayor, con pureza. Diferencias: Racket incluye el caso falso en el `if`, mientras que OCaml usa `else` explícitamente, requiriendo una línea adicional.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if` con un paréntesis, OCaml cierra la rama `else` con `b`, aumentando el número de líneas en OCaml.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 10 y 7, retornando 10. Diferencias: Racket usa `(max-two 10 7)` con paréntesis, OCaml usa `max_two 10 7`, más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Clasificar número positivo, negativo o cero",
      "racket": {
        "lines": [
          "(define (classify-number x)",
          "  (cond",
          "    [(> x 0) 'positive]",
          "    [(< x 0) 'negative]",
          "    [else 'zero]",
          "  )",
          ")",
          "(classify-number 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let classify_number x =",
          "  if x > 0 then",
          "    \"positive\"",
          "  else if x < 0 then",
          "    \"negative\"",
          "  else",
          "    \"zero\"",
          "in",
          "classify_number 3"
        ]
      },
      "explanations_racket": [
        "Define una función `classify-number` que toma un parámetro `x` para clasificar un número como positivo, negativo o cero. La sintaxis `(define (nombre params) cuerpo)` es funcional, como etiquetar una temperatura según su valor.",
        "Inicia un condicional `cond`, que permite múltiples ramas en Racket. Es una expresión pura que evalúa condiciones secuencialmente, ideal para clasificaciones complejas.",
        "Evalúa si `x > 0`, retornando el símbolo `'positive` si es verdadero, como etiquetar una temperatura positiva.",
        "Evalúa si `x < 0`, retornando `'negative`, para el caso negativo, manteniendo pureza.",
        "Si ninguna condición previa es verdadera, retorna `'zero` con la rama `else`, como clasificar un valor neutro.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `classify-number` con 3, retornando `'positive` porque `3 > 0`, mostrando la clasificación."
      ],
      "explanations_ocaml": [
        "Define una función `classify_number` con un parámetro `x` para clasificar un número, usando `let nombre params = cuerpo`. Es una abstracción funcional, como categorizar un nivel de batería.",
        "Inicia un condicional `if` con `x > 0` en notación infija, evaluando la primera condición con pureza funcional.",
        "Si `x > 0`, retorna la cadena `\"positive\"`, como asignar una etiqueta a un valor positivo.",
        "Introduce un `else if` para evaluar `x < 0`, retornando `\"negative\"`, necesario para manejar múltiples condiciones en OCaml.",
        "Introduce la rama `else`, retornando `\"zero\"` si ninguna condición previa es verdadera, necesaria para completar el condicional.",
        "Cierra la rama `else` con `\"zero\"`, asegurando un valor puro en todos los casos.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `classify_number` con 3, retornando `\"positive\"` porque `3 > 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para clasificar un número como positivo, negativo o cero, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa cadenas, Racket usa símbolos.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza funcional. Diferencias: Racket usa `cond` para múltiples ramas, más flexible, mientras que OCaml usa `if` con anidamiento `else if`, más explícito.",
        "Similitudes: Ambas retornan un valor para el caso positivo. Diferencias: Racket usa el símbolo `'positive`, OCaml usa la cadena `\"positive\"` con `then`.",
        "Similitudes: Ambas manejan el caso negativo. Diferencias: Racket usa una rama de `cond` con `'negative`, más concisa, mientras que OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas manejan el caso cero. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `\"zero\"`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 3, retornando 'positive'. Diferencias: Racket usa `(classify-number 3)` con un símbolo, OCaml usa `classify_number 3` con una cadena."
      ]
    },
    "ejercicio-3": {
      "title": "Año bisiesto",
      "racket": {
        "lines": [
          "(define (leap-year? year)",
          "  (cond",
          "    [(= (remainder year 400) 0) #t]",
          "    [(= (remainder year 100) 0) #f]",
          "    [(= (remainder year 4) 0) #t]",
          "    [else #f]",
          "  )",
          ")",
          "(leap-year? 2024)"
        ]
      },
      "ocaml": {
        "lines": [
          "let leap_year year =",
          "  if year mod 400 = 0 then",
          "    true",
          "  else if year mod 100 = 0 then",
          "    false",
          "  else if year mod 4 = 0 then",
          "    true",
          "  else",
          "    false",
          "in",
          "leap_year 2024"
        ]
      },
      "explanations_racket": [
        "Define una función `leap-year?` que toma un parámetro `year` para verificar si un año es bisiesto. La sintaxis `(define (nombre params) cuerpo)` es funcional, como decidir si un año necesita un día extra en un calendario.",
        "Inicia un condicional `cond` para evaluar las reglas del año bisiesto, una expresión pura que verifica condiciones en orden.",
        "Evalúa si `year` es divisible por 400 usando `(= (remainder year 400) 0)`, retornando `#t` si es verdadero, como 2000.",
        "Evalúa si `year` es divisible por 100, retornando `#f`, como 1900, donde no se añade un día extra.",
        "Evalúa si `year` es divisible por 4, retornando `#t`, como 2024, un año bisiesto típico.",
        "Si ninguna condición es verdadera, retorna `#f` con `else`, para años no bisiestos.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `leap-year?` con 2024, retornando `#t` porque `2024 mod 4 = 0` y no es divisible por 100, mostrando que es bisiesto."
      ],
      "explanations_ocaml": [
        "Define una función `leap_year` con un parámetro `year` para verificar si es bisiesto, usando `let nombre params = cuerpo`. Es una abstracción funcional, como programar un calendario.",
        "Inicia un condicional `if` con `year mod 400 = 0` en notación infija, evaluando la primera regla del año bisiesto con pureza.",
        "Si `year mod 400 = 0`, retorna `true`, para años como 2000.",
        "Introduce un `else if` para `year mod 100 = 0`, retornando `false`, para años como 1900.",
        "Introduce otro `else if` para `year mod 4 = 0`, retornando `true`, para años como 2024.",
        "Introduce la rama `else`, retornando `false` para años no bisiestos, necesaria para completar el condicional.",
        "Cierra la rama `else` con `false`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `leap_year` con 2024, retornando `true` porque `2024 mod 4 = 0` y no es divisible por 100, demostrando que es bisiesto."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si un año es bisiesto, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas inician un condicional para evaluar reglas, con pureza. Diferencias: Racket usa `cond`, más flexible, mientras que OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas verifican divisibilidad por 400, retornando verdadero. Diferencias: Racket usa `(remainder year 400)` en notación prefija, OCaml usa `mod 400` infijo, más matemático.",
        "Similitudes: Ambas verifican divisibilidad por 100, retornando falso. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas verifican divisibilidad por 4, retornando verdadero. Diferencias: Racket usa una rama de `cond`, OCaml usa otro `else if`.",
        "Similitudes: Ambas manejan el caso no bisiesto. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `false`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 2024, retornando verdadero. Diferencias: Racket usa `(leap-year? 2024)`, OCaml usa `leap_year 2024`, más simple."
      ]
    },
    "ejercicio-4": {
      "title": "Signo de un número",
      "racket": {
        "lines": [
          "(define (sign x)",
          "  (cond",
          "    [(> x 0) 1]",
          "    [(< x 0) -1]",
          "    [else 0]",
          "  )",
          ")",
          "(sign -2)"
        ]
      },
      "ocaml": {
        "lines": [
          "let sign x =",
          "  if x > 0 then",
          "    1",
          "  else if x < 0 then",
          "    -1",
          "  else",
          "    0",
          "in",
          "sign (-2)"
        ]
      },
      "explanations_racket": [
        "Define una función `sign` que toma un parámetro `x` para determinar su signo (1, -1, 0). La sintaxis `(define (nombre params) cuerpo)` es funcional, como etiquetar el cambio en una reseña.",
        "Inicia un condicional `cond` para evaluar múltiples casos, una expresión pura que clasifica según condiciones.",
        "Evalúa si `x > 0`, retornando `1`, como indicar un cambio positivo en una puntuación.",
        "Evalúa si `x < 0`, retornando `-1`, para valores negativos, manteniendo pureza.",
        "Si ninguna condición previa es verdadera, retorna `0` con `else`, para el caso neutro.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `sign` con -2, retornando `-1` porque `-2 < 0`, mostrando la función."
      ],
      "explanations_ocaml": [
        "Define una función `sign` con un parámetro `x` para determinar su signo, usando `let nombre params = cuerpo`. Es una abstracción funcional, como clasificar una variación en datos.",
        "Inicia un condicional `if` con `x > 0` en notación infija, evaluando la primera condición con pureza.",
        "Si `x > 0`, retorna `1`, para valores positivos.",
        "Introduce un `else if` para `x < 0`, retornando `-1`, para valores negativos.",
        "Introduce la rama `else`, retornando `0` para el caso neutro, necesaria para completar el condicional.",
        "Cierra la rama `else` con `0`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `sign` con -2, retornando `-1` porque `-2 < 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para determinar el signo de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza. Diferencias: Racket usa `cond`, más flexible, OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas retornan `1` para el caso positivo. Diferencias: Racket usa una rama de `cond`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas retornan `-1` para el caso negativo. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas retornan `0` para el caso neutro. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `0`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con -2, retornando `-1`. Diferencias: Racket usa `(sign -2)`, OCaml usa `sign (-2)` con paréntesis para el negativo."
      ]
    },
    "ejercicio-5": {
      "title": "Sistema de calificación con subniveles (+ y -)",
      "racket": {
        "lines": [
          "(define (grade score)",
          "  (let ((rounded (round score)))",
          "    (cond",
          "      [(>= rounded 90)",
          "       (if (>= rounded 95)",
          "           'A+",
          "           'A-)]",
          "      [(>= rounded 80)",
          "       (if (>= rounded 85)",
          "           'B+",
          "           'B-)]",
          "      [(>= rounded 70)",
          "       (if (>= rounded 75)",
          "           'C+",
          "           'C-)]",
          "      [(>= rounded 60)",
          "       (if (>= rounded 65)",
          "           'D+",
          "           'D-)]",
          "      [else 'F]",
          "    )",
          "  )",
          ")",
          "(grade 92.3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let grade score =",
          "  let rounded = int_of_float (Float.round score) in",
          "  if rounded >= 90 then",
          "    if rounded >= 95 then \"A+\" else \"A-\"",
          "  else if rounded >= 80 then",
          "    if rounded >= 85 then \"B+\" else \"B-\"",
          "  else if rounded >= 70 then",
          "    if rounded >= 75 then \"C+\" else \"C-\"",
          "  else if rounded >= 60 then",
          "    if rounded >= 65 then \"D+\" else \"D-\"",
          "  else",
          "    \"F\"",
          "in",
          "grade 92.3"
        ]
      },
      "explanations_racket": [
        "Define una función `grade` que recibe una nota `score`. Esta función decidirá qué letra corresponde según la calificación numérica.",
        "Dentro de la función, se usa `let` para crear una variable local llamada `rounded` que guarda el valor redondeado de `score` (por ejemplo, 92.3 se convierte en 92).",
        "`cond` inicia un bloque de condiciones que se evalúan una por una. Cada caso representa un rango de calificaciones.",
        "Si la nota es 90 o más (`(>= rounded 90)`), entra en esta condición. Dentro de ella, hay otro `if` que evalúa si la nota es 95 o más.",
        "Si es 95 o más, devuelve `'A+` (nota excelente). Si está entre 90 y 94, devuelve `'A-`, lo que muestra un nivel alto pero no perfecto.",
        "El siguiente bloque evalúa si la nota es al menos 80. Dentro, otro `if` decide entre `'B+` y `'B-`, añadiendo subniveles dentro del rango B.",
        "De igual forma, el siguiente rango (70–79) se evalúa con `if` anidado, devolviendo `'C+` o `'C-`, según esté cerca del 80 o más bajo.",
        "Luego, si la nota está entre 60 y 69, se aplica la misma lógica para `'D+` y `'D-`, diferenciando entre apenas aprobada o más alta.",
        "Si ninguna de las condiciones anteriores se cumple, se ejecuta `else` y devuelve `'F`, que representa una nota reprobatoria.",
        "Finalmente, se llama a `(grade 92.3)`. Como el valor redondeado es 92, devuelve `'A-`."
      ],
      "explanations_ocaml": [
        "Define una función `grade` en OCaml que recibe una nota `score`.",
        "Crea una variable local `rounded` que guarda el número redondeado de `score` (por ejemplo, 92.3 se convierte en 92).",
        "El condicional principal empieza: si `rounded >= 90`, entonces entra al primer bloque.",
        "Dentro de ese bloque, hay un `if` anidado: si la nota es 95 o más, devuelve \"A+\"; si no, devuelve \"A-\".",
        "Si no cumple el rango anterior, pasa al siguiente bloque `else if rounded >= 80`. Allí se repite la estructura con `if` anidado para decidir entre \"B+\" o \"B-\".",
        "Cada bloque siguiente (70 y 60) repite la misma idea: un rango principal con una decisión interna, agregando detalle y precisión al resultado.",
        "Si la nota es menor a 60, entra al `else` final que devuelve \"F\", indicando reprobación.",
        "El `in` introduce la llamada final a la función.",
        "Se llama a `grade 92.3`. El valor 92 no alcanza 95, por lo que devuelve \"A-\"."
      ],
      "comparisons": [
        "Ambas definen funciones para clasificar calificaciones, pero Racket usa `cond` y símbolos (`'A-`), mientras OCaml usa `if` y cadenas (\"A-\").",
        "Ambas crean una variable local: `let` en OCaml y `(let ...)` en Racket, aunque con sintaxis distinta.",
        "Ambas usan estructuras anidadas (`if` dentro de `cond` o `if` dentro de `if`) para refinar los resultados.",
        "OCaml agrupa los `if` con `else if`, mientras Racket los separa con `cond` y paréntesis, lo que hace más clara la jerarquía de decisiones.",
        "Ambas llamadas finales evalúan con 92.3 y devuelven una nota alta pero no perfecta: `'A-` o \"A-\"."
      ]
    },
    "ejercicio-6": {
      "title": "Activar alarma con condiciones anidadas",
      "racket": {
        "lines": [
          "(define (activate-alarm? x)",
          "  (if (and (= (remainder x 2) 0)",
          "           (= (remainder x 3) 0))",
          "      #t",
          "      (if (or (= (remainder (round (sqrt x)) 5) 0)",
          "              (= (remainder (round (sqrt x)) 7) 0))",
          "          #t",
          "          #f)))",
          "(activate-alarm? 12)"
        ]
      },
      "ocaml": {
        "lines": [
          "let activate_alarm x =",
          "  if x mod 2 = 0 && x mod 3 = 0 then",
          "    true",
          "  else if ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 5 = 0)",
          "       || ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 7 = 0) then",
          "    true",
          "  else",
          "    false",
          "in",
          "activate_alarm 12"
        ]
      },
      "explanations_racket": [
        "Define una función `activate-alarm?` que recibe un número `x` y determina si debe activarse una alarma según ciertas reglas matemáticas.",
        "El primer `if` comprueba si el número es divisible por 2 y por 3. Si ambas condiciones son ciertas, retorna `#t` (verdadero).",
        "Si no es divisible por ambos, entra al segundo `if` anidado.",
        "Dentro del segundo `if`, se calcula la raíz cuadrada de `x`, se redondea, y se verifica si ese número es divisible por 5 o por 7.",
        "Si se cumple alguna de esas dos condiciones, retorna `#t`, indicando que la alarma también se activa en esos casos especiales.",
        "Si ninguna de las condiciones anteriores se cumple, retorna `#f` (falso), lo que significa que la alarma no se activa.",
        "Finalmente, al ejecutar `(activate-alarm? 12)`, el resultado es `#t`, porque 12 es divisible tanto por 2 como por 3."
      ],
      "explanations_ocaml": [
        "Define una función `activate_alarm` que recibe un número `x` y devuelve `true` o `false` según ciertas condiciones.",
        "Primero verifica si `x` es divisible por 2 y por 3 usando `mod` y el operador lógico `&&`. Si ambas condiciones son ciertas, devuelve `true`.",
        "Si no se cumple la primera parte, evalúa el `else if` anidado.",
        "En este segundo caso, convierte `x` a número decimal (`float_of_int x`), calcula su raíz cuadrada, la redondea, la vuelve a entero y verifica si ese número es divisible por 5 o por 7.",
        "Si alguna de esas condiciones se cumple (`||`), devuelve `true`.",
        "Si ninguna se cumple, llega al `else` final que devuelve `false`.",
        "Finalmente, `activate_alarm 12` devuelve `true`, porque cumple la primera condición (divisible por 2 y 3)."
      ],
      "comparisons": [
        "Ambas funciones evalúan condiciones numéricas anidadas: primero divisibilidad directa, luego divisibilidad del valor derivado de la raíz cuadrada.",
        "Racket usa `and` y `or` con notación prefija, OCaml usa `&&` y `||` en notación infija, pero la lógica es la misma.",
        "Ambas devuelven valores booleanos: `#t` / `#f` en Racket y `true` / `false` en OCaml.",
        "El flujo condicional es idéntico: una verificación principal seguida de una secundaria más compleja.",
        "Ambas devuelven verdadero con el número 12."
      ]
    },
    "ejercicio-7": {
      "title": "Clasificación geométrica con validación y tamaño",
      "racket": {
        "lines": [
          "(define (triangle-type a b c)",
          "  (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))",
          "      (cond",
          "        [(and (= a b) (= b c))",
          "         (if (< a 5)",
          "             'small-equilateral",
          "             'equilateral)]",
          "        [(or (= a b) (= b c) (= a c))",
          "         (if (< a 5)",
          "             'small-isosceles",
          "             'isosceles)]",
          "        [else",
          "         (if (< a 5)",
          "             'small-scalene",
          "             'scalene)])",
          "      'invalid))",
          "(triangle-type 3 3 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let triangle_type a b c =",
          "  if a + b > c && a + c > b && b + c > a then",
          "    if a = b && b = c then",
          "      if a < 5 then \"small-equilateral\" else \"equilateral\"",
          "    else if a = b || b = c || a = c then",
          "      if a < 5 then \"small-isosceles\" else \"isosceles\"",
          "    else",
          "      if a < 5 then \"small-scalene\" else \"scalene\"",
          "  else",
          "    \"invalid\"",
          "in",
          "triangle_type 3 3 3"
        ]
      },
      "explanations_racket": [
        "Define una función `triangle-type` que recibe tres lados (`a`, `b`, `c`) y determina qué tipo de triángulo forman.",
        "Primero evalúa si los tres lados pueden formar un triángulo. Esto se hace comprobando que la suma de dos lados sea siempre mayor que el tercero.",
        "Si la figura es válida, entra a un `cond` para clasificar su tipo.",
        "Si los tres lados son iguales (`(and (= a b) (= b c))`), entra en el primer bloque.",
        "Dentro de este bloque hay un `if` anidado que evalúa si los lados son menores que 5. Si lo son, devuelve `'small-equilateral`, indicando un triángulo equilátero pequeño; si no, `'equilateral`.",
        "Si no todos los lados son iguales, pasa al siguiente caso que usa `or` para verificar si al menos dos lados son iguales, es decir, si es isósceles.",
        "Dentro de este caso también hay un `if` anidado para determinar si el triángulo isósceles es pequeño (`'small-isosceles`) o normal (`'isosceles`).",
        "El último caso del `cond` corresponde al triángulo escaleno (todos los lados distintos). También anida un `if` para distinguir si es pequeño o normal.",
        "Si los lados no forman un triángulo válido, la función devuelve `'invalid`.",
        "Finalmente, al ejecutar `(triangle-type 3 3 3)`, devuelve `'small-equilateral` porque todos los lados son iguales y menores que 5."
      ],
      "explanations_ocaml": [
        "Define una función `triangle_type` con tres parámetros (`a`, `b`, `c`). Esta función clasifica un triángulo según sus lados.",
        "Primero verifica si los tres lados cumplen la regla del triángulo: la suma de dos debe ser mayor que el tercero.",
        "Si se cumple, entra al bloque principal donde se analizan los tipos.",
        "Si los tres lados son iguales (`a = b && b = c`), entra al primer bloque.",
        "Dentro, hay un `if` anidado que evalúa si `a < 5`. Si lo es, devuelve \"small-equilateral\"; si no, devuelve \"equilateral\".",
        "Si no es equilátero, evalúa el siguiente `else if` que comprueba si al menos dos lados son iguales (isósceles).",
        "Allí también hay un `if` anidado que devuelve \"small-isosceles\" o \"isosceles\" según el tamaño.",
        "Si ninguno de los anteriores se cumple, es escaleno, y otro `if` anidado determina si es pequeño o no.",
        "Si no cumple la regla del triángulo, devuelve \"invalid\".",
        "Al ejecutar `triangle_type 3 3 3`, devuelve \"small-equilateral\" porque todos los lados son iguales y menores que 5."
      ],
      "comparisons": [
        "Ambas funciones comienzan validando si los lados forman un triángulo real antes de clasificarlo.",
        "Ambas usan estructuras anidadas (`if` dentro de `cond` en Racket, `if` dentro de `if` en OCaml) para combinar lógica de forma y tamaño.",
        "Racket usa símbolos (`'small-equilateral`), OCaml usa cadenas (\"small-equilateral\"), pero los significados son equivalentes.",
        "La validación geométrica (a+b>c, etc.) es igual en ambas versiones, solo cambia la sintaxis.",
        "Ambas devuelven la misma clasificación final con los valores dados."
      ]
    }
  },
  "recursion": {
    "ejercicio-1": {
      "title": "Suma de los primeros n números",
      "racket": {
        "lines": [
          "(define (sum-n n)",
          "  (if (<= n 0)",
          "      0",
          "      (+ n (sum-n (- n 1))))",
          ")",
          "(sum-n 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [4, 3, 2, 1]
      },
      "ocaml": {
        "lines": [
          "let rec sum_n n =",
          "  if n <= 0 then",
          "    0",
          "  else",
          "    n + sum_n (n - 1)",
          "in",
          "sum_n 4"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [4, 3, 2, 1]
      },
      "explanations_racket": [
        "Define una función recursiva `sum-n` que suma los números de 1 a `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como sumar las ventas diarias de un comerciante hasta el día n.",
        "Inicia un condicional `if` que verifica si `n <= 0` con notación prefija `(<= n 0)`, una expresión pura para el caso base, como decidir cuándo detener la suma.",
        "Si `n <= 0`, retorna 0, el caso base, indicando que no hay ventas si no hay días.",
        "Si `n > 0`, suma `n` con `sum-n` de `n - 1` usando `(+ n (sum-n (- n 1)))`, una recursión pura, como sumar la venta actual con las anteriores.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `sum-n` con 4, calculando 4 + 3 + 2 + 1 = 10, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_n` para sumar de 1 a `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, ideal para cálculos funcionales, como sumar ingresos diarios.",
        "Inicia un condicional `if` con `n <= 0` en notación infija, una expresión pura para el caso base.",
        "Si `n <= 0`, retorna 0, como no sumar nada si no hay días.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma `n` con `sum_n (n - 1)` usando notación infija `n + sum_n (n - 1)`, una recursión pura, como sumar el día actual con los anteriores.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_n` con 4, calculando 4 + 3 + 2 + 1 = 10, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar de 1 a n, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito para recursión. OCaml infiere que `n` es entero, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 0` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 0)`, OCaml usa infija `n <= 0`, más matemática.",
        "Similitudes: Ambas retornan 0 como caso base, esencial para detener la recursión. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo sumando `n`. Diferencias: Racket usa `(+ n ...)` en una línea, OCaml separa `else` y la recursión, requiriendo más líneas por estructura.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 4, retornando 10. Diferencias: Racket usa `(sum-n 4)` con paréntesis, OCaml usa `sum_n 4`, más conciso en la invocación."
      ]
    },
    "ejercicio-2": {
      "title": "Potencia de un número",
      "racket": {
        "lines": [
          "(define (power base exp)",
          "  (if (= exp 0)",
          "      1",
          "      (* base (power base (- exp 1))))",
          ")",
          "(power 2 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [2, 4, 8, 16]
      },
      "ocaml": {
        "lines": [
          "let rec power base exp =",
          "  if exp = 0 then",
          "    1",
          "  else",
          "    base * power base (exp - 1)",
          "in",
          "power 2 4"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [2, 4, 8, 16]
      },
      "explanations_racket": [
        "Define una función recursiva `power` para calcular `base` elevado a `exp`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el crecimiento de una inversión que se duplica repetidamente.",
        "Inicia un condicional `if` con `(= exp 0)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `exp = 0`, retorna 1, el caso base (base^0 = 1), como una inversión sin crecimiento.",
        "Si `exp ≠ 0`, multiplica `base` por `power` de `exp - 1` usando `(* base (power base (- exp 1)))`, una recursión pura, como calcular 2^4 = 2 * 2^3.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `power` con 2 y 4, calculando 2^4 = 16, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `power` para calcular `base` elevado a `exp`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un crecimiento exponencial.",
        "Inicia un condicional `if` con `exp = 0` en notación infija, verificando el caso base con pureza.",
        "Si `exp = 0`, retorna 1, el caso base, como un cálculo sin multiplicaciones.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica `base` por `power base (exp - 1)` en notación infija, una recursión pura, como calcular 2^4 = 2 * 2^3.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `power` con 2 y 4, calculando 2^4 = 16, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular potencias, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito.",
        "Similitudes: Ambas verifican `exp = 0` con pureza funcional. Diferencias: Racket usa notación prefija `(= exp 0)`, OCaml usa infija `exp = 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo multiplicando `base`. Diferencias: Racket usa `(* base ...)` en notación prefija, OCaml usa `base * ...` infija, más concisa y matemática.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 2 y 4, retornando 16. Diferencias: Racket usa `(power 2 4)` con paréntesis, OCaml usa `power 2 4`, más simple."
      ]
    },
    "ejercicio-3": {
      "title": "Factorial de un número",
      "racket": {
        "lines": [
          "(define (factorial n)",
          "  (if (<= n 1)",
          "      1",
          "      (* n (factorial (- n 1))))",
          ")",
          "(factorial 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [1, 2, 6, 24]
      },
      "ocaml": {
        "lines": [
          "let rec factorial n =",
          "  if n <= 1 then",
          "    1",
          "  else",
          "    n * factorial (n - 1)",
          "in",
          "factorial 4"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 2, 6, 24]
      },
      "explanations_racket": [
        "Define una función recursiva `factorial` que calcula n!. La sintaxis `(define (nombre params) cuerpo)` es funcional, como contar las formas de organizar n cajas en un almacén.",
        "Inicia un condicional `if` con `(<= n 1)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 1`, retorna 1, el caso base (0! = 1, 1! = 1), como definir una sola forma de organizar una caja o ninguna.",
        "Si `n > 1`, multiplica `n` por `factorial` de `n - 1` usando `(* n (factorial (- n 1)))`, una recursión pura, como calcular 4! = 4 * 3!.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `factorial` con 4, calculando 4! = 4 * 3 * 2 * 1 = 24, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `factorial` para calcular n!, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como calcular combinaciones de objetos.",
        "Inicia un condicional `if` con `n <= 1` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 1`, retorna 1, el caso base, como una sola configuración para una caja o ninguna.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica `n` por `factorial (n - 1)` en notación infija, una recursión pura, como calcular 4! = 4 * 3!.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `factorial` con 4, calculando 4! = 24, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular el factorial, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere que `n` es entero, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 1` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 1)`, OCaml usa infija `n <= 1`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo multiplicando `n`. Diferencias: Racket usa `(* n ...)` en notación prefija, OCaml usa `n * ...` infija, requiriendo una línea extra para `else`.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 4, retornando 24. Diferencias: Racket usa `(factorial 4)` con paréntesis, OCaml usa `factorial 4`, más conciso."
      ]
    },
    "ejercicio-4": {
      "title": "Fibonacci en la posición n",
      "racket": {
        "lines": [
          "(define (fibonacci n)",
          "  (if (<= n 1)",
          "      n",
          "      (+ (fibonacci (- n 1))",
          "         (fibonacci (- n 2)))",
          "  )",
          ")",
          "(fibonacci 6)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [0, 1, 1, 2, 3, 5, 8]
      },
      "ocaml": {
        "lines": [
          "let rec fibonacci n =",
          "  if n <= 1 then",
          "    n",
          "  else",
          "    fibonacci (n - 1) +",
          "    fibonacci (n - 2)",
          "in",
          "fibonacci 6"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 5, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 5, 0, 1, 2],
        "recursion-step-answer": [0, 1, 1, 2, 3, 5, 8]
      },
      "explanations_racket": [
        "Define una función recursiva `fibonacci` para calcular el número de Fibonacci en la posición `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como modelar el crecimiento de una población de conejos en un ecosistema.",
        "Inicia un condicional `if` con `(<= n 1)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 1`, retorna `n` (Fib(0) = 0, Fib(1) = 1), el caso base, como definir los primeros pasos de la población.",
        "Si `n > 1`, suma `fibonacci` de `n - 1` y `n - 2` usando notación prefija, iniciando una recursión doble, como sumar generaciones previas de conejos.",
        "Completa la recursión con `(+ (fibonacci (- n 1)) (fibonacci (- n 2)))`, una expresión pura que descompone el problema.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `fibonacci` con 6, calculando Fib(6) = 8, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `fibonacci` para calcular Fib(n), usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un patrón biológico de crecimiento.",
        "Inicia un condicional `if` con `n <= 1` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 1`, retorna `n` (Fib(0) = 0, Fib(1) = 1), como establecer los primeros valores de una secuencia.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma `fibonacci (n - 1)` y `fibonacci (n - 2)` en notación infija, una recursión doble pura, como combinar generaciones previas.",
        "Completa la suma recursiva, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `fibonacci` con 6, calculando Fib(6) = 8, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular Fibonacci, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 1` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 1)`, OCaml usa infija `n <= 1`, más matemática.",
        "Similitudes: Ambas retornan `n` como caso base (0 o 1). Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión doble para `n > 1`. Diferencias: Racket divide la suma en dos líneas por formato prefijo, OCaml usa `else` para iniciar la recursión.",
        "Similitudes: Ambas completan la recursión sumando dos llamadas. Diferencias: Racket cierra la suma en una línea separada, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la suma, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 6, retornando 8. Diferencias: Racket usa `(fibonacci 6)` con paréntesis, OCaml usa `fibonacci 6`, más conciso."
      ]
    },
    "ejercicio-5": {
      "title": "Suma de dígitos",
      "racket": {
        "lines": [
          "(define (sum-digits n)",
          "  (if (< n 10)",
          "      n",
          "      (+ (remainder n 10)",
          "         (sum-digits (quotient n 10)))",
          "  )",
          ")",
          "(sum-digits 12345)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [5, 4, 3, 2, 1]
      },
      "ocaml": {
        "lines": [
          "let rec sum_digits n =",
          "  if n < 10 then",
          "    n",
          "  else",
          "    (n mod 10) +",
          "    sum_digits (n / 10)",
          "in",
          "sum_digits 12345"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2],
        "recursion-step-answer": [5, 4, 3, 2, 1]
      },
      "explanations_racket": [
        "Define una función recursiva `sum-digits` para sumar los dígitos de `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como sumar los números de un código postal para validarlo.",
        "Inicia un condicional `if` con `(< n 10)`, verificando si `n` es un solo dígito, una expresión pura para el caso base.",
        "Si `n < 10`, retorna `n`, el caso base, como tomar un solo dígito de un código.",
        "Si `n >= 10`, suma el último dígito (`remainder n 10`) con la suma de los dígitos de `n` dividido por 10 (`quotient n 10`), iniciando la recursión, como descomponer 12345 en 5 + 4 + 3 + 2 + 1.",
        "Completa la recursión sumando el resultado de `sum-digits (quotient n 10)`, una expresión pura que reduce el número.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `sum-digits` con 12345, calculando 1 + 2 + 3 + 4 + 5 = 15, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_digits` para sumar los dígitos de `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como validar un número sumando sus partes.",
        "Inicia un condicional `if` con `n < 10` en notación infija, verificando el caso base con pureza.",
        "Si `n < 10`, retorna `n`, el caso base, como un solo dígito en un cálculo.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma el último dígito (`n mod 10`) con `sum_digits (n / 10)` en notación infija, iniciando la recursión pura.",
        "Completa la recursión con la suma, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_digits` con 12345, calculando 1 + 2 + 3 + 4 + 5 = 15, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar los dígitos de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n < 10` con pureza funcional. Diferencias: Racket usa notación prefija `(< n 10)`, OCaml usa infija `n < 10`, más matemática.",
        "Similitudes: Ambas retornan `n` como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión sumando el último dígito. Diferencias: Racket usa `remainder` y `quotient` en notación prefija, OCaml usa `mod` y `/` infijos, más concisos.",
        "Similitudes: Ambas completan la recursión sumando el resto del número. Diferencias: Racket divide la suma en dos líneas por formato prefijo, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la suma, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 12345, retornando 15. Diferencias: Racket usa `(sum-digits 12345)` con paréntesis, OCaml usa `sum_digits 12345`, más conciso."
      ]
    },
    "ejercicio-6": {
      "title": "Producto de los primeros n impares",
      "racket": {
        "lines": [
          "(define (product-odds n)",
          "  (if (<= n 0)",
          "      1",
          "      (* (+ (* 2 n) -1)",
          "         (product-odds (- n 1)))",
          "  )",
          ")",
          "(product-odds 3)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 3, 15]
      },
      "ocaml": {
        "lines": [
          "let rec product_odds n =",
          "  if n <= 0 then",
          "    1",
          "  else",
          "    (2 * n - 1) *",
          "    product_odds (n - 1)",
          "in",
          "product_odds 3"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2],
        "recursion-step-answer": [1, 3, 15]
      },
      "explanations_racket": [
        "Define una función recursiva `product-odds` para calcular el producto de los primeros n números impares (1, 3, 5, ...). La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el producto de valores alternados en un experimento matemático.",
        "Inicia un condicional `if` con `(<= n 0)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 0`, retorna 1, el caso base, como el producto vacío (neutro para la multiplicación).",
        "Si `n > 0`, multiplica el n-ésimo impar `(+ (* 2 n) -1)` por `product-odds` de `n - 1`, iniciando la recursión, como calcular 1 * 3 * 5 para n = 3.",
        "Completa la recursión con la multiplicación, una expresión pura que reduce el problema.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `product-odds` con 3, calculando 1 * 3 * 5 = 15, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `product_odds` para calcular el producto de los primeros n impares, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un cálculo matemático.",
        "Inicia un condicional `if` con `n <= 0` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 0`, retorna 1, el caso base, como un producto vacío.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica el n-ésimo impar `(2 * n - 1)` por `product_odds (n - 1)` en notación infija, iniciando la recursión pura.",
        "Completa la multiplicación recursiva, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `product_odds` con 3, calculando 1 * 3 * 5 = 15, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular el producto de impares, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 0` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 0)`, OCaml usa infija `n <= 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión multiplicando el n-ésimo impar. Diferencias: Racket usa `(+ (* 2 n) -1)` en notación prefija, OCaml usa `(2 * n - 1)` infija, más concisa.",
        "Similitudes: Ambas completan la recursión con la multiplicación. Diferencias: Racket divide la expresión en dos líneas por formato prefijo, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la multiplicación, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 3, retornando 15. Diferencias: Racket usa `(product-odds 3)` con paréntesis, OCaml usa `product_odds 3`, más conciso."
      ]
    },
    "ejercicio-7": {
      "title": "Contar dígitos",
      "racket": {
        "lines": [
          "(define (count-digits n)",
          "  (if (< n 10)",
          "      1",
          "      (+ 1 (count-digits (quotient n 10))))",
          ")",
          "(count-digits 1234)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "ocaml": {
        "lines": [
          "let rec count_digits n =",
          "  if n < 10 then",
          "    1",
          "  else",
          "    1 + count_digits (n / 10)",
          "in",
          "count_digits 1234"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "explanations_racket": [
        "Define una función recursiva `count-digits` para contar los dígitos de `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como validar un número de teléfono contando sus cifras.",
        "Inicia un condicional `if` con `(< n 10)`, verificando si `n` es un solo dígito, una expresión pura para el caso base.",
        "Si `n < 10`, retorna 1, el caso base, como contar una sola cifra en un número.",
        "Si `n >= 10`, suma 1 al conteo de dígitos de `n` dividido por 10 (`quotient n 10`), una recursión pura, como contar cada cifra de 1234.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `count-digits` con 1234, calculando 4 dígitos, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `count_digits` para contar los dígitos de `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como validar un código contando sus partes.",
        "Inicia un condicional `if` con `n < 10` en notación infija, verificando el caso base con pureza.",
        "Si `n < 10`, retorna 1, el caso base, como una sola cifra en un número.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma 1 a `count_digits (n / 10)` en notación infija, una recursión pura para contar los dígitos restantes.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `count_digits` con 1234, calculando 4 dígitos, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para contar los dígitos de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n < 10` con pureza funcional. Diferencias: Racket usa notación prefija `(< n 10)`, OCaml usa infija `n < 10`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo sumando 1. Diferencias: Racket usa `quotient` en notación prefija, OCaml usa `/` infija, más concisa y matemática.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 1234, retornando 4. Diferencias: Racket usa `(count-digits 1234)` con paréntesis, OCaml usa `count_digits 1234`, más conciso."
      ]
    }
  },
  "listas": {
    "ejercicio-1": {
      "title": "Contar Elementos en una Lista de Tareas",
      "racket": {
        "lines": [
          "(define (length lst)",
          "  (if (empty? lst)",
          "      0",
          "      (+ 1 (length (rest lst))))",
          "  )",
          ")",
          "(length '(1 2 3 4))"
        ],
        "recursion": [6, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "ocaml": {
        "lines": [
          "let rec length lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    1 + length (List.tl lst)",
          "in",
          "length [1; 2; 3; 4]"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "explanations_racket": [
        "Define una función `length` que toma una lista `lst`, como las tareas de una organizadora (1 2 3 4). En Racket, `(define (nombre params) cuerpo)` es como escribir una receta para contar cuántas tareas hay.",
        "Inicia un condicional `if` que verifica si la lista está vacía con `(empty? lst)`. Es como preguntar si la organizadora tiene tareas pendientes.",
        "Si la lista está vacía, retorna 0, indicando que no hay tareas. Es el caso base para detener la cuenta.",
        "Si la lista no está vacía, suma 1 al conteo de la lista sin su primer elemento con `(length (rest lst))`. Es como contar una tarea y pasar a las restantes.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket, como cerrar un paso en la receta.",
        "Cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Llama a `length` con la lista `(1 2 3 4)`, contando 4 elementos, como confirmar cuántas tareas tiene la organizadora."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `length` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` indica recursión, como una receta para contar tareas de una organizadora.",
        "Inicia un condicional `if` con `lst = []` para verificar si la lista está vacía. Es como preguntar si no hay tareas.",
        "Si la lista está vacía, retorna 0, el caso base, indicando cero tareas.",
        "Introduce la rama `else`, necesaria en OCaml para el caso no vacío, preparando el conteo.",
        "Suma 1 al conteo de la lista sin su primer elemento con `length (List.tl lst)`, como contar una tarea y continuar con las demás.",
        "Usa `in` para conectar la definición con la llamada, una regla estructural de OCaml.",
        "Llama a `length` con `[1; 2; 3; 4]`, contando 4 elementos, como confirmar el total de tareas."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para contar elementos en una lista, con recursión pura y resultado 4. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo` con `rec` explícito. OCaml usa `;` para listas, Racket usa espacios.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)` con notación prefija, OCaml usa `lst = []` con notación infija, más intuitiva.",
        "Similitudes: Ambas retornan 0 como caso base. Diferencias: Racket lo hace directamente en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas suman 1 al conteo recursivo. Diferencias: Racket usa `(+ 1 (length (rest lst)))` con paréntesis, OCaml usa `1 + length (List.tl lst)` con notación infija y `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `if` con `)`, OCaml usa `in` para la evaluación.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando 4. Diferencias: Racket usa `(length '(1 2 3 4))` con comillas, OCaml usa `length [1; 2; 3; 4]` con corchetes y `;`."
      ]
    },
    "ejercicio-2": {
      "title": "Obtener los Dos Primeros Elementos de una Lista de Tareas",
      "racket": {
        "lines": [
          "(define (first-two-elements lst)",
          "  (let ((len (length lst)))",
          "    (if (< len 1)",
          "        null",
          "        (let ((first-el (first lst))",
          "              (rest-lst (rest lst)))",
          "          (if (empty? rest-lst)",
          "              (list first-el)",
          "              (list first-el (first rest-lst)))))",
          "  )",
          ")",
          "(first-two-elements '(5 6 7 8 9))"
        ],
        "recursion-step-answer": [5, 6]
      },
      "ocaml": {
        "lines": [
          "let rec first_two_elements lst =",
          "  let len = List.length lst in",
          "  if len < 1 then",
          "    []",
          "  else",
          "    let first_el = List.hd lst in",
          "    let rest_lst = List.tl lst in",
          "    if rest_lst = [] then",
          "      [first_el]",
          "    else",
          "      [first_el; List.hd rest_lst]",
          "in",
          "first_two_elements [5; 6; 7; 8; 9]"
        ],
        "recursion-step-answer": [5, 6]
      },
      "explanations_racket": [
        "Define una función `first-two-elements` que toma una lista `lst`, como tareas de un gerente (5 6 7 8 9). En Racket, `(define (nombre params) cuerpo)` es como una receta para priorizar las dos primeras tareas.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar cuántas tareas hay antes de priorizar.",
        "Inicia un condicional `if` para verificar si la lista tiene menos de 1 elemento con `(< len 1)`, como asegurarse de que hay tareas.",
        "Si la lista está vacía, retorna `null`, indicando que no hay tareas para priorizar.",
        "Define `first-el` como `(first lst)`, tomando la primera tarea, como anotar la tarea inicial.",
        "Define `rest-lst` como `(rest lst)`, obteniendo la lista sin el primer elemento, como pasar a las tareas restantes.",
        "Verifica si `rest-lst` está vacía con `(empty? rest-lst)`, como preguntar si hay más tareas.",
        "Si `rest-lst` está vacía, retorna una lista con solo `first-el`, como priorizar solo la primera tarea si no hay más.",
        "Si `rest-lst` no está vacía, retorna una lista con `first-el` y el primer elemento de `rest-lst`, como priorizar las dos primeras tareas.",
        "Cierra el bloque `let` y el `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Llama a `first-two-elements` con `(5 6 7 8 9)`, retornando `(5 6)`, como seleccionar las dos primeras tareas."
      ],
      "explanations_ocaml": [
        "Define una función `first_two_elements` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` permite recursión, aunque aquí no se usa, como una receta para priorizar tareas.",
        "Usa `let` para calcular la longitud con `List.length lst`, como contar las tareas del gerente.",
        "Inicia un condicional `if` con `len < 1` para verificar si la lista está vacía, como confirmar si hay tareas.",
        "Si la lista está vacía, retorna `[]`, indicando que no hay tareas.",
        "Introduce la rama `else`, necesaria en OCaml para el caso no vacío.",
        "Define `first_el` como `List.hd lst`, tomando la primera tarea.",
        "Define `rest_lst` como `List.tl lst`, obteniendo las tareas restantes.",
        "Verifica si `rest_lst` está vacía con `rest_lst = []`, como preguntar si hay más tareas.",
        "Si `rest_lst` está vacía, retorna `[first_el]`, como priorizar solo la primera tarea.",
        "Introduce `else` para el caso donde hay más tareas.",
        "Retorna una lista con `first_el` y el primer elemento de `rest_lst`, como priorizar las dos primeras tareas.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `first_two_elements` con `[5; 6; 7; 8; 9]`, retornando `[5; 6]`."
      ],
      "comparisons": [
        "Similitudes: Ambas extraen los dos primeros elementos de una lista, con el mismo propósito y resultado `(5 6)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, aunque aquí no hay recursión. OCaml usa `;` para listas, Racket usa espacios.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(< len 1)`, OCaml usa `len < 1`.",
        "Similitudes: Ambas retornan una lista vacía si no hay elementos. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket incluye esta lógica en el `let`, OCaml usa `else` explícitamente.",
        "Similitudes: Ambas extraen el primer elemento. Diferencias: Racket usa `(first lst)`, OCaml usa `List.hd lst`.",
        "Similitudes: Ambas obtienen el resto de la lista. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas verifican si el resto está vacío. Diferencias: Racket usa `(empty? rest-lst)`, OCaml usa `rest_lst = []`.",
        "Similitudes: Ambas retornan una lista con el primer elemento si el resto está vacío. Diferencias: Racket usa `(list first-el)`, OCaml usa `[first_el]`.",
        "Similitudes: Ambas manejan el caso con más elementos. Diferencias: Racket usa `(list first-el (first rest-lst))`, OCaml usa `[first_el; List.hd rest_lst]` con `;`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 5 elementos, dando `(5 6)`. Diferencias: Racket usa `(first-two-elements '(5 6 7 8 9))`, OCaml usa `first_two_elements [5; 6; 7; 8; 9]`."
      ]
    },
    "ejercicio-3": {
      "title": "Obtener el Último Elemento de una Cola",
      "racket": {
        "lines": [
          "(define (last-element lst)",
          "  (let ((len (length lst)))",
          "    (if (< len 1)",
          "        null",
          "        (let ((rest-lst (rest lst))",
          "              (len-rest (length rest-lst)))",
          "          (if (= len-rest 0)",
          "              (first lst)",
          "              (last-element rest-lst)))))",
          "  )",
          ")",
          "(last-element '(1 2 3 4 5))"
        ],
        "recursion": [11, 0, 1, 2, 4, 5, 6, 8, 0, 1, 2, 4, 5, 6, 8, 0, 1, 2, 4, 5, 6, 8, 0, 1, 2, 4, 5, 6, 7],
        "recursion-step-answer": [1, 2, 3, 4, 5]
      },
      "ocaml": {
        "lines": [
          "let rec last_element lst =",
          "  let len = List.length lst in",
          "  if len < 1 then",
          "    None",
          "  else",
          "    let rest_lst = List.tl lst in",
          "    let len_rest = List.length rest_lst in",
          "    if len_rest = 0 then",
          "      Some (List.hd lst)",
          "    else",
          "      last_element rest_lst",
          "in",
          "last_element [1; 2; 3; 4; 5]"
        ],
        "recursion": [12, 0, 1, 2, 4, 5, 6, 7, 10, 0, 1, 2, 4, 5, 6, 7, 10, 0, 1, 2, 4, 5, 6, 7, 10, 0, 1, 2, 4, 5, 6, 7, 8],
        "recursion-step-answer": [1, 2, 3, 4, 5]
      },
      "explanations_racket": [
        "Define una función `last-element` que toma una lista `lst`, como clientes en una cola (1 2 3 4 5). En Racket, `(define (nombre params) cuerpo)` es como una receta para encontrar al último cliente.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar cuántos clientes hay.",
        "Verifica si la lista está vacía con `(< len 1)`, como preguntar si no hay clientes.",
        "Si la lista está vacía, retorna `null`, indicando que no hay último cliente.",
        "Define `rest-lst` como `(rest lst)`, obteniendo la lista sin el primer cliente.",
        "Define `len-rest` como `(length rest-lst)`, contando los clientes restantes.",
        "Verifica si `rest-lst` tiene longitud 0 con `(= len-rest 0)`, como preguntar si solo queda un cliente.",
        "Si `rest-lst` está vacía, retorna `(first lst)`, el último cliente.",
        "Si `rest-lst` no está vacía, llama recursivamente a `last-element` con `rest-lst`, como avanzar en la cola.",
        "Cierra el bloque `let` y el `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `last-element` con `(1 2 3 4 5)`, retornando `5`, el último cliente."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `last_element` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para encontrar al último cliente.",
        "Usa `let` para calcular la longitud con `List.length lst`, como contar clientes.",
        "Verifica si la lista está vacía con `len < 1`, como preguntar si no hay clientes.",
        "Si la lista está vacía, retorna `None`, indicando que no hay último cliente.",
        "Introduce la rama `else`, necesaria en OCaml para el caso no vacío.",
        "Define `rest_lst` como `List.tl lst`, obteniendo los clientes restantes.",
        "Define `len_rest` como `List.length rest_lst`, contando los clientes restantes.",
        "Verifica si `rest_lst` tiene longitud 0 con `len_rest = 0`.",
        "Si `rest_lst` está vacía, retorna `Some (List.hd lst)`, el último cliente.",
        "Introduce `else` para el caso recursivo.",
        "Llama recursivamente a `last_element` con `rest_lst`, como avanzar en la cola.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `last_element` con `[1; 2; 3; 4; 5]`, retornando `Some 5`."
      ],
      "comparisons": [
        "Similitudes: Ambas encuentran el último elemento de una lista con recursión, dando `5`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`. OCaml retorna `Some 5`, Racket retorna `5` directamente.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(< len 1)`, OCaml usa `len < 1`.",
        "Similitudes: Ambas retornan un valor nulo si la lista está vacía. Diferencias: Racket usa `null`, OCaml usa `None`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket lo hace en el `let`, OCaml usa `else`.",
        "Similitudes: Ambas obtienen el resto de la lista. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas calculan la longitud del resto. Diferencias: Racket usa `(length rest-lst)`, OCaml usa `List.length rest_lst`.",
        "Similitudes: Ambas verifican si el resto está vacío. Diferencias: Racket usa `(= len-rest 0)`, OCaml usa `len_rest = 0`.",
        "Similitudes: Ambas retornan el primer elemento si el resto está vacío. Diferencias: Racket usa `(first lst)`, OCaml usa `Some (List.hd lst)`.",
        "Similitudes: Ambas manejan el caso recursivo. Diferencias: Racket usa `(last-element rest-lst)`, OCaml usa `last_element rest_lst` con `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 5 elementos, dando `5`. Diferencias: Racket usa `(last-element '(1 2 3 4 5))`, OCaml usa `last_element [1; 2; 3; 4; 5]`."
      ]
    },
    "ejercicio-4": {
      "title": "Concatenar Tres Listas de un Mercado",
      "racket": {
        "lines": [
          "(define (append-three lst1 lst2 lst3)",
          "  (let ((len1 (length lst1))",
          "        (append12 (if (empty? lst1)",
          "                      lst2",
          "                      (cons (first lst1)",
          "                            (append-three (rest lst1) lst2 lst3)))))",
          "    (if (empty? append12)",
          "        lst3",
          "        (let ((first-12 (first append12))",
          "              (rest-12 (rest append12)))",
          "          (cons first-12 (append-three rest-12 lst3 '())))))",
          "  )",
          ")",
          "(append-three '(1 2) '(3 4) '(5 6))"
        ],
        "recursion": [13, 0, 1, 2, 4, 5, 0, 2, 4, 5, 0, 2, 3, 6, 8, 10, 6, 8, 10, 6, 7],
        "recursion-step-answer": [1, 2, 3, 4, 5, 6]
      },
      "ocaml": {
        "lines": [
          "let rec append_three lst1 lst2 lst3 =",
          "  let len1 = List.length lst1 in",
          "  let append12 = if lst1 = [] then",
          "                   lst2",
          "                 else",
          "                   List.hd lst1 :: append_three (List.tl lst1) lst2 lst3 in",
          "  if append12 = [] then",
          "    lst3",
          "  else",
          "    let first_12 = List.hd append12 in",
          "    let rest_12 = List.tl append12 in",
          "    first_12 :: append_three rest_12 lst3 []",
          "in",
          "append_three [1; 2] [3; 4] [5; 6]"
        ],
        "recursion": [13, 0, 1, 2, 4, 5, 0, 2, 4, 5, 0, 2, 3, 6, 8, 9, 10, 11, 6, 8, 9, 10, 11, 6, 7],
        "recursion-step-answer": [1, 2, 3, 4, 5, 6]
      },
      "explanations_racket": [
        "Define una función `append-three` que toma tres listas `lst1`, `lst2`, `lst3`, como frutas (1 2), verduras (3 4), y lácteos (5 6). Es como una receta para combinar productos en una lista.",
        "Usa `let` para calcular la longitud de `lst1` con `(length lst1)`, como contar los productos de frutas.",
        "Define `append12` con un `if` que verifica si `lst1` está vacía con `(empty? lst1)`.",
        "Si `lst1` está vacía, usa `lst2`, como pasar a las verduras si no hay frutas.",
        "Si `lst1` no está vacía, usa `cons` para añadir el primer elemento de `lst1` y llama recursivamente a `append-three` con el resto de `lst1`, como combinar una fruta con el resto.",
        "Cierra el `if` de `append12`, necesario para la sintaxis.",
        "Verifica si `append12` está vacía con `(empty? append12)`, como preguntar si frutas y verduras se agotaron.",
        "Si `append12` está vacía, retorna `lst3`, como usar solo los lácteos.",
        "Define `first-12` como `(first append12)`, tomando el primer elemento combinado.",
        "Define `rest-12` como `(rest append12)`, obteniendo el resto combinado.",
        "Usa `cons` para añadir `first-12` y llama recursivamente a `append-three` con `rest-12` y una lista vacía, como seguir combinando productos.",
        "Cierra el bloque `let` y el `if`, necesario para Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `append-three` con `(1 2)`, `(3 4)`, `(5 6)`, dando `(1 2 3 4 5 6)`."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `append_three` que toma tres listas. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para combinar productos.",
        "Usa `let` para calcular la longitud de `lst1` con `List.length lst1`.",
        "Define `append12` con un `if` que verifica si `lst1` está vacía con `lst1 = []`.",
        "Si `lst1` está vacía, usa `lst2`, como pasar a las verduras.",
        "Introduce `else` para el caso no vacío.",
        "Añade el primer elemento de `lst1` con `::` y llama recursivamente a `append_three` con el resto de `lst1`.",
        "Verifica si `append12` está vacía con `append12 = []`.",
        "Si `append12` está vacía, retorna `lst3`.",
        "Introduce `else` para el caso no vacío.",
        "Define `first_12` como `List.hd append12`, tomando el primer elemento combinado.",
        "Define `rest_12` como `List.tl append12`, obteniendo el resto.",
        "Añade `first_12` con `::` y llama recursivamente a `append_three` con `rest_12` y una lista vacía.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `append_three` con `[1; 2]`, `[3; 4]`, `[5; 6]`, dando `[1; 2; 3; 4; 5; 6]`."
      ],
      "comparisons": [
        "Similitudes: Ambas concatenan tres listas, dando `(1 2 3 4 5 6)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas calculan la longitud de `lst1`. Diferencias: Racket usa `(length lst1)`, OCaml usa `List.length lst1`.",
        "Similitudes: Ambas verifican si `lst1` está vacía. Diferencias: Racket usa `(empty? lst1)`, OCaml usa `lst1 = []`.",
        "Similitudes: Ambas usan `lst2` si `lst1` está vacía. Diferencias: Racket usa `lst2` directamente, OCaml usa `lst2` en el `if`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket usa `(cons ...)` en el `if`, OCaml usa `::` con `else`.",
        "Similitudes: Ambas combinan el primer elemento de `lst1` recursivamente. Diferencias: Racket usa `(cons (first lst1) ...`, OCaml usa `List.hd lst1 :: ...`.",
        "Similitudes: Ambas verifican si `append12` está vacía. Diferencias: Racket usa `(empty? append12)`, OCaml usa `append12 = []`.",
        "Similitudes: Ambas retornan `lst3` si `append12` está vacía. Diferencias: Racket usa `lst3` directamente, OCaml usa `lst3` en el `if`.",
        "Similitudes: Ambas manejan el caso no vacío de `append12`. Diferencias: Racket usa `let`, OCaml usa `else`.",
        "Similitudes: Ambas extraen el primer elemento de `append12`. Diferencias: Racket usa `(first append12)`, OCaml usa `List.hd append12`.",
        "Similitudes: Ambas obtienen el resto de `append12`. Diferencias: Racket usa `(rest append12)`, OCaml usa `List.tl append12`.",
        "Similitudes: Ambas combinan el primer elemento recursivamente. Diferencias: Racket usa `(cons first-12 ...)`, OCaml usa `first_12 :: ...`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con tres listas, dando `(1 2 3 4 5 6)`. Diferencias: Racket usa `(append-three '(1 2) '(3 4) '(5 6))`, OCaml usa `append_three [1; 2] [3; 4] [5; 6]`."
      ]
    },
    "ejercicio-5": {
      "title": "Obtener Elementos Intermedios de una Lista de Tareas",
      "racket": {
        "lines": [
          "(define (middle-elements lst)",
          "  (let ((len (length lst))",
          "        (rest-lst (if (empty? lst) null (rest lst))))",
          "    (if (< len 2)",
          "        null",
          "        (let ((len-rest (length rest-lst))",
          "              (middle-rest (if (empty? rest-lst) null (rest rest-lst))))",
          "          (if (<= len-rest 1)",
          "              null",
          "              (cons (first rest-lst) (middle-elements rest-lst)))))",
          "  )",
          ")",
          "(middle-elements '(1 2 3 4 5 6))"
        ],
        "recursion": [12, 0, 1, 3, 5, 6, 7, 9, 0, 1, 3, 5, 6, 7, 9, 0, 1, 3, 5, 6, 7, 9, 0, 1, 3, 5, 6, 7, 8],
        "recursion-step-answer": [2, 3, 4, 5]
      },
      "ocaml": {
        "lines": [
          "let rec middle_elements lst =",
          "  let len = List.length lst in",
          "  let rest_lst = if lst = [] then [] else List.tl lst in",
          "  if len < 2 then",
          "    []",
          "  else",
          "    let len_rest = List.length rest_lst in",
          "    let middle_rest = if rest_lst = [] then [] else List.tl rest_lst in",
          "    if len_rest <= 1 then",
          "      []",
          "    else",
          "      List.hd rest_lst :: middle_elements rest_lst",
          "in",
          "middle_elements [1; 2; 3; 4; 5; 6]"
        ],
        "recursion": [13, 0, 1, 2, 3, 5, 6, 7, 8, 11, 0, 1, 2, 3, 5, 6, 7, 8, 11, 0, 1, 2, 3, 5, 6, 7, 8, 11, 0, 1, 2, 3, 5, 6, 7, 8, 9],
        "recursion-step-answer": [2, 3, 4, 5]
      },
      "explanations_racket": [
        "Define una función `middle-elements` que toma una lista `lst`, como tareas de un estudiante (1 2 3 4 5 6). Es como una receta para obtener tareas intermedias, sin la primera ni la última.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar todas las tareas.",
        "Define `rest-lst` con un `if` que retorna `null` si la lista está vacía o `(rest lst)` si no, como obtener las tareas sin la primera.",
        "Verifica si la lista tiene menos de 2 elementos con `(< len 2)`, como asegurar que hay suficientes tareas.",
        "Si la lista tiene menos de 2 elementos, retorna `null`, indicando que no hay tareas intermedias.",
        "Define `len-rest` como `(length rest-lst)`, contando las tareas restantes.",
        "Define `middle-rest` como el resto de `rest-lst`, como eliminar la primera tarea restante.",
        "Verifica si `rest-lst` tiene 1 o menos elementos con `(<= len-rest 1)`.",
        "Si `rest-lst` tiene 1 o menos elementos, retorna `null`, indicando que no hay intermedios.",
        "Si hay más elementos, usa `cons` para añadir el primer elemento de `rest-lst` y llama recursivamente a `middle-elements`, como construir la lista intermedia.",
        "Cierra el bloque `let` y el `if`, necesario para Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `middle-elements` con `(1 2 3 4 5 6)`, dando `(2 3 4 5)`."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `middle_elements` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para tareas intermedias.",
        "Usa `let` para calcular la longitud con `List.length lst`.",
        "Define `rest_lst` con un `if` que retorna `[]` si la lista está vacía o `List.tl lst` si no.",
        "Verifica si la lista tiene menos de 2 elementos con `len < 2`.",
        "Si la lista tiene menos de 2 elementos, retorna `[]`.",
        "Introduce `else` para el caso con más elementos.",
        "Define `len_rest` como `List.length rest_lst`, contando las tareas restantes.",
        "Define `middle_rest` como el resto de `rest_lst` con `List.tl rest_lst`.",
        "Verifica si `rest_lst` tiene 1 o menos elementos con `len_rest <= 1`.",
        "Si `rest_lst` tiene 1 o menos elementos, retorna `[]`.",
        "Introduce `else` para el caso recursivo.",
        "Añade el primer elemento de `rest_lst` con `::` y llama recursivamente a `middle_elements`.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `middle_elements` con `[1; 2; 3; 4; 5; 6]`, dando `[2; 3; 4; 5]`."
      ],
      "comparisons": [
        "Similitudes: Ambas obtienen los elementos intermedios de una lista, dando `(2 3 4 5)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas obtienen el resto de la lista. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas verifican si la lista tiene menos de 2 elementos. Diferencias: Racket usa `(< len 2)`, OCaml usa `len < 2`.",
        "Similitudes: Ambas retornan una lista vacía si no hay suficientes elementos. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso con más elementos. Diferencias: Racket usa `let`, OCaml usa `else`.",
        "Similitudes: Ambas calculan la longitud del resto. Diferencias: Racket usa `(length rest-lst)`, OCaml usa `List.length rest_lst`.",
        "Similitudes: Ambas obtienen el resto del resto. Diferencias: Racket usa `(rest rest-lst)`, OCaml usa `List.tl rest_lst`.",
        "Similitudes: Ambas verifican si el resto tiene 1 o menos elementos. Diferencias: Racket usa `(<= len-rest 1)`, OCaml usa `len_rest <= 1`.",
        "Similitudes: Ambas retornan una lista vacía si no hay intermedios. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso recursivo. Diferencias: Racket usa `(cons ...)`, OCaml usa `::` con `else`.",
        "Similitudes: Ambas combinan el primer elemento del resto recursivamente. Diferencias: Racket usa `(cons (first rest-lst) ...)`, OCaml usa `List.hd rest_lst :: ...`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 6 elementos, dando `(2 3 4 5)`. Diferencias: Racket usa `(middle-elements '(1 2 3 4 5 6))`, OCaml usa `middle_elements [1; 2; 3; 4; 5; 6]`."
      ]
    },
    "ejercicio-6": {
      "title": "Verificar si Todas las Sublistas Están Vacías",
      "racket": {
        "lines": [
          "(define (all-empty? lst)",
          "  (let ((len (length lst))",
          "        (first-sublist (if (empty? lst) null (first lst)))",
          "        (rest-sublists (if (empty? lst) null (rest lst))))",
          "    (if (= len 0)",
          "        true",
          "        (let ((len-first (length first-sublist))",
          "              (rest-empty (all-empty? rest-sublists)))",
          "          (and (= len-first 0) rest-empty))))",
          "  )",
          ")",
          "(all-empty? '((1 2) () (3 4) ()))"
        ],
        "recursion": [11, 0, 1, 2, 3, 4, 6, 7, 8, 0, 1, 2, 3, 4, 6, 7, 8, 0, 1, 2, 3, 4, 6, 7, 8, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [false, true, false, true]
      },
      "ocaml": {
        "lines": [
          "let rec all_empty lst =",
          "  let len = List.length lst in",
          "  let first_sublist = if lst = [] then [] else List.hd lst in",
          "  let rest_sublists = if lst = [] then [] else List.tl lst in",
          "  if len = 0 then",
          "    true",
          "  else",
          "    let len_first = List.length first_sublist in",
          "    let rest_empty = all_empty rest_sublists in",
          "    len_first = 0 && rest_empty",
          "in",
          "all_empty [[1; 2]; []; [3; 4]; []]"
        ],
        "recursion": [11, 0, 1, 2, 3, 4, 6, 7, 8, 9, 0, 1, 2, 3, 4, 6, 7, 8, 9, 0, 1, 2, 3, 4, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [false, true, false, true]
      },
      "explanations_racket": [
        "Define una función `all-empty?` que toma una lista de listas `lst`, como sublistas de tareas ((1 2) () (3 4) ()). Es como una receta para verificar si todas las sublistas están vacías.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar cuántas sublistas hay.",
        "Define `first-sublist` con un `if` que retorna `null` si la lista está vacía o `(first lst)` si no, como tomar la primera sublista de tareas.",
        "Define `rest-sublists` como `(rest lst)` si no está vacía, como obtener las sublistas restantes.",
        "Verifica si la lista tiene longitud 0 con `(= len 0)`, como preguntar si no hay sublistas.",
        "Si la lista está vacía, retorna `true`, indicando que todas las sublistas están vacías por definición.",
        "Define `len-first` como `(length first-sublist)`, contando los elementos de la primera sublista.",
        "Define `rest-empty` como `(all-empty? rest-sublists)`, verificando recursivamente las sublistas restantes.",
        "Combina con `and` para verificar si `len-first` es 0 y `rest-empty` es `true`, como confirmar que todas las sublistas están vacías.",
        "Cierra el bloque `let` y el `if`, necesario para Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `all-empty?` con `((1 2) () (3 4) ())`, dando `false` porque no todas las sublistas están vacías."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `all_empty` que toma una lista de listas. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para verificar sublistas vacías.",
        "Usa `let` para calcular la longitud con `List.length lst`.",
        "Define `first_sublist` con un `if` que retorna `[]` si la lista está vacía o `List.hd lst` si no.",
        "Define `rest_sublists` como `List.tl lst` si no está vacía.",
        "Verifica si la lista tiene longitud 0 con `len = 0`.",
        "Si la lista está vacía, retorna `true`.",
        "Introduce `else` para el caso con sublistas.",
        "Define `len_first` como `List.length first_sublist`, contando los elementos de la primera sublista.",
        "Define `rest_empty` como `all_empty rest_sublists`, verificando recursivamente.",
        "Combina con `&&` para verificar si `len_first` es 0 y `rest_empty` es `true`.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `all_empty` con `[[1; 2]; []; [3; 4]; []]`, dando `false`."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican si todas las sublistas están vacías, dando `false`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas obtienen la primera sublista. Diferencias: Racket usa `(first lst)`, OCaml usa `List.hd lst`.",
        "Similitudes: Ambas obtienen las sublistas restantes. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(= len 0)`, OCaml usa `len = 0`.",
        "Similitudes: Ambas retornan `true` si la lista está vacía. Diferencias: Racket usa `true`, OCaml usa `true` en el `if`.",
        "Similitudes: Ambas manejan el caso con sublistas. Diferencias: Racket usa `let`, OCaml usa `else`.",
        "Similitudes: Ambas calculan la longitud de la primera sublista. Diferencias: Racket usa `(length first-sublist)`, OCaml usa `List.length first_sublist`.",
        "Similitudes: Ambas verifican recursivamente las sublistas restantes. Diferencias: Racket usa `(all-empty? rest-sublists)`, OCaml usa `all_empty rest_sublists`.",
        "Similitudes: Ambas combinan las condiciones con un operador lógico. Diferencias: Racket usa `(and ...)`, OCaml usa `&&`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de listas, dando `false`. Diferencias: Racket usa `(all-empty? '((1 2) () (3 4) ()))`, OCaml usa `all_empty [[1; 2]; []; [3; 4]; []]`."
      ]
    },
    "ejercicio-7": {
      "title": "Añadir un Elemento Transformado a una Lista",
      "racket": {
        "lines": [
          "(define (cons-transformed-aux x lst acc)",
          "  (let ((transformed (* x 2))",
          "        (len (length lst))",
          "        (new-lst (cons transformed lst)))",
          "    (if (empty? new-lst)",
          "        acc",
          "        (let ((first-el (first new-lst))",
          "              (rest-el (rest new-lst))",
          "              (len-rest (length rest-el)))",
          "          (cons-transformed-aux 0 rest-el (cons first-el acc))))",
          ")",
          "(define (cons-transformed x lst)",
          "  (cons-transformed-aux x lst null)",
          ")",
          "(cons-transformed 0 '(1 2 3 4))"
        ],
        "recursion": [14, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [0, 1, 2, 3, 4]
      },
      "ocaml": {
        "lines": [
          "let rec cons_transformed_aux x lst acc =",
          "  let transformed = x * 2 in",
          "  let len = List.length lst in",
          "  let new_lst = transformed :: lst in",
          "  if new_lst = [] then",
          "    List.rev acc",
          "  else",
          "    let first_el = List.hd new_lst in",
          "    let rest_el = List.tl new_lst in",
          "    let len_rest = List.length rest_el in",
          "    cons_transformed_aux 0 rest_el (first_el :: acc)",
          "let cons_transformed x lst =",
          "  cons_transformed_aux x lst []",
          "in",
          "cons_transformed 0 [1; 2; 3; 4]"
        ],
        "recursion": [14, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [0, 1, 2, 3, 4]
      },
      "explanations_racket": [
        "Define una función auxiliar `cons-transformed-aux` que toma un elemento `x`, una lista `lst`, y un acumulador `acc`. Es como una receta para que un programador transforme un elemento (0*2=0) y lo añada a una lista como (1 2 3 4).",
        "Inicia un bloque `let` para definir variables intermedias, como anotar pasos en una libreta para organizar el cálculo.",
        "Define `transformed` como `(* x 2)`, duplicando el elemento, como calcular el nuevo valor a añadir.",
        "Define `len` como `(length lst)`, contando los elementos de la lista original para verificar su tamaño.",
        "Define `new-lst` como `(cons transformed lst)`, añadiendo el elemento transformado al inicio de la lista, como preparar una lista temporal.",
        "Inicia un condicional `if` para verificar si `new-lst` está vacía con `(empty? new-lst)`, como preguntar si la lista temporal está completa.",
        "Si `new-lst` está vacía, retorna `acc`, la lista acumulada con los elementos procesados, como entregar el resultado final.",
        "Inicia otro bloque `let` para definir más variables intermedias, como continuar anotando pasos detallados.",
        "Define `first-el` como `(first new-lst)`, tomando el primer elemento de la lista temporal, como seleccionar el siguiente elemento a procesar.",
        "Define `rest-el` como `(rest new-lst)`, obteniendo el resto de la lista temporal, como avanzar a los elementos restantes.",
        "Define `len-rest` como `(length rest-el)`, contando los elementos restantes para verificar si hay más que procesar.",
        "Llama recursivamente a `cons-transformed-aux` con 0, `rest-el`, y un acumulador que incluye `first-el` usando `(cons first-el acc)`, como continuar construyendo la lista.",
        "Cierra el bloque `let` y el `if`, necesario para la sintaxis de Racket, como cerrar un paso en la receta.",
        "Cierra la definición de `cons-transformed-aux` con un paréntesis, como el punto final de la receta auxiliar.",
        "Define la función principal `cons-transformed` que toma `x` y `lst`, inicializando la recursión con un acumulador vacío, como preparar el inicio del proceso.",
        "Llama a `cons-transformed-aux` con `x`, `lst`, y `null`, como iniciar la receta con un acumulador vacío.",
        "Cierra la definición de `cons-transformed` con un paréntesis, necesario para la sintaxis de Racket.",
        "Llama a `cons-transformed` con 0 and `(1 2 3 4)`, retornando `(0 1 2 3 4)`, como completar la lista transformada."
      ],
      "explanations_ocaml": [
        "Define una función auxiliar recursiva `cons_transformed_aux` que toma `x`, `lst`, y `acc`. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para transformar y añadir un elemento.",
        "Define `transformed` como `x * 2`, duplicando el elemento, como calcular el nuevo valor a añadir.",
        "Define `len` como `List.length lst`, contando los elementos de la lista original.",
        "Define `new_lst` como `transformed :: lst`, añadiendo el elemento transformado al inicio, como preparar una lista temporal.",
        "Inicia un condicional `if` para verificar si `new_lst` está vacía con `new_lst = []`, como preguntar si la lista temporal está completa.",
        "Si `new_lst` está vacía, retorna `List.rev acc`, invirtiendo el acumulador para obtener el orden correcto, como entregar el resultado final.",
        "Introduce la rama `else` para manejar el caso donde `new_lst` no está vacía, preparando la recursión.",
        "Define `first_el` como `List.hd new_lst`, tomando el primer elemento de la lista temporal.",
        "Define `rest_el` como `List.tl new_lst`, obteniendo el resto de la lista temporal.",
        "Define `len_rest` como `List.length rest_el`, contando los elementos restantes.",
        "Llama recursivamente a `cons_transformed_aux` con 0, `rest_el`, y un acumulador con `first_el` usando `first_el :: acc`, como continuar construyendo la lista.",
        "Define la función principal `cons_transformed` que inicializa la recursión con un acumulador vacío.",
        "Llama a `cons_transformed_aux` con `x`, `lst`, y `[]`, como iniciar la receta con un acumulador vacío.",
        "Usa `in` para conectar la definición de `cons_transformed` con la llamada, una regla estructural de OCaml.",
        "Llama a `cons_transformed` con 0 and `[1; 2; 3; 4]`, retornando `[0; 1; 2; 3; 4]`."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función auxiliar recursiva para añadir un elemento transformado, dando `(0 1 2 3 4)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo` con `rec` explícito para recursión.",
        "Similitudes: Ambas calculan el elemento transformado multiplicando por 2. Diferencias: Racket usa `(* x 2)` con notación prefija, OCaml usa `x * 2` con notación infija, más matemática.",
        "Similitudes: Ambas calculan la longitud de la lista original para verificar su tamaño. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst` con notación de módulo.",
        "Similitudes: Ambas añaden el elemento transformado al inicio de la lista. Diferencias: Racket usa `(cons transformed lst)` con notación prefija, OCaml usa `transformed :: lst` con notación infija.",
        "Similitudes: Ambas verifican si la lista temporal está vacía. Diferencias: Racket usa `(empty? new-lst)` con notación prefija, OCaml usa `new_lst = []` con notación infija.",
        "Similitudes: Ambas retornan el acumulador si la lista está vacía. Diferencias: Racket usa `acc` directamente, OCaml usa `List.rev acc` para corregir el orden debido a la construcción de la lista.",
        "Similitudes: Ambas manejan el caso no vacío para continuar la recursión. Diferencias: Racket usa un `let` anidado para definir variables, OCaml usa `else` explícitamente para estructurar la lógica.",
        "Similitudes: Ambas extraen el primer elemento de la lista temporal. Diferencias: Racket usa `(first new-lst)`, OCaml usa `List.hd new_lst` con notación de módulo.",
        "Similitudes: Ambas obtienen el resto de la lista temporal. Diferencias: Racket usa `(rest new-lst)`, OCaml usa `List.tl new_lst`.",
        "Similitudes: Ambas calculan la longitud del resto de la lista para verificar si hay más elementos. Diferencias: Racket usa `(length rest-el)`, OCaml usa `List.length rest_el`.",
        "Similitudes: Ambas llaman recursivamente a la función auxiliar con un acumulador actualizado. Diferencias: Racket usa `(cons-transformed-aux 0 rest-el (cons first-el acc))` con notación prefija, OCaml usa `cons_transformed_aux 0 rest_el (first_el :: acc)` con notación infija.",
        "Similitudes: Ambas definen una función principal que inicializa la recursión. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo` sin necesidad de `rec` en la función principal.",
        "Similitudes: Ambas inicializan la recursión con un acumulador vacío. Diferencias: Racket usa `null` como acumulador inicial, OCaml usa `[]`, reflejando diferencias en la sintaxis de listas vacías.",
        "Similitudes: Ambas son líneas estructurales necesarias para completar la definición. Diferencias: Racket cierra la función auxiliar y principal con `)`, OCaml usa `in` para conectar la definición principal con la llamada.",
        "Similitudes: Ambas llaman la función principal con 0 and una lista de 4 elementos, retornando `(0 1 2 3 4)`. Diferencias: Racket usa `(cons-transformed 0 '(1 2 3 4))` con comillas y paréntesis, OCaml usa `cons_transformed 0 [1; 2; 3; 4]` con corchetes y `;` para listas."
      ]
    }
  },
  "funciones-orden-superior": {
    "ejercicio-1": {
      "title": "Aplicar descuento a precios con map",
      "racket": {
        "lines": [
          "(define (apply-discount lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (map (lambda (x) (* x 0.85)) lst)",
          "  )",
          ")",
          "(apply-discount '(100 200 300))"
        ]
      },
      "ocaml": {
        "lines": [
          "let apply_discount lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.map (fun x -> x *. 0.85) lst",
          "in",
          "apply_discount [100; 200; 300]"
        ]
      },
      "explanations_racket": [
        "Define una función llamada `apply-discount` que toma una lista `lst` (como precios de productos). En Racket, `(define (nombre params) cuerpo)` es como nombrar una receta para procesar datos, asegurando que no modificamos los precios originales.",
        "Verifica si la lista está vacía con `(empty? lst)`. Es como revisar si el carrito de compras está vacío antes de aplicar descuentos.",
        "Si la lista está vacía, devuelve `()` (una lista vacía). Esto evita errores, como intentar descontar nada.",
        "Si la lista no está vacía, usa `map` para aplicar una función anónima `(lambda (x) (* x 0.85))` a cada precio, multiplicándolo por 0.85 (descuento del 15%). `map` es como un asistente que ajusta cada precio uno por uno, creando una nueva lista.",
        "Cierra la condición `if` y la función, siguiendo las reglas de Racket con paréntesis.",
        "Cierra la definición de la función, completando la 'receta'.",
        "Llama a `apply-discount` con la lista `(100 200 300)`, dando `(85.0 170.0 255.0)`, como mostrar los precios finales tras el descuento."
      ],
      "explanations_ocaml": [
        "Define una función `apply_discount` que toma una lista `lst`. En OCaml, `let nombre params = cuerpo` es como crear una instrucción para procesar datos, manteniendo los precios originales intactos.",
        "Verifica si la lista está vacía con `lst = []`. Es como comprobar si no hay productos en el carrito.",
        "Si la lista está vacía, devuelve `[]` (lista vacía). Esto previene problemas al procesar nada.",
        "Si la lista no está vacía, introduce la rama `else`, requerida en OCaml para completar la condición.",
        "Usa `List.map` para aplicar `(fun x -> x *. 0.85)` a cada elemento, multiplicando por 0.85 para el descuento. `List.map` es como un empleado que ajusta cada precio, creando una nueva lista.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `apply_discount` con `[100; 200; 300]`, dando `[85.0; 170.0; 255.0]`, mostrando los precios con descuento."
      ],
      "comparisons": [
        "Similitudes: Ambas funciones aplican un descuento usando `map`, creando una nueva lista sin cambiar la original. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal. OCaml infiere tipos (lista de enteros a flotantes).",
        "Similitudes: Ambas verifican si la lista está vacía para robustez. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija, más intuitiva para matemáticas.",
        "Similitudes: Ambas devuelven una lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`, reflejando notaciones de lista distintas.",
        "Similitudes: Ambas transforman la lista con una función anónima. Diferencias: Racket usa `(lambda (x) (* x 0.85))` prefija, OCaml usa `(fun x -> x *. 0.85)` infija con `*.` para flotantes. OCaml requiere `List.map` por su módulo `List`.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `else` explícito y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in` para separar definición y llamada.",
        "Similitudes: Ambas llaman la función con listas idénticas, dando `(85.0 170.0 255.0)`. Diferencias: Racket usa `'(100 200 300)` con comillas, OCaml usa `[100; 200; 300]` con punto y coma."
      ]
    },
    "ejercicio-2": {
      "title": "Filtrar productos con stock y precio específicos",
      "racket": {
        "lines": [
          "(define (filter-stock lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (filter (lambda (x) (and (> x 5) (< x 50))) lst)",
          "  )",
          ")",
          "(filter-stock '(10 60 30 40 70))"
        ]
      },
      "ocaml": {
        "lines": [
          "let filter_stock lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.filter (fun x -> x > 5 && x < 50) lst",
          "in",
          "filter_stock [10; 60; 30; 40; 70]"
        ]
      },
      "explanations_racket": [
        "Define una función `filter-stock` que toma una lista `lst` (como cantidades en un inventario). `(define (nombre params) cuerpo)` es como crear una regla para elegir productos.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si el almacén está vacío.",
        "Si está vacía, devuelve `()` (lista vacía), evitando errores.",
        "Usa `filter` para aplicar `(lambda (x) (and (> x 5) (< x 50)))`, seleccionando números entre 5 y 50. Es como un filtro que elige productos con stock adecuado y precio bajo.",
        "Cierra la condición `if` y la función con paréntesis.",
        "Cierra la definición de la función, completando la regla.",
        "Llama a `filter-stock` con `(10 60 30 40 70)`, dando `(10 30 40)`, como mostrar los productos seleccionados."
      ],
      "explanations_ocaml": [
        "Define una función `filter_stock` que toma una lista `lst`. `let nombre params = cuerpo` es como escribir una instrucción para seleccionar productos.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay productos.",
        "Si está vacía, devuelve `[]` (lista vacía), previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml para manejar el caso no vacío.",
        "Usa `List.filter` para aplicar `(fun x -> x > 5 && x < 50)`, seleccionando números entre 5 y 50. Es como un tamiz que elige productos específicos.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `filter_stock` con `[10; 60; 30; 40; 70]`, dando `[10; 30; 40]`, mostrando los productos seleccionados."
      ],
      "comparisons": [
        "Similitudes: Ambas filtran elementos usando `filter`, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican listas vacías. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`.",
        "Similitudes: Ambas usan `filter`/`List.filter` con un predicado compuesto. Diferencias: Racket usa `(and (> x 5) (< x 50))` prefija, OCaml usa `x > 5 && x < 50` infija. OCaml requiere `List.filter`.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `else` y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con listas idénticas, dando `(10 30 40)`. Diferencias: Racket usa `'(10 60 30 40 70)`, OCaml usa `[10; 60; 30; 40; 70]`."
      ]
    },
    "ejercicio-3": {
      "title": "Filtrar y elevar al cuadrado costos",
      "racket": {
        "lines": [
          "(define (process-costs lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (let ((filtered (filter (lambda (x) (> (abs x) 3)) lst)))",
          "        (map (lambda (x) (* (abs x) (abs x))) filtered)",
          "      )",
          "  )",
          ")",
          "(process-costs '(2 3 -4 5 -6))"
        ]
      },
      "ocaml": {
        "lines": [
          "let process_costs lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    let filtered = List.filter (fun x -> abs x > 3) lst in",
          "    List.map (fun x -> (abs x) * (abs x)) filtered",
          "in",
          "process_costs [2; 3; -4; 5; -6]"
        ]
      },
      "explanations_racket": [
        "Define una función `process-costs` que toma una lista `lst` (como costos). `(define (nombre params) cuerpo)` es como crear un proceso para analizar costos.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay costos registrados.",
        "Si está vacía, devuelve `()` (lista vacía), evitando errores.",
        "Usa `let` para almacenar el resultado de `filter` en `filtered`. `filter` aplica `(lambda (x) (> (abs x) 3))`, seleccionando valores cuyo valor absoluto es mayor a 3. Es como elegir costos significativos.",
        "Aplica `map` con `(lambda (x) (* (abs x) (abs x)))` a la lista filtrada, calculando el cuadrado de valores absolutos. Es como calcular el impacto al cuadrado de los costos seleccionados.",
        "Cierra la condición `let` y `if`, siguiendo la sintaxis de Racket.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `process-costs` con `(2 3 -4 5 -6)`, dando `(16 25 36)`, mostrando los costos procesados."
      ],
      "explanations_ocaml": [
        "Define una función `process_costs` que toma una lista `lst`. `let nombre params = cuerpo` es como escribir un procedimiento para costos.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay datos.",
        "Si está vacía, devuelve `[]` (lista vacía), previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml.",
        "Usa `let filtered = ...` para guardar el resultado de `List.filter` con `(fun x -> abs x > 3)`, seleccionando valores absolutos mayores a 3. Es como elegir costos relevantes.",
        "Aplica `List.map` con `(fun x -> (abs x) * (abs x))` a la lista filtrada, calculando cuadrados. Es como procesar los costos seleccionados.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `process_costs` con `[2; 3; -4; 5; -6]`, dando `[16; 25; 36]`, mostrando los resultados."
      ],
      "comparisons": [
        "Similitudes: Ambas filtran y transforman listas usando `filter` y `map`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican listas vacías. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`.",
        "Similitudes: Ambas filtran con un predicado basado en valor absoluto. Diferencias: Racket usa `(let ((filtered ...)))` con paréntesis, OCaml usa `let filtered = ... in` más lineal.",
        "Similitudes: Ambas aplican `map` para calcular cuadrados. Diferencias: Racket usa `(lambda (x) (* (abs x) (abs x)))` prefija, OCaml usa `(fun x -> (abs x) * (abs x))` infija.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con listas idénticas, dando `(16 25 36)`. Diferencias: Racket usa `'(2 3 -4 5 -6)`, OCaml usa `[2; 3; -4; 5; -6]`."
      ]
    },
    "ejercicio-4": {
      "title": "Sumar transacciones mayores a un umbral",
      "racket": {
        "lines": [
          "(define (sum-transactions threshold lst)",
          "  (if (empty? lst)",
          "      0",
          "      (foldl + 0 (filter (lambda (x) (> x threshold)) lst))",
          "  )",
          ")",
          "(sum-transactions 100 '(100 -50 200 -30 150))"
        ]
      },
      "ocaml": {
        "lines": [
          "let sum_transactions threshold lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    List.fold_left (+) 0 (List.filter (fun x -> x > threshold) lst)",
          "in",
          "sum_transactions 100 [100; -50; 200; -30; 150]"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-transactions` que toma un `threshold` (umbral) y una lista `lst` (como transacciones). `(define (nombre params) cuerpo)` es como crear una calculadora de totales.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay transacciones.",
        "Si está vacía, devuelve `0`, evitando errores en el cálculo.",
        "Usa `foldl` para sumar (`+`) los elementos filtrados por `(filter (lambda (x) (> x threshold)) lst)`, seleccionando transacciones mayores al umbral. Es como sumar solo las transacciones grandes.",
        "Cierra la condición `if` y la función con paréntesis.",
        "Cierra la definición de la función.",
        "Llama a `sum-transactions` con umbral `100` y lista `(100 -50 200 -30 150)`, dando `350` (200 + 150)."
      ],
      "explanations_ocaml": [
        "Define una función `sum_transactions` que toma `threshold` y `lst`. `let nombre params = cuerpo` es como programar una calculadora de transacciones.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay datos.",
        "Si está vacía, devuelve `0`, previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml.",
        "Usa `List.fold_left (+) 0` para sumar los elementos filtrados por `List.filter (fun x -> x > threshold)`, seleccionando transacciones mayores al umbral. Es como calcular el total de transacciones relevantes.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `sum_transactions` con `100` y `[100; -50; 200; -30; 150]`, dando `350`."
      ],
      "comparisons": [
        "Similitudes: Ambas suman transacciones usando `filter` y `fold`, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican listas vacías. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven `0` para listas vacías. Diferencias: Notación idéntica, pero Racket usa `'()` para listas vacías en otros contextos.",
        "Similitudes: Ambas usan `filter` y `fold` para procesar datos. Diferencias: Racket usa `(foldl + 0 ...)` prefija, OCaml usa `List.fold_left (+) 0` infija. OCaml requiere módulos `List`.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `else` y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con umbral y lista idéntica, dando `350`. Diferencias: Racket usa `'(100 -50 200 -30 150)`, OCaml usa `[100; -50; 200; -30; 150]`."
      ]
    },
    "ejercicio-5": {
      "title": "Procesar valores financieros con currying",
      "racket": {
        "lines": [
          "(define (make-financial-processor threshold)",
          "  (lambda (lst)",
          "    (if (empty? lst)",
          "        0",
          "        (foldl + 0",
          "               (filter (lambda (x) (> x threshold))",
          "                       (map abs lst))",
          "        )",
          "    )",
          "  )",
          ")",
          "((make-financial-processor 150) '(-200 300 -100 400))"
        ]
      },
      "ocaml": {
        "lines": [
          "let make_financial_processor threshold =",
          "  fun lst ->",
          "    if lst = [] then",
          "      0",
          "    else",
          "      List.fold_left (+) 0",
          "        (List.filter (fun x -> x > threshold)",
          "           (List.map abs lst))",
          "in",
          "make_financial_processor 150 [-200; 300; -100; 400]"
        ]
      },
      "explanations_racket": [
        "Define una función `make-financial-processor` que toma un `threshold` (umbral) y devuelve otra función. `(define (nombre params) cuerpo)` es como crear una máquina configurable para procesar finanzas, como ajustar un filtro de transacciones.",
        "Crea una función anónima `(lambda (lst) ...)` que procesará una lista. Es como ajustar la máquina para trabajar con datos específicos.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay transacciones para procesar.",
        "Si la lista está vacía, devuelve `0`, evitando errores en el cálculo.",
        "Usa `foldl` con `+` y valor inicial `0` para sumar los elementos filtrados, que son seleccionados por `filter` de los resultados de `map`. Es como sumar transacciones válidas después de ajustarlas.",
        "Aplica `filter` con `(lambda (x) (> x threshold))` para seleccionar valores mayores al umbral, como elegir transacciones significativas.",
        "Aplica `map` con `abs` para convertir cada valor a positivo, como corregir números negativos en un reporte financiero.",
        "Cierra la condición `if` y la función anónima con paréntesis, siguiendo la sintaxis de Racket.",
        "Cierra la definición de la función anónima.",
        "Cierra la definición de la función principal con paréntesis.",
        "Crea una función con umbral `150` y la aplica a la lista `(-200 300 -100 400)`, dando `700` (200 + 300 + 400), como calcular el total de transacciones válidas."
      ],
      "explanations_ocaml": [
        "Define una función `make_financial_processor` que toma `threshold` y devuelve otra función. `let nombre params = cuerpo` es como programar una calculadora ajustable para finanzas.",
        "Crea una función anónima con `fun lst ->`, que procesará una lista. Es como configurar la calculadora para una lista específica.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay datos financieros.",
        "Si la lista está vacía, devuelve `0`, previniendo errores.",
        "Introduce la rama `else`, requerida en OCaml para manejar el caso no vacío.",
        "Usa `List.fold_left` con `(+) 0` para sumar los elementos filtrados por `List.filter`, que selecciona valores mayores al umbral de los resultados de `List.map`. Es como procesar transacciones en pasos.",
        "Aplica `List.filter` con `(fun x -> x > threshold)` para elegir valores mayores al umbral.",
        "Aplica `List.map` con `abs` para convertir valores a positivos, como ajustar un reporte.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Crea una función con umbral `150` y la aplica a `[-200; 300; -100; 400]`, dando `700`, mostrando el total de transacciones válidas."
      ],
      "comparisons": [
        "Similitudes: Ambas usan currying para crear una función que devuelve otra, procesando listas con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas crean funciones anónimas para procesar listas. Diferencias: Racket usa `(lambda (lst) ...)`, OCaml usa `fun lst ->`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven `0` para listas vacías. Diferencias: Notación idéntica, pero contextos distintos.",
        "Similitudes: Ambas usan un pipeline de `map`, `filter`, y `fold` para procesar datos. Diferencias: Racket usa `(foldl + 0 ...)` prefija, OCaml usa `List.fold_left (+) 0` infija. OCaml requiere módulos `List`.",
        "Similitudes: Ambas filtran valores con un predicado. Diferencias: Racket usa `(lambda (x) (> x threshold))`, OCaml usa `(fun x -> x > threshold)`.",
        "Similitudes: Ambas aplican valor absoluto con `map`. Diferencias: Racket usa `(map abs lst)`, OCaml usa `List.map abs lst`.",
        "Similitudes: Ambas cierran la lógica anidada. Diferencias: Racket usa paréntesis, OCaml usa indentación y `in`.",
        "Similitudes: Ambas cierran la función anónima. Diferencias: Racket usa paréntesis, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con umbral `150` y lista idéntica, dando `700`. Diferencias: Racket usa `'(-200 300 -100 400)`, OCaml usa `[-200; 300; -100; 400]`."
      ]
    },
    "ejercicio-6": {
      "title": "Procesar ventas estructuradas con filter, map y fold",
      "racket": {
        "lines": [
          "(define (process-sales pred extractor lst)",
          "  (if (empty? lst)",
          "      0",
          "      (foldl + 0",
          "             (map extractor",
          "                  (filter pred lst))",
          "      )",
          "  )",
          ")",
          "(process-sales",
          "  (lambda (p) (and (string=? (cdr p) \"venta\") (> (car p) 0)))",
          "  car",
          "  '((200 . \"venta\") (-50 . \"devolucion\") (300 . \"venta\") (-20 . \"devolucion\")))"
        ]
      },
      "ocaml": {
        "lines": [
          "let process_sales pred extractor lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    List.fold_left (+) 0",
          "      (List.map extractor",
          "         (List.filter pred lst))",
          "in",
          "process_sales",
          "  (fun (m, t) -> t = \"venta\" && m > 0)",
          "  fst",
          "  [(200, \"venta\"); (-50, \"devolucion\"); (300, \"venta\"); (-20, \"devolucion\")]"
        ]
      },
      "explanations_racket": [
        "Define una función `process-sales` que toma un `pred` (regla de selección), un `extractor` (para obtener datos) y una lista `lst` de parejas (monto, tipo). `(define (nombre params) cuerpo)` es como crear un sistema para sumar ventas.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay registros de ventas.",
        "Si la lista está vacía, devuelve `0`, evitando errores en la suma.",
        "Usa `foldl` con `+` y valor inicial `0` para sumar los resultados de `map`, que aplica `extractor` a las parejas seleccionadas por `filter` con `pred`. Es como calcular el total de ventas válidas.",
        "Aplica `map` con `extractor` (como `car`) para extraer montos de las parejas filtradas, como tomar solo los valores numéricos.",
        "Aplica `filter` con `pred` para seleccionar parejas que cumplan la condición, como elegir solo ventas positivas.",
        "Cierra la condición `if` y el bloque de `foldl` con paréntesis.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `process-sales` con un predicado, `car` como extractora, y una lista de parejas, dando `500` (200 + 300).",
        "Define el predicado `(lambda (p) (and (string=? (cdr p) \"venta\") (> (car p) 0)))`, que verifica si la pareja tiene tipo \"venta\" y monto positivo. Es como una regla para identificar ventas válidas.",
        "Usa `car` como `extractor` para obtener el monto de cada pareja, como extraer el número de un registro.",
        "Pasa la lista de parejas `((200 . \"venta\") ...)` estructurada como pares en Racket, como un registro de transacciones."
      ],
      "explanations_ocaml": [
        "Define una función `process_sales` que toma `pred`, `extractor` y `lst` (parejas de monto y tipo). `let nombre params = cuerpo` es como programar un sistema para calcular ventas.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay registros.",
        "Si la lista está vacía, devuelve `0`, previniendo errores en la suma.",
        "Introduce la rama `else`, necesaria en OCaml para manejar el caso no vacío.",
        "Usa `List.fold_left` con `(+) 0` para sumar los resultados de `List.map`, que aplica `extractor` a las parejas filtradas por `List.filter` con `pred`. Es como sumar montos de ventas válidas.",
        "Aplica `List.map` con `extractor` (como `fst`) para extraer montos de las parejas filtradas.",
        "Aplica `List.filter` con `pred` para seleccionar parejas que cumplan la condición.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `process_sales` con un predicado, `fst` como extractora, y la lista de parejas, dando `500`.",
        "Define el predicado `(fun (m, t) -> t = \"venta\" && m > 0)`, que verifica si la pareja tiene tipo \"venta\" y monto positivo.",
        "Usa `fst` como `extractor` para obtener el monto de cada pareja.",
        "Pasa la lista de parejas `[(200, \"venta\") ...]` estructurada como tuplas en OCaml."
      ],
      "comparisons": [
        "Similitudes: Ambas procesan parejas usando `filter`, `map` y `fold` para sumar montos, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven `0` para listas vacías. Diferencias: Notación idéntica, pero Racket usa `'()` en otros contextos.",
        "Similitudes: Ambas usan un pipeline de `filter`, `map` y `fold`. Diferencias: Racket usa `(foldl + 0 ...)` prefija, OCaml usa `List.fold_left (+) 0` infija. OCaml requiere módulos `List`.",
        "Similitudes: Ambas aplican `map` con una función extractora. Diferencias: Racket usa `(map extractor ...)`, OCaml usa `List.map extractor ...`.",
        "Similitudes: Ambas filtran con un predicado personalizado. Diferencias: Racket usa `(filter pred lst)`, OCaml usa `List.filter pred lst`.",
        "Similitudes: Ambas cierran la lógica anidada. Diferencias: Racket usa paréntesis, OCaml usa indentación y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con predicado, extractora y lista idéntica, dando `500`. Diferencias: Racket usa `'(200 . \"venta\")` con notación de par, OCaml usa `(200, \"venta\")` con tuplas."
      ]
    },
    "ejercicio-7": {
      "title": "Procesar calificaciones anidadas con map, filter y fold",
      "racket": {
        "lines": [
          "(define (process-grades lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (filter (lambda (avg) (> avg 80))",
          "              (map (lambda (sublst)",
          "                     (if (empty? sublst)",
          "                         0",
          "                         (let ((approved (filter (lambda (g) (> g 70)) sublst)))",
          "                           (if (empty? approved)",
          "                               0",
          "                               (/ (foldl + 0 approved) (length approved)))",
          "                         )",
          "                     )",
          "                   lst)",
          "              )",
          "      )",
          "  )",
          ")",
          "(process-grades '((70 80 90) (60 85 95) (50 60)))"
        ]
      },
      "ocaml": {
        "lines": [
          "let process_grades lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.filter (fun avg -> avg > 80)",
          "      (List.map (fun sublst ->",
          "                   if sublst = [] then",
          "                     0",
          "                   else",
          "                     let approved = List.filter (fun g -> g > 70) sublst in",
          "                     if approved = [] then",
          "                       0",
          "                     else",
          "                       (List.fold_left (+) 0 approved) / (List.length approved)",
          "                ) lst",
          "      )",
          "in",
          "process_grades [[70; 80; 90]; [60; 85; 95]; [50; 60]]"
        ]
      },
      "explanations_racket": [
        "Define una función `process-grades` que toma una lista `lst` de sublistas (calificaciones por estudiante). `(define (nombre params) cuerpo)` es como crear un sistema para evaluar estudiantes.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay estudiantes registrados.",
        "Si la lista está vacía, devuelve `()` (lista vacía), evitando errores.",
        "Usa `filter` con `(lambda (avg) (> avg 80))` para seleccionar promedios mayores a 80, aplicados a los resultados de `map`. Es como elegir estudiantes destacados.",
        "Aplica `map` con `(lambda (sublst) ...)` a cada sublista para calcular el promedio de calificaciones aprobadas (>70).",
        "Verifica si la sublista está vacía con `(empty? sublst)`, como comprobar si un estudiante no tiene calificaciones.",
        "Si la sublista está vacía, devuelve `0` como promedio, previniendo errores.",
        "Usa `let` para almacenar las calificaciones aprobadas, filtradas con `(filter (lambda (g) (> g 70)) sublst)`, como seleccionar solo notas válidas.",
        "Verifica si no hay calificaciones aprobadas con `(empty? approved)`.",
        "Si no hay calificaciones aprobadas, devuelve `0` como promedio.",
        "Calcula el promedio dividiendo la suma de calificaciones aprobadas (`foldl + 0 approved`) por su cantidad (`length approved`). Es como promediar las notas válidas de un estudiante.",
        "Cierra la condición `if` y la función anónima de `map`.",
        "Cierra el bloque de `map` y `filter`.",
        "Cierra la condición `if` y la definición de la función.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `process-grades` con `((70 80 90) (60 85 95) (50 60))`, dando `(85 90)`, mostrando los promedios de estudiantes destacados."
      ],
      "explanations_ocaml": [
        "Define una función `process_grades` que toma una lista `lst` de sublistas. `let nombre params = cuerpo` es como programar un sistema escolar para evaluar calificaciones.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay estudiantes.",
        "Si la lista está vacía, devuelve `[]` (lista vacía), previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml para manejar el caso no vacío.",
        "Usa `List.filter` con `(fun avg -> avg > 80)` para seleccionar promedios mayores a 80, aplicados a los resultados de `List.map`.",
        "Aplica `List.map` con `(fun sublst -> ...)` para calcular el promedio de calificaciones aprobadas por estudiante.",
        "Verifica si la sublista está vacía con `sublst = []`, como revisar si un estudiante no tiene notas.",
        "Si la sublista está vacía, devuelve `0` como promedio.",
        "Introduce `else` para manejar sublistas no vacías.",
        "Usa `let approved = ...` para guardar las calificaciones aprobadas, filtradas con `List.filter (fun g -> g > 70) sublst`.",
        "Verifica si no hay calificaciones aprobadas con `approved = []`.",
        "Si no hay aprobadas, devuelve `0` como promedio.",
        "Introduce `else` para calcular el promedio.",
        "Calcula el promedio con `(List.fold_left (+) 0 approved) / (List.length approved)`, sumando las calificaciones aprobadas y dividiendo por su cantidad.",
        "Cierra la función anónima de `List.map`.",
        "Cierra el bloque de `List.map` y `List.filter`.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `process_grades` con `[[70; 80; 90]; [60; 85; 95]; [50; 60]]`, dando `[85; 90]`, mostrando los promedios destacados."
      ],
      "comparisons": [
        "Similitudes: Ambas procesan listas anidadas usando `filter`, `map` y `fold` para calcular promedios, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven una lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`.",
        "Similitudes: Ambas filtran promedios mayores a 80. Diferencias: Racket usa `(filter (lambda (avg) (> avg 80)))`, OCaml usa `List.filter (fun avg -> avg > 80)`.",
        "Similitudes: Ambas mapean sublistas para calcular promedios. Diferencias: Racket usa `(map (lambda (sublst) ...))`, OCaml usa `List.map (fun sublst -> ...)`.",
        "Similitudes: Ambas verifican si la sublista está vacía. Diferencias: Racket usa `(empty? sublst)`, OCaml usa `sublst = []`.",
        "Similitudes: Ambas devuelven `0` para sublistas vacías. Diferencias: Notación idéntica, pero contextos distintos.",
        "Similitudes: Ambas filtran calificaciones aprobadas. Diferencias: Racket usa `(let ((approved ...)))` con paréntesis, OCaml usa `let approved = ... in` más lineal.",
        "Similitudes: Ambas verifican si no hay calificaciones aprobadas. Diferencias: Racket usa `(empty? approved)`, OCaml usa `approved = []`.",
        "Similitudes: Ambas devuelven `0` si no hay calificaciones aprobadas. Diferencias: Notación idéntica.",
        "Similitudes: Ambas calculan promedios con suma y división. Diferencias: Racket usa `(foldl + 0 ...)/(length ...)`, OCaml usa `List.fold_left (+) 0 .../List.length ...`.",
        "Similitudes: Ambas cierran la lógica anidada de `map`. Diferencias: Racket usa paréntesis, OCaml usa indentación.",
        "Similitudes: Ambas cierran el bloque de `filter` y `map`. Diferencias: Racket usa paréntesis, OCaml usa paréntesis e indentación.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con listas anidadas idénticas, dando `(85 90)`. Diferencias: Racket usa `'((70 80 90) ...)`, OCaml usa `[[70; 80; 90]; ...]` con punto y coma."
      ]
    }
  },
  "tipos-datos-simples": {
    "ejercicio-1": {
      "title": "Suma de tuplas con validación",
      "racket": {
        "lines": [
          "(define (sum-tuple t)",
          "  (if (and (pair? t) (number? (car t)) (number? (cdr t)))",
          "      (+ (car t) (cdr t))",
          "      (error \"Input must be a pair of numbers\"))",
          ")",
          "(sum-tuple '(5 . 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let sum_tuple (a, b) =",
          "  if (is_int a && is_int b) || (is_float a && is_float b) then",
          "    a +. (float_of_int b)",
          "  else",
          "    failwith \"Input must be a pair of numbers\"",
          "in",
          "sum_tuple (5, 3)"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-tuple` que toma una tupla `t`. `(define (nombre params) cuerpo)` es como crear una receta para sumar dos valores, como horas trabajadas.",
        "Verifica si `t` es una tupla válida con `(pair? t)` y si ambos elementos son números con `(number? (car t))` y `(number? (cdr t))`. Es como asegurarse de que tienes un par de valores numéricos antes de sumarlos.",
        "Si la validación pasa, suma el primer elemento (`car t`) y el segundo (`cdr t`). Es como sumar las horas de dos turnos.",
        "Si la validación falla, lanza un error con un mensaje. Es como alertar que los datos no son correctos.",
        "Cierra la definición de la función con paréntesis, una regla de Racket.",
        "Llama a `sum-tuple` con la tupla `(5 . 3)`, dando `8`, como calcular el total de horas trabajadas."
      ],
      "explanations_ocaml": [
        "Define una función `sum_tuple` que toma una tupla `(a, b)`. `let nombre params = cuerpo` es como escribir una instrucción para sumar valores.",
        "Verifica si ambos elementos son enteros (`is_int`) o flotantes (`is_float`) usando `||` para permitir ambos casos. Es como confirmar que los valores son numéricos.",
        "Si son válidos, suma `a` y `b` usando `+.`, convirtiendo `b` a flotante si es necesario. Es como sumar dos cantidades en un cálculo.",
        "Si la validación falla, usa `else` para manejar el caso inválido, una regla de OCaml.",
        "Lanza un error con `failwith` si los datos no son correctos, como mostrar un mensaje de error en un sistema.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `sum_tuple` con `(5, 3)`, dando `8`, mostrando el resultado de la suma."
      ],
      "comparisons": [
        "Similitudes: Ambas suman los valores de una tupla con validación. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal.",
        "Similitudes: Ambas verifican la validez de la tupla. Diferencias: Racket usa `(pair? t)` y `(number? ...)` prefija, OCaml usa `(is_int ...)` o `(is_float ...)` infija.",
        "Similitudes: Ambas suman los elementos si son válidos. Diferencias: Racket usa `(+ (car t) (cdr t))` prefija, OCaml usa `a +. (float_of_int b)` infija con conversión a flotante.",
        "Similitudes: Ambas manejan errores para entradas inválidas. Diferencias: Racket usa `(error ...)` con paréntesis, OCaml usa `else` y `failwith`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una tupla idéntica, dando `8`. Diferencias: Racket usa `'(5 . 3)` con notación de par, OCaml usa `(5, 3)` con coma."
      ]
    },
    "ejercicio-2": {
      "title": "Extracción segura del primer elemento de una tupla",
      "racket": {
        "lines": [
          "(define (first-of-tuple t)",
          "  (if (pair? t)",
          "      (car t)",
          "      (error \"Input must be a pair\"))",
          ")",
          "(first-of-tuple '(7 . 8))"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_of_tuple (a, _) =",
          "  a",
          "in",
          "first_of_tuple (7, 8)"
        ]
      },
      "explanations_racket": [
        "Define una función `first-of-tuple` que toma una tupla `t`. `(define (nombre params) cuerpo)` es como crear una regla para obtener la primera coordenada.",
        "Verifica si `t` es una tupla válida con `(pair? t)`, como asegurarse de que tienes un par de valores.",
        "Si es válida, extrae el primer elemento con `(car t)`, como tomar la primera coordenada de un punto.",
        "Si no es válida, lanza un error con un mensaje, como alertar que los datos no son correctos.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `first-of-tuple` con `(7 . 8)`, dando `7`, como obtener la coordenada x."
      ],
      "explanations_ocaml": [
        "Define una función `first_of_tuple` que toma una tupla `(a, _)`. `let nombre params = cuerpo` es como escribir una instrucción para extraer el primer valor. El `_` ignora el segundo valor.",
        "Devuelve `a`, el primer elemento de la tupla, como tomar la primera coordenada directamente.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `first_of_tuple` con `(7, 8)`, dando `7`, mostrando la coordenada extraída."
      ],
      "comparisons": [
        "Similitudes: Ambas extraen el primer elemento de una tupla. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas acceden al primer elemento. Diferencias: Racket usa `(car t)` con validación `(pair? t)`, OCaml usa `(a, _)` sin validación explícita, confiando en el tipado.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket usa `(error ...)` para casos inválidos, OCaml no valida explícitamente y usa `in`.",
        "Similitudes: Ambas llaman la función con una tupla idéntica, dando `7`. Diferencias: Racket usa `'(7 . 8)`, OCaml usa `(7, 8)`."
      ]
    },
    "ejercicio-3": {
      "title": "Extracción de edad de un registro personalizado",
      "racket": {
        "lines": [
          "(struct person (name age))",
          "(define (get-age p)",
          "  (if (and (person? p) (number? (person-age p)) (> (person-age p) 0))",
          "      (person-age p)",
          "      (error \"Invalid person or age\"))",
          ")",
          "(get-age (person \"Ana\" 20))"
        ]
      },
      "ocaml": {
        "lines": [
          "type person = { name: string; age: int }",
          "let get_age p =",
          "  if p.age > 0 then",
          "    p.age",
          "  else",
          "    failwith \"Age must be positive\"",
          "in",
          "get_age { name = \"Ana\"; age = 20 }"
        ]
      },
      "explanations_racket": [
        "Crea una estructura `person` con campos `name` y `age`. `(struct nombre (campos))` es como definir una plantilla para datos de personas.",
        "Define una función `get-age` que toma un registro `p`, como una regla para obtener la edad.",
        "Verifica si `p` es un registro `person` con `(person? p)`, si `age` es un número con `(number? (person-age p))` y si es positivo con `(> (person-age p) 0)`. Es como confirmar que los datos son válidos.",
        "Si la validación pasa, devuelve la edad con `(person-age p)`, como extraer la edad de un formulario.",
        "Si falla, lanza un error con un mensaje, como alertar que el registro es incorrecto.",
        "Cierra la definición de la función.",
        "Llama a `get-age` con un registro `(person \"Ana\" 20)`, dando `20`, como obtener la edad de Ana."
      ],
      "explanations_ocaml": [
        "Define un tipo `person` con campos `name` (cadena) y `age` (entero). `type nombre = { campos }` es como crear una plantilla para personas.",
        "Define una función `get_age` que toma un registro `p`, como una instrucción para extraer la edad.",
        "Verifica si la edad es positiva con `p.age > 0`, como asegurarse de que la edad es válida.",
        "Si es válida, devuelve `p.age`, como tomar la edad de un registro.",
        "Si no es válida, lanza un error con `failwith`, como mostrar un mensaje de error.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `get_age` con `{ name = \"Ana\"; age = 20 }`, dando `20`, mostrando la edad de Ana."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una estructura para personas y extraen la edad. Diferencias: Racket usa `(struct nombre (campos))`, OCaml usa `type nombre = { campos }`.",
        "Similitudes: Ambas funciones toman un registro para extraer la edad. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican la validez de la edad. Diferencias: Racket usa `(and (person? p) ...)` prefija, OCaml usa `p.age > 0` infija con menos validaciones explícitas.",
        "Similitudes: Ambas devuelven la edad si es válida. Diferencias: Racket usa `(person-age p)`, OCaml usa `p.age`.",
        "Similitudes: Ambas manejan errores. Diferencias: Racket usa `(error ...)`, OCaml usa `else` y `failwith`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con un registro idéntico, dando `20`. Diferencias: Racket usa `(person \"Ana\" 20)`, OCaml usa `{ name = \"Ana\"; age = 20 }`."
      ]
    },
    "ejercicio-4": {
      "title": "Cálculo del volumen de una caja con tupla triple",
      "racket": {
        "lines": [
          "(define (product-triple t)",
          "  (if (and (list? t) (= (length t) 3)",
          "           (andmap number? t) (andmap positive? t))",
          "      (* (car t) (cadr t) (caddr t))",
          "      (error \"Input must be a list of three positive numbers\"))",
          ")",
          "(product-triple '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let product_triple (a, b, c) =",
          "  if a > 0 && b > 0 && c > 0 then",
          "    a * b * c",
          "  else",
          "    failwith \"Dimensions must be positive\"",
          "in",
          "product_triple (2, 3, 4)"
        ]
      },
      "explanations_racket": [
        "Define una función `product-triple` que toma una lista `t` (como dimensiones de una caja). `(define (nombre params) cuerpo)` es como crear una regla para calcular el volumen.",
        "Verifica si `t` es una lista de 3 elementos con `(list? t)` y `(= (length t) 3)`, y si todos son números positivos con `(andmap number? t)` y `(andmap positive? t)`. Es como confirmar que las dimensiones son válidas.",
        "Si la validación pasa, multiplica los elementos con `(car t)`, `(cadr t)`, `(caddr t)`, como calcular largo × ancho × alto.",
        "Si falla, lanza un error con un mensaje, como alertar que las dimensiones no son correctas.",
        "Cierra la definición de la función.",
        "Llama a `product-triple` con `(2 3 4)`, dando `24`, como calcular el volumen de la caja."
      ],
      "explanations_ocaml": [
        "Define una función `product_triple` que toma una tupla `(a, b, c)`. `let nombre params = cuerpo` es como escribir una instrucción para calcular el volumen.",
        "Verifica si todos los elementos son positivos con `a > 0 && b > 0 && c > 0`, como asegurarse de que las dimensiones son válidas.",
        "Si son válidos, multiplica `a * b * c`, como calcular el volumen de una caja.",
        "Si no son válidos, lanza un error con `failwith`, como mostrar un mensaje de error.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `product_triple` con `(2, 3, 4)`, dando `24`, mostrando el volumen."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan el producto de una tupla triple con validación. Diferencias: Racket usa `(define (nombre params) cuerpo)` y trata la tupla como lista, OCaml usa `let nombre params = cuerpo` con tupla explícita.",
        "Similitudes: Ambas verifican la validez de los datos. Diferencias: Racket usa `(and (list? t) ...)` prefija, OCaml usa `a > 0 && ...` infija, más directa.",
        "Similitudes: Ambas multiplican los elementos si son válidos. Diferencias: Racket usa `(car t) (cadr t) (caddr t)` prefija, OCaml usa `a * b * c` infija.",
        "Similitudes: Ambas manejan errores. Diferencias: Racket usa `(error ...)`, OCaml usa `else` y `failwith`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con datos idénticos, dando `24`. Diferencias: Racket usa `'(2 3 4)` como lista, OCaml usa `(2, 3, 4)` como tupla."
      ]
    },
    "ejercicio-5": {
      "title": "Comparación robusta de tuplas",
      "racket": {
        "lines": [
          "(define (equal-tuples? t1 t2)",
          "  (if (and (pair? t1) (pair? t2)",
          "           (number? (car t1)) (number? (cdr t1))",
          "           (number? (car t2)) (number? (cdr t2)))",
          "      (and (= (car t1) (car t2)) (= (cdr t1) (cdr t2)))",
          "      (error \"Inputs must be pairs of numbers\"))",
          ")",
          "(equal-tuples? '(1 . 2) '(1 . 2))"
        ]
      },
      "ocaml": {
        "lines": [
          "let equal_tuples (a1, b1) (a2, b2) =",
          "  if (is_int a1 && is_int b1 && is_int a2 && is_int b2) ||",
          "     (is_float a1 && is_float b1 && is_float a2 && is_float b2) then",
          "    a1 = a2 && b1 = b2",
          "  else",
          "    failwith \"Inputs must be pairs of numbers\"",
          "in",
          "equal_tuples (1, 2) (1, 2)"
        ]
      },
      "explanations_racket": [
        "Define una función `equal-tuples?` que toma dos tuplas `t1` y `t2`. `(define (nombre params) cuerpo)` es como crear una regla para comparar coordenadas.",
        "Verifica si ambas entradas son tuplas con `(pair? t1)` y `(pair? t2)`, y si todos los elementos son números con `(number? ...)`. Es como confirmar que ambas son coordenadas válidas.",
        "Verifica los primeros elementos de ambas tuplas y los segundos, continuando la validación.",
        "Si la validación pasa, compara los elementos con `(= (car t1) (car t2))` y `(= (cdr t1) (cdr t2))`, como verificar si dos puntos son iguales.",
        "Si falla, lanza un error con un mensaje, como alertar que las entradas no son válidas.",
        "Cierra la definición de la función.",
        "Llama a `equal-tuples?` con `(1 . 2)` y `(1 . 2)`, dando `true`, como confirmar que las coordenadas son idénticas."
      ],
      "explanations_ocaml": [
        "Define una función `equal_tuples` que toma dos tuplas `(a1, b1)` y `(a2, b2)`. `let nombre params = cuerpo` es como escribir una instrucción para comparar valores.",
        "Verifica si todos los elementos son enteros o flotantes con `(is_int ...)` o `(is_float ...)`, como asegurarse de que las coordenadas son numéricas.",
        "Continúa la validación con `||` para permitir flotantes, completando la condición.",
        "Si son válidos, compara `a1 = a2` y `b1 = b2`, como verificar si dos puntos coinciden.",
        "Si no son válidos, lanza un error con `failwith`, como mostrar un mensaje de error.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `equal_tuples` con `(1, 2)` y `(1, 2)`, dando `true`, mostrando que las tuplas son iguales."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan dos tuplas con validación. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican la validez de las tuplas. Diferencias: Racket usa `(pair? ...)` y `(number? ...)` prefija, OCaml usa `(is_int ...)` o `(is_float ...)` infija.",
        "Similitudes: Ambas continúan la validación. Diferencias: Racket distribuye la validación en varias líneas, OCaml usa una condición más larga con `||`.",
        "Similitudes: Ambas comparan elementos si son válidos. Diferencias: Racket usa `(and (= ...))` prefija, OCaml usa `a1 = a2 && b1 = b2` infija.",
        "Similitudes: Ambas manejan errores. Diferencias: Racket usa `(error ...)`, OCaml usa `else` y `failwith`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con tuplas idénticas, dando `true`. Diferencias: Racket usa `'(1 . 2)`, OCaml usa `(1, 2)`."
      ]
    },
    "ejercicio-6": {
      "title": "Extracción avanzada de nombre de un registro",
      "racket": {
        "lines": [
          "(struct person (name age city))",
          "(define (get-name p)",
          "  (if (and (person? p) (string? (person-name p)) (not (string=? (person-name p) \"\")))",
          "      (person-name p)",
          "      (error \"Invalid person or empty name\"))",
          ")",
          "(get-name (person \"Bob\" 25 \"Paris\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "type person = { name: string; age: int; city: string }",
          "let get_name p =",
          "  if p.name <> \"\" then",
          "    p.name",
          "  else",
          "    failwith \"Name must not be empty\"",
          "in",
          "get_name { name = \"Bob\"; age = 25; city = \"Paris\" }"
        ]
      },
      "explanations_racket": [
        "Crea una estructura `person` con campos `name`, `age` y `city`. `(struct nombre (campos))` es como definir una plantilla para datos de personas con más detalles.",
        "Define una función `get-name` que toma un registro `p`, como una regla para extraer el nombre.",
        "Verifica si `p` es un registro `person`, si `name` es una cadena y no está vacía con `(not (string=? (person-name p) \"\"))`. Es como confirmar que el registro es válido y tiene un nombre.",
        "Si la validación pasa, devuelve el nombre con `(person-name p)`, como tomar el nombre de un censo.",
        "Si falla, lanza un error con un mensaje, como alertar que el registro o nombre es incorrecto.",
        "Cierra la definición de la función.",
        "Llama a `get-name` con `(person \"Bob\" 25 \"Paris\")`, dando `Bob`, como extraer el nombre del registro."
      ],
      "explanations_ocaml": [
        "Define un tipo `person` con campos `name`, `age` y `city`. `type nombre = { campos }` es como crear una plantilla para datos de personas.",
        "Define una función `get_name` que toma un registro `p`, como una instrucción para obtener el nombre.",
        "Verifica si el nombre no está vacío con `p.name <> \"\"`, como asegurarse de que el registro tiene un nombre válido.",
        "Si es válido, devuelve `p.name`, como extraer el nombre de un formulario.",
        "Si no es válido, lanza un error con `failwith`, como mostrar un mensaje de error.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `get_name` con `{ name = \"Bob\"; age = 25; city = \"Paris\" }`, dando `Bob`, mostrando el nombre."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una estructura para personas y extraen el nombre con validación. Diferencias: Racket usa `(struct nombre (campos))`, OCaml usa `type nombre = { campos }`.",
        "Similitudes: Ambas funciones toman un registro para extraer el nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican la validez del nombre. Diferencias: Racket usa `(and (person? p) ...)` prefija, OCaml usa `p.name <> \"\"` infija con menos validaciones.",
        "Similitudes: Ambas devuelven el nombre si es válido. Diferencias: Racket usa `(person-name p)`, OCaml usa `p.name`.",
        "Similitudes: Ambas manejan errores. Diferencias: Racket usa `(error ...)`, OCaml usa `else` y `failwith`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con un registro idéntico, dando `Bob`. Diferencias: Racket usa `(person \"Bob\" 25 \"Paris\")`, OCaml usa `{ name = \"Bob\"; age = 25; city = \"Paris\" }`."
      ]
    },
    "ejercicio-7": {
      "title": "Construcción y procesamiento de registros anidados",
      "racket": {
        "lines": [
          "(struct student (name age grades))",
          "(define (student-info name age grades)",
          "  (if (and (string? name) (not (string=? name \"\"))",
          "           (number? age) (> age 0)",
          "           (list? grades) (not (empty? grades)) (andmap positive? grades))",
          "      (let ((s (student name age grades)))",
          "        (cons (student-name s)",
          "              (/ (foldl + 0 grades) (length grades))))",
          "      (error \"Invalid input: name, age, or grades\"))",
          ")",
          "(student-info \"Carlos\" 22 '(90 85))"
        ]
      },
      "ocaml": {
        "lines": [
          "type student = { name: string; age: int; grades: int list }",
          "let student_info name age grades =",
          "  if name <> \"\" && age > 0 && grades <> [] &&",
          "     List.for_all (fun x -> x > 0) grades then",
          "    let s = { name; age; grades } in",
          "    (s.name, (List.fold_left (+) 0 grades) / (List.length grades))",
          "  else",
          "    failwith \"Invalid input: name, age, or grades\"",
          "in",
          "student_info \"Carlos\" 22 [90; 85]"
        ]
      },
      "explanations_racket": [
        "Crea una estructura `student` con campos `name`, `age` y `grades`. `(struct nombre (campos))` es como definir una plantilla para datos de estudiantes.",
        "Define una función `student-info` que toma `name`, `age` y `grades`, como una regla para crear un registro y calcular un promedio.",
        "Verifica si `name` es una cadena no vacía, `age` es un número positivo, y `grades` es una lista no vacía de números positivos. Es como confirmar que todos los datos del estudiante son válidos.",
        "Continúa la validación, asegurando que `age` y `grades` cumplen los requisitos.",
        "Continúa la validación, comprobando que las notas son positivas con `(andmap positive? grades)`.",
        "Si la validación pasa, crea un registro `s` con `(student name age grades)` usando `let`, como guardar los datos del estudiante.",
        "Crea una tupla con `(cons (student-name s) ...)` para el nombre y el promedio de notas, calculado con `(foldl + 0 grades)` y `(length grades)`. Es como devolver el nombre y la nota promedio.",
        "Si la validación falla, lanza un error con un mensaje, como alertar que los datos no son correctos.",
        "Cierra la definición de la función.",
        "Llama a `student-info` con `\"Carlos\"`, `22` y `(90 85)`, dando `(Carlos 87)`, como mostrar el nombre y promedio del estudiante."
      ],
      "explanations_ocaml": [
        "Define un tipo `student` con campos `name`, `age` y `grades`. `type nombre = { campos }` es como crear una plantilla para estudiantes.",
        "Define una función `student_info` que toma `name`, `age` y `grades`, como una instrucción para crear un registro y calcular el promedio.",
        "Verifica si `name` no está vacío, `age` es positivo, `grades` no está vacía y todas las notas son positivas con `List.for_all`. Es como asegurarse de que los datos son válidos.",
        "Continúa la validación, combinando todas las condiciones con `&&`.",
        "Si la validación pasa, crea un registro `s` con `{ name; age; grades }` usando `let`, como almacenar los datos del estudiante.",
        "Devuelve una tupla `(s.name, ...)` con el nombre y el promedio, calculado con `List.fold_left (+) 0 grades` y `List.length grades`. Es como mostrar el nombre y la nota promedio.",
        "Si la validación falla, lanza un error con `failwith`, como mostrar un mensaje de error.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `student_info` con `\"Carlos\"`, `22` y `[90; 85]`, dando `(Carlos, 87)`, mostrando el resultado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una estructura para estudiantes y crean una tupla con nombre y promedio. Diferencias: Racket usa `(struct nombre (campos))`, OCaml usa `type nombre = { campos }`.",
        "Similitudes: Ambas funciones toman nombre, edad y notas. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican la validez de los datos. Diferencias: Racket usa `(and (string? name) ...)` prefija, OCaml usa `name <> \"\" && ...` infija.",
        "Similitudes: Ambas continúan la validación. Diferencias: Racket distribuye la validación en varias líneas, OCaml usa una condición compacta.",
        "Similitudes: Ambas validan las notas. Diferencias: Racket usa `(andmap positive? grades)`, OCaml usa `List.for_all (fun x -> x > 0) grades`.",
        "Similitudes: Ambas crean un registro si los datos son válidos. Diferencias: Racket usa `(let ((s ...)))`, OCaml usa `let s = ... in`.",
        "Similitudes: Ambas devuelven una tupla con nombre y promedio. Diferencias: Racket usa `(cons (student-name s) ...)` prefija, OCaml usa `(s.name, ...)` infija con módulos `List`.",
        "Similitudes: Ambas manejan errores. Diferencias: Racket usa `(error ...)`, OCaml usa `else` y `failwith`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con datos idénticos, dando `(Carlos 87)`. Diferencias: Racket usa `'()` para listas y `(cons ...)` para tuplas, OCaml usa `[]` y `(,)`."
      ]
    }
  },
  "cadenas-y-caracteres": {
    "ejercicio-1": {
      "title": "Longitud de una cadena",
      "racket": {
        "lines": [
          "(define (string-length str)",
          "  (string-length str)",
          ")",
          "(string-length \"admin\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let string_length str =",
          "  String.length str",
          "in",
          "string_length \"admin\""
        ]
      },
      "explanations_racket": [
        "Define una función `string-length` que toma un parámetro `str` para calcular la longitud de una cadena. La sintaxis `(define (nombre params) cuerpo)` es estándar en Racket, promoviendo abstracción funcional, como crear una herramienta reusable para contar caracteres, similar a medir la longitud de una cinta.",
        "Usa `string-length` (función primitiva de Racket) para retornar la longitud de `str`. La expresión es pura, siempre da el mismo resultado para la misma cadena, alineándose con el paradigma funcional, como contar las letras en un nombre sin cambiarlo.",
        "Cierra la definición de la función con un paréntesis, una convención estructural de Racket necesaria para completar la sintaxis.",
        "Llama a `string-length` con \"admin\", evaluando la longitud como 5, mostrando cómo usar la función para validar un usuario, como comprobar si un nombre de usuario tiene la longitud correcta."
      ],
      "explanations_ocaml": [
        "Define una función `string_length` con un parámetro `str` para calcular la longitud, usando `let nombre params = cuerpo`. En OCaml, las funciones son puras e inmutables, ideales para abstracción, como una herramienta para medir el tamaño de un texto, similar a contar palabras en una frase.",
        "Usa `String.length` (función del módulo `String`) para retornar la longitud de `str`. La expresión es pura, garantizando consistencia, como medir un mensaje sin alterarlo.",
        "Usa `in` para introducir el contexto de la llamada, una característica estructural de OCaml que separa la definición de su uso, sin lógica propia.",
        "Llama a `string_length` con \"admin\", dando 5, demostrando la función en un contexto práctico, como validar la longitud de una contraseña."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular la longitud de una cadena, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere que `str` es cadena, Racket es dinámico.",
        "Similitudes: Ambas usan una función primitiva para calcular longitud, manteniendo pureza. Diferencias: Racket usa `string-length` prefija, OCaml usa `String.length` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"admin\", dando 5. Diferencias: Racket usa `(string-length \"admin\")`, OCaml usa `string_length \"admin\"`, más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Concatenar cadenas",
      "racket": {
        "lines": [
          "(define (concat-strings s1 s2)",
          "  (string-append s1 \" \" s2)",
          ")",
          "(concat-strings \"hola\" \"mundo\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let concat_strings s1 s2 =",
          "  s1 ^ \" \" ^ s2",
          "in",
          "concat_strings \"hola\" \"mundo\""
        ]
      },
      "explanations_racket": [
        "Define una función `concat-strings` que toma dos parámetros, `s1` y `s2`, para unir cadenas. La sintaxis `(define (nombre params) cuerpo)` es funcional, como crear un mensaje combinando palabras.",
        "Usa `string-append` para unir `s1`, un espacio, y `s2`, en notación prefija. La expresión es pura, como formar \"hola mundo\" sin alterar las palabras originales.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `concat-strings` con \"hola\" y \"mundo\", dando \"hola mundo\", mostrando cómo generar un saludo completo."
      ],
      "explanations_ocaml": [
        "Define una función `concat_strings` con dos parámetros para unir cadenas, usando `let nombre params = cuerpo`. Es funcional, como combinar textos en un documento.",
        "Usa el operador `^` para unir `s1`, un espacio, y `s2`, en notación infija. La expresión es pura, como formar un mensaje sin cambiar las partes.",
        "Usa `in` para introducir la llamada, una característica de OCaml.",
        "Llama a `concat_strings` con \"hola\" y \"mundo\", dando \"hola mundo\", demostrando la unión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para unir cadenas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas unen cadenas con un espacio, manteniendo pureza. Diferencias: Racket usa `string-append` prefija, OCaml usa `^` infijo, más conciso.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"hola\" y \"mundo\", dando \"hola mundo\". Diferencias: Racket usa `(concat-strings \"hola\" \"mundo\")`, OCaml usa `concat_strings \"hola\" \"mundo\"`."
      ]
    },
    "ejercicio-3": {
      "title": "Obtener primer carácter de cadena",
      "racket": {
        "lines": [
          "(define (first-char str)",
          "  (string-ref str 0)",
          ")",
          "(first-char \"gato\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_char str =",
          "  if str = \"\" then",
          "    None",
          "  else",
          "    Some (String.get str 0)",
          "in",
          "first_char \"gato\""
        ]
      },
      "explanations_racket": [
        "Define una función `first-char` para obtener el primer carácter de una cadena `str`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como extraer la inicial de una palabra para un monograma.",
        "Usa `string-ref` para acceder al carácter en posición 0 de `str`, en notación prefija. La expresión es pura, como leer la primera letra sin cambiar la palabra.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `first-char` con \"gato\", retornando #\\g, mostrando la extracción."
      ],
      "explanations_ocaml": [
        "Define una función `first_char` para obtener el primer carácter, usando `let nombre params = cuerpo`. Es funcional, como seleccionar la inicial de un nombre.",
        "Inicia un condicional `if` con `str = \"\"`, verificando si la cadena está vacía, una expresión pura para el caso base.",
        "Si la cadena está vacía, retorna `None`, usando el tipo `option` para indicar ausencia, como no hay inicial si no hay nombre.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar cadenas no vacías.",
        "Retorna `Some (String.get str 0)`, envolviendo el primer carácter en `Some`, como confirmar que hay una inicial disponible.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `first_char` con \"gato\", dando `Some 'g'`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para obtener el primer carácter, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml maneja vacía con `option`.",
        "Similitudes: Ambas acceden al primer carácter con pureza. Diferencias: Racket usa `string-ref` prefija, OCaml usa `String.get` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket no maneja vacío, OCaml usa `if` para vacía, aumentando líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"gato\", dando 'g'. Diferencias: Racket retorna #\\g, OCaml Some 'g'."
      ]
    },
    "ejercicio-4": {
      "title": "Convertir cadena a mayúsculas",
      "racket": {
        "lines": [
          "(define (to-upper str)",
          "  (string-upcase str)",
          ")",
          "(to-upper \"welcome\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let to_upper str =",
          "  String.uppercase_ascii str",
          "in",
          "to_upper \"welcome\""
        ]
      },
      "explanations_racket": [
        "Define una función `to-upper` para convertir una cadena a mayúsculas. La sintaxis `(define (nombre params) cuerpo)` es funcional, como transformar un cartel a letras grandes.",
        "Usa `string-upcase` para retornar la cadena en mayúsculas, en notación prefija. La expresión es pura, como gritar un mensaje sin cambiar el original.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `to-upper` con \"welcome\", retornando \"WELCOME\", mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `to_upper` para convertir a mayúsculas, usando `let nombre params = cuerpo`. Es funcional, como hacer un letrero en letras grandes.",
        "Usa `String.uppercase_ascii` para retornar la cadena en mayúsculas, en notación infija. La expresión es pura, específica para ASCII.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `to_upper` con \"welcome\", retornando \"WELCOME\", demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para convertir cadenas a mayúsculas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función primitiva para mayúsculas, manteniendo pureza. Diferencias: Racket usa `string-upcase` prefija, OCaml usa `String.uppercase_ascii` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"welcome\", dando \"WELCOME\". Diferencias: Racket usa `(to-upper \"welcome\")`, OCaml usa `to_upper \"welcome\"`."
      ]
    },
    "ejercicio-5": {
      "title": "Verificar si una cadena está vacía",
      "racket": {
        "lines": [
          "(define (empty-string? str)",
          "  (string=? str \"\")",
          ")",
          "(empty-string? \"\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let empty_string str =",
          "  str = \"\"",
          "in",
          "empty_string \"\""
        ]
      },
      "explanations_racket": [
        "Define una función `empty-string?` para verificar si una cadena `str` está vacía. La sintaxis `(define (nombre params) cuerpo)` es funcional, como comprobar si un formulario tiene texto.",
        "Usa `string=?` para comparar `str` con \"\", retornando #t si es vacía. La expresión es pura, como validar un campo vacío.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `empty-string?` con \"\", dando #t, mostrando la verificación."
      ],
      "explanations_ocaml": [
        "Define una función `empty_string` para verificar si una cadena está vacía, usando `let nombre params = cuerpo`. Es funcional, como validar un campo en un formulario.",
        "Compara `str` con \"\" usando `=`, retornando `true` si es vacía. La expresión es pura, como confirmar un texto vacío.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `empty_string` con \"\", dando `true`, demostrando la verificación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si una cadena está vacía, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas comparan con cadena vacía, con pureza. Diferencias: Racket usa `string=?` prefija, OCaml usa `=` infija, más concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"\", dando verdadero. Diferencias: Racket usa `(empty-string? \"\")`, OCaml usa `empty_string \"\"`."
      ]
    },
    "ejercicio-6": {
      "title": "Extraer subcadena",
      "racket": {
        "lines": [
          "(define (substring-from str start len)",
          "  (substring str start (+ start len))",
          ")",
          "(substring-from \"python\" 1 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let substring_from str start len =",
          "  String.sub str start len",
          "in",
          "substring_from \"python\" 1 3"
        ]
      },
      "explanations_racket": [
        "Define una función `substring-from` para extraer una subcadena desde `start` con longitud `len`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como cortar un trozo de una cuerda.",
        "Usa `substring` para retornar el segmento de `str` desde `start` hasta `start + len`. La expresión es pura, como extraer 'yth' de \"python\" sin alterar la cadena original.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `substring-from` con \"python\", 1, 3, dando \"yth\", mostrando la extracción."
      ],
      "explanations_ocaml": [
        "Define una función `substring_from` para extraer una subcadena, usando `let nombre params = cuerpo`. Es funcional, como recortar un fragmento de un texto.",
        "Usa `String.sub` para retornar el segmento de `str` desde `start` con `len`. La expresión es pura, como obtener 'yth' de \"python\" sin cambiar la cadena.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `substring_from` con \"python\", 1, 3, dando \"yth\", demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para extraer una subcadena, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función primitiva para subcadena, con pureza. Diferencias: Racket usa `substring` prefija con `(+ start len)`, OCaml usa `String.sub` infija, más modular y concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"python\", 1, 3, dando \"yth\". Diferencias: Racket usa `(substring-from \"python\" 1 3)`, OCaml usa `substring_from \"python\" 1 3`."
      ]
    },
    "ejercicio-7": {
      "title": "Contar vocales en una cadena",
      "racket": {
        "lines": [
          "(define (count-vowels str)",
          "  (length",
          "    (filter (lambda (c)",
          "              (member c '(#\\a #\\e #\\i #\\o #\\u)))",
          "            (string->list str)))",
          ")",
          "(count-vowels \"hello\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let count_vowels str =",
          "  String.fold_left",
          "    (fun acc c ->",
          "       if List.mem c ['a'; 'e'; 'i'; 'o'; 'u'] then",
          "         acc + 1",
          "       else",
          "         acc",
          "    ) 0 str",
          "in",
          "count_vowels \"hello\""
        ]
      },
      "explanations_racket": [
        "Define una función `count-vowels` para contar vocales en una cadena `str`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un juego que cuenta vocales para puntuar palabras.",
        "Usa `length` para contar elementos en la lista filtrada, una expresión pura para obtener el total de vocales.",
        "Usa `filter` con `lambda` para seleccionar caracteres vocales. `lambda` es una función anónima, como un juez que decide si una letra es vocal.",
        "Verifica si `c` está en la lista de vocales con `member`, en notación prefija. Es pura, como identificar vocales en \"hello\".",
        "Convierte `str` a lista de caracteres con `string->list`, preparando la cadena para filtrado, como descomponer una palabra en letras.",
        "Cierra los bloques de `filter` y `length`, necesario para la sintaxis de Racket.",
        "Llama a `count-vowels` con \"hello\", contando 2 vocales (e, o), mostrando el procesamiento."
      ],
      "explanations_ocaml": [
        "Define una función `count_vowels` para contar vocales en una cadena, usando `let nombre params = cuerpo`. Es funcional, como un juego que puntúa palabras por vocales.",
        "Usa `String.fold_left` para acumular un conteo, reduciendo la cadena a un número. `fold_left` es una función de alto orden pura, como un contador que suma por cada vocal.",
        "Usa `fun` para definir una función anónima que toma acumulador `acc` y carácter `c`. `fun` es como una regla para cada letra.",
        "Inicia un condicional `if` para verificar si `c` es vocal usando `List.mem`, en notación infija, una expresión pura.",
        "Si `c` es vocal, suma 1 a `acc`, incrementando el conteo, como puntuar una letra vocal.",
        "Introduce `else` para caracteres no vocales, retornando `acc` sin cambio, necesaria en OCaml.",
        "Retorna `acc` si no es vocal, completando la función anónima.",
        "Inicializa el acumulador en 0 y aplica a `str`, reduciendo la cadena.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `count_vowels` con \"hello\", contando 2 vocales (e, o), demostrando el procesamiento."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para contar vocales, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa `String.fold_left`, Racket usa `filter` + `length`.",
        "Similitudes: Ambas usan alto orden para procesar la cadena, con pureza. Diferencias: Racket usa `length` para contar filtrados, OCaml usa `fold_left` para acumular, más eficiente para conteo.",
        "Similitudes: Ambas usan función anónima para verificar vocales. Diferencias: Racket usa `lambda` prefija, OCaml usa `fun` infija con ->.",
        "Similitudes: Ambas verifican si el carácter es vocal. Diferencias: Racket usa `member` prefija, OCaml usa `List.mem` infija, más modular.",
        "Similitudes: Ambas usan listas de vocales. Diferencias: Racket usa caracteres `#\\a`, OCaml usa `'a'`, con `List.mem`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra bloques, OCaml cierra `else`.",
        "Similitudes: Ambas convierten cadena a procesable. Diferencias: Racket usa `string->list` prefija, OCaml usa `fold_left` directo sobre cadena.",
        "Similitudes: Ambas llaman la función con \"hello\", dando 2. Diferencias: Racket usa `(count-vowels \"hello\")`, OCaml usa `count_vowels \"hello\"`."
      ]
    }
  },
  "composicion-de-funciones": {
    "ejercicio-1": {
      "title": "Componer suma y cuadrado",
      "racket": {
        "lines": [
          "(define (compose-square-plus-one x)",
          "  ((compose (lambda (x) (* x x))",
          "            (lambda (x) (+ x 1)))",
          "   x",
          "  )",
          ")",
          "(compose-square-plus-one 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_square_plus_one x =",
          "  (fun x -> x * x)",
          "  ((fun x -> x + 1) x)",
          "in",
          "compose_square_plus_one 5"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-square-plus-one` que toma un número `x` y aplica composición. La sintaxis `(define (nombre params) cuerpo)` es funcional, como procesar una edad sumando 1 y elevando al cuadrado para un análisis demográfico.",
        "Usa `compose` para combinar `(lambda (x) (* x x))` (elevar al cuadrado) con `(lambda (x) (+ x 1))` (sumar 1). `compose` aplica la segunda función primero, luego la primera, en notación prefija, pura y sin efectos secundarios.",
        "Completa la composición, especificando que ambas funciones se encadenan, como calcular (x+1)^2 en un solo paso.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-square-plus-one` con `5`, evaluando (5+1)^2 = 6^2 = 36, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_square_plus_one` para combinar suma y cuadrado, usando `let nombre params = cuerpo`. Es funcional, como procesar una edad para un demógrafo.",
        "Define `(fun x -> x * x)` para elevar al cuadrado, aplicada al resultado de la función interna. La expresión es pura, como calcular el cuadrado en un pipeline.",
        "Aplica `(fun x -> x + 1)` a `x` primero, sumando 1, luego pasa el resultado al cuadrado, en notación infija, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `compose_square_plus_one` con `5`, evaluando (5+1)^2 = 36, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer suma y cuadrado, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con composición manual.",
        "Similitudes: Ambas aplican el cuadrado después de sumar 1, con pureza. Diferencias: Racket usa `(lambda (x) (* x x))` prefija con `compose`, OCaml usa `(fun x -> x * x)` infija, aplicada directamente.",
        "Similitudes: Ambas encadenan funciones para transformar `x`. Diferencias: Racket usa `compose` explícitamente, OCaml anida funciones manualmente, reflejando su enfoque más explícito.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada para `x`, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `5`, dando `36`. Diferencias: Racket usa `(compose-square-plus-one 5)`, OCaml usa `compose_square_plus_one 5`."
      ]
    },
    "ejercicio-2": {
      "title": "Componer resta y duplicación",
      "racket": {
        "lines": [
          "(define (compose-double-minus-three x)",
          "  ((compose (lambda (x) (* x 2))",
          "            (lambda (x) (- x 3)))",
          "   x",
          "  )",
          ")",
          "(compose-double-minus-three 10)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_double_minus_three x =",
          "  (fun x -> x * 2)",
          "  ((fun x -> x - 3) x)",
          "in",
          "compose_double_minus_three 10"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-double-minus-three` que toma un número `x` y aplica composición. La sintaxis `(define (nombre params) cuerpo)` es funcional, como ajustar un salario restando 3 y duplicando.",
        "Usa `compose` para combinar `(lambda (x) (* x 2))` (duplicar) con `(lambda (x) (- x 3))` (restar 3). `compose` aplica la resta primero, luego duplica, en notación prefija, pura.",
        "Completa la composición, encadenando ambas funciones, como calcular (x-3)*2.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-double-minus-three` con `10`, evaluando (10-3)*2 = 7*2 = 14, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_double_minus_three` para combinar resta y duplicación, usando `let nombre params = cuerpo`. Es funcional, como ajustar un salario en un sistema.",
        "Define `(fun x -> x * 2)` para duplicar, aplicada al resultado de la resta. La expresión es pura, como un cálculo en un pipeline.",
        "Aplica `(fun x -> x - 3)` a `x` primero, restando 3, luego pasa el resultado a duplicar, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_double_minus_three` con `10`, evaluando (10-3)*2 = 14, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer resta y duplicación, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con composición manual.",
        "Similitudes: Ambas aplican duplicar después de restar 3, con pureza. Diferencias: Racket usa `(lambda (x) (* x 2))` prefija, OCaml usa `(fun x -> x * 2)` infija.",
        "Similitudes: Ambas encadenan funciones. Diferencias: Racket usa `compose`, OCaml anida funciones manualmente.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `10`, dando `14`. Diferencias: Racket usa `(compose-double-minus-three 10)`, OCaml usa `compose_double_minus_three 10`."
      ]
    },
    "ejercicio-3": {
      "title": "Composición múltiple: duplicar, sumar 1, elevar al cuadrado",
      "racket": {
        "lines": [
          "(define (compose-three x)",
          "  ((compose (lambda (x) (* x x))",
          "            (compose (lambda (x) (+ x 1))",
          "                     (lambda (x) (* x 2))))",
          "   x",
          "  )",
          ")",
          "(compose-three 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_three x =",
          "  (fun x -> x * x)",
          "  ((fun x -> x + 1)",
          "   ((fun x -> x * 2) x))",
          "in",
          "compose_three 3"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-three` que toma un número `x` y aplica tres transformaciones. La sintaxis `(define (nombre params) cuerpo)` es funcional, como procesar un dato científico.",
        "Usa `compose` para combinar `(lambda (x) (* x x))` (elevar al cuadrado) con una composición interna. Es pura, como un pipeline de cálculos.",
        "Compone `(lambda (x) (+ x 1))` (sumar 1) con `(lambda (x) (* x 2))` (duplicar), aplicando primero duplicar, luego sumar 1, y finalmente elevar al cuadrado.",
        "Completa la composición anidada, calculando ((x*2)+1)^2.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-three` con `3`, evaluando ((3*2)+1)^2 = 7^2 = 49, mostrando la composición múltiple."
      ],
      "explanations_ocaml": [
        "Define una función `compose_three` para combinar tres transformaciones, usando `let nombre params = cuerpo`. Es funcional, como procesar un dato en un experimento.",
        "Define `(fun x -> x * x)` para elevar al cuadrado, aplicada al resultado de las funciones internas.",
        "Aplica `(fun x -> x + 1)` al resultado de duplicar, sumando 1 en el pipeline.",
        "Aplica `(fun x -> x * 2)` a `x` primero, duplicando, luego pasa por las otras funciones, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_three` con `3`, evaluando ((3*2)+1)^2 = 49, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer tres transformaciones, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas aplican el cuadrado al final, con pureza. Diferencias: Racket usa `(lambda (x) (* x x))` prefija, OCaml usa `(fun x -> x * x)` infija.",
        "Similitudes: Ambas suman 1 después de duplicar. Diferencias: Racket usa `compose` anidado, OCaml anida funciones manualmente.",
        "Similitudes: Ambas duplican primero. Diferencias: Racket integra en `compose`, OCaml usa anidamiento explícito.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `3`, dando `49`. Diferencias: Racket usa `(compose-three 3)`, OCaml usa `compose_three 3`."
      ]
    },
    "ejercicio-4": {
      "title": "Componer suma y valor absoluto",
      "racket": {
        "lines": [
          "(define (compose-abs-plus-five x)",
          "  ((compose (lambda (x)",
          "              (if (< x 0)",
          "                  (- x)",
          "                  x))",
          "            (lambda (x) (+ x 5)))",
          "   x",
          "  )",
          ")",
          "(compose-abs-plus-five -3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_abs_plus_five x =",
          "  (fun x ->",
          "     if x < 0 then",
          "       -x",
          "     else",
          "       x)",
          "  ((fun x -> x + 5) x)",
          "in",
          "compose_abs_plus_five (-3)"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-abs-plus-five` que combina suma y valor absoluto. La sintaxis `(define (nombre params) cuerpo)` es funcional, como corregir un error sumando 5 y tomando el valor absoluto.",
        "Usa `compose` para combinar una función anónima que calcula el valor absoluto con `(lambda (x) (+ x 5))`. Es pura, como un ajuste en un pipeline.",
        "Inicia un condicional `if` con `(< x 0)` para verificar si el valor es negativo.",
        "Si es negativo, retorna `(- x)`, como corregir un valor negativo.",
        "Si no es negativo, retorna `x`, manteniendo el valor original.",
        "Completa la función de valor absoluto y combina con sumar 5, aplicando suma primero.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-abs-plus-five` con `-3`, evaluando |(-3+5)| = |2| = 2, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_abs_plus_five` para combinar suma y valor absoluto, usando `let nombre params = cuerpo`. Es funcional, como corregir un error en un cálculo.",
        "Define `(fun x -> ...)` para calcular el valor absoluto, aplicada al resultado de sumar 5.",
        "Inicia un condicional `if` con `x < 0` para verificar si el valor es negativo.",
        "Si es negativo, retorna `-x`, como ajustar un valor negativo.",
        "Introduce `else` para el caso no negativo, requerido en OCaml.",
        "Retorna `x` si no es negativo, manteniendo el valor.",
        "Aplica `(fun x -> x + 5)` a `x` primero, sumando 5, luego pasa al valor absoluto.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_abs_plus_five` con `-3`, evaluando |(-3+5)| = 2, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer suma y valor absoluto, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas calculan el valor absoluto después de sumar 5, con pureza. Diferencias: Racket usa `(lambda (x) ...)` prefija, OCaml usa `(fun x -> ...)` infija.",
        "Similitudes: Ambas verifican si el valor es negativo. Diferencias: Racket usa `(< x 0)` prefija, OCaml usa `x < 0` infija.",
        "Similitudes: Ambas retornan el opuesto para negativos. Diferencias: Racket usa `(- x)`, OCaml usa `-x`.",
        "Similitudes: Ambas retornan el valor original para no negativos. Diferencias: OCaml requiere `else` explícito, Racket lo integra en `if`.",
        "Similitudes: Ambas completan el valor absoluto. Diferencias: Racket usa paréntesis, OCaml usa `)`.",
        "Similitudes: Ambas suman 5 primero. Diferencias: Racket usa `compose`, OCaml anida manualmente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `-3`, dando `2`. Diferencias: Racket usa `(compose-abs-plus-five -3)`, OCaml usa `compose_abs_plus_five (-3)`."
      ]
    },
    "ejercicio-5": {
      "title": "Componer resta y triplicación",
      "racket": {
        "lines": [
          "(define (compose-triple-minus-one x)",
          "  ((compose (lambda (x) (* x 3))",
          "            (lambda (x) (- x 1)))",
          "   x",
          "  )",
          ")",
          "(compose-triple-minus-one 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_triple_minus_one x =",
          "  (fun x -> x * 3)",
          "  ((fun x -> x - 1) x)",
          "in",
          "compose_triple_minus_one 4"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-triple-minus-one` que combina resta y triplicación. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular un bono restando 1 y triplicando.",
        "Usa `compose` para combinar `(lambda (x) (* x 3))` (triplicar) con `(lambda (x) (- x 1))` (restar 1). Aplica la resta primero, luego triplica, en notación prefija, pura.",
        "Completa la composición, calculando (x-1)*3.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-triple-minus-one` con `4`, evaluando (4-1)*3 = 3*3 = 9, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_triple_minus_one` para combinar resta y triplicación, usando `let nombre params = cuerpo`. Es funcional, como ajustar un bono en un sistema.",
        "Define `(fun x -> x * 3)` para triplicar, aplicada al resultado de restar 1.",
        "Aplica `(fun x -> x - 1)` a `x` primero, restando 1, luego pasa a triplicar, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_triple_minus_one` con `4`, evaluando (4-1)*3 = 9, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer resta y triplicación, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas triplican después de restar 1, con pureza. Diferencias: Racket usa `(lambda (x) (* x 3))` prefija, OCaml usa `(fun x -> x * 3)` infija.",
        "Similitudes: Ambas restan 1 primero. Diferencias: Racket usa `compose`, OCaml anida manualmente.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `4`, dando `9`. Diferencias: Racket usa `(compose-triple-minus-one 4)`, OCaml usa `compose_triple_minus_one 4`."
      ]
    },
    "ejercicio-6": {
      "title": "Componer cuadrado y paridad",
      "racket": {
        "lines": [
          "(define (compose-square-even x)",
          "  ((compose (lambda (x) (= (remainder x 2) 0))",
          "            (lambda (x) (* x x)))",
          "   x",
          "  )",
          ")",
          "(compose-square-even 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_square_even x =",
          "  (fun x -> x mod 2 = 0)",
          "  ((fun x -> x * x) x)",
          "in",
          "compose_square_even 3"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-square-even` que verifica si el cuadrado de un número es par. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un matemático verificando propiedades.",
        "Usa `compose` para combinar `(lambda (x) (= (remainder x 2) 0))` (verificar paridad) con `(lambda (x) (* x x))` (elevar al cuadrado). Aplica el cuadrado primero, luego verifica paridad, en notación prefija, pura.",
        "Completa la composición, calculando si x^2 es par.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-square-even` con `3`, evaluando 3^2 = 9, que no es par, dando `#f`, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_square_even` para verificar si el cuadrado es par, usando `let nombre params = cuerpo`. Es funcional, como analizar propiedades matemáticas.",
        "Define `(fun x -> x mod 2 = 0)` para verificar paridad, aplicada al resultado del cuadrado.",
        "Aplica `(fun x -> x * x)` a `x` primero, elevando al cuadrado, luego pasa a verificar paridad, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_square_even` con `3`, evaluando 3^2 = 9, que no es par, dando `false`, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer cuadrado y paridad, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas verifican paridad después de elevar al cuadrado, con pureza. Diferencias: Racket usa `(lambda (x) (= (remainder x 2) 0))` prefija, OCaml usa `(fun x -> x mod 2 = 0)` infija.",
        "Similitudes: Ambas elevan al cuadrado primero. Diferencias: Racket usa `compose`, OCaml anida manualmente.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `3`, dando `#f`/`false`. Diferencias: Racket usa `(compose-square-even 3)`, OCaml usa `compose_square_even 3`."
      ]
    },
    "ejercicio-7": {
      "title": "Componer valor absoluto y duplicación",
      "racket": {
        "lines": [
          "(define (compose-double-abs x)",
          "  ((compose (lambda (x) (* x 2))",
          "            (lambda (x)",
          "              (if (< x 0)",
          "                  (- x)",
          "                  x)))",
          "   x",
          "  )",
          ")",
          "(compose-double-abs -4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_double_abs x =",
          "  (fun x -> x * 2)",
          "  ((fun x ->",
          "      if x < 0 then",
          "        -x",
          "      else",
          "        x) x)",
          "in",
          "compose_double_abs (-4)"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-double-abs` que combina valor absoluto y duplicación. La sintaxis `(define (nombre params) cuerpo)` es funcional, como corregir un error y duplicarlo.",
        "Usa `compose` para combinar `(lambda (x) (* x 2))` (duplicar) con una función de valor absoluto. Aplica el valor absoluto primero, luego duplica, en notación prefija, pura.",
        "Define la función anónima para valor absoluto, iniciando con `(lambda (x) ...)`",
        "Inicia un condicional `if` con `(< x 0)` para verificar si el valor es negativo.",
        "Si es negativo, retorna `(- x)`, como corregir un valor negativo.",
        "Si no es negativo, retorna `x`, manteniendo el valor original.",
        "Completa la composición, aplicando valor absoluto y luego duplicando.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-double-abs` con `-4`, evaluando |-4|*2 = 4*2 = 8, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_double_abs` para combinar valor absoluto y duplicación, usando `let nombre params = cuerpo`. Es funcional, como ajustar un valor en un sistema.",
        "Define `(fun x -> x * 2)` para duplicar, aplicada al resultado del valor absoluto.",
        "Define `(fun x -> ...)` para calcular el valor absoluto, aplicada a `x`.",
        "Inicia un condicional `if` con `x < 0` para verificar si el valor es negativo.",
        "Si es negativo, retorna `-x`, como corregir un valor negativo.",
        "Introduce `else` para el caso no negativo, requerido en OCaml.",
        "Retorna `x` si no es negativo, manteniendo el valor.",
        "Aplica el valor absoluto a `x` primero, luego pasa a duplicar, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_double_abs` con `-4`, evaluando |-4|*2 = 8, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer valor absoluto y duplicación, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas duplican después del valor absoluto, con pureza. Diferencias: Racket usa `(lambda (x) (* x 2))` prefija, OCaml usa `(fun x -> x * 2)` infija.",
        "Similitudes: Ambas calculan el valor absoluto. Diferencias: Racket usa `(lambda (x) ...)` prefija, OCaml usa `(fun x -> ...)` infija.",
        "Similitudes: Ambas verifican si el valor es negativo. Diferencias: Racket usa `(< x 0)`, OCaml usa `x < 0`.",
        "Similitudes: Ambas retornan el opuesto para negativos. Diferencias: Racket usa `(- x)`, OCaml usa `-x`.",
        "Similitudes: Ambas retornan el valor original para no negativos. Diferencias: OCaml requiere `else`, Racket lo integra en `if`.",
        "Similitudes: Ambas completan el valor absoluto. Diferencias: Racket usa paréntesis, OCaml usa `)`.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `-4`, dando `8`. Diferencias: Racket usa `(compose-double-abs -4)`, OCaml usa `compose_double_abs (-4)`."
      ]
    }
  },
  "procesamiento-listas": {
    "ejercicio-1": {
      "title": "Sumar elementos de una lista recursivamente",
      "racket": {
        "lines": [
          "(define (sum-list lst)",
          "  (if (empty? lst)",
          "      0",
          "      (+ (first lst)",
          "         (sum-list (rest lst))))",
          "  )",
          ")",
          "(sum-list '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec sum_list lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    List.hd lst + sum_list (List.tl lst)",
          "in",
          "sum_list [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-list` que suma los elementos de una lista recursivamente. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un comerciante sumando ventas diarias.",
        "Usa `if` para verificar si la lista está vacía con `(empty? lst)`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `0`, como el total de ventas cuando no hay transacciones.",
        "Si la lista no está vacía, suma el primer elemento `(first lst)` con el resultado de la recursión, en notación prefija.",
        "Llama recursivamente a `sum-list` con `(rest lst)`, procesando el resto de la lista, manteniendo la pureza.",
        "Cierra el bloque `if` y la función, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `sum-list` con `'(2 3 4)`, evaluando 2 + 3 + 4 = 9, mostrando la suma recursiva."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_list` con `let rec` para sumar elementos de una lista, usando `let nombre params = cuerpo`. Es funcional, como sumar ventas en un registro.",
        "Usa `if` para verificar si la lista es vacía con `lst = []`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `0`, como un total nulo sin ventas.",
        "Introduce `else` para el caso no vacío, requerido en OCaml, para manejar la recursión.",
        "Suma el primer elemento (`List.hd lst`) con la recursión sobre el resto (`sum_list (List.tl lst)`), en notación infija, pura.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_list` con `[2; 3; 4]`, evaluando 2 + 3 + 4 = 9, demostrando la suma recursiva."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar listas, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo` con tipado estático implícito.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija.",
        "Similitudes: Ambas retornan `0` para el caso base, con pureza. Diferencias: Racket usa una línea directa, OCaml usa `then` explícito.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket usa paréntesis, OCaml requiere `else` explícito.",
        "Similitudes: Ambas suman el primer elemento con la recursión del resto, con pureza. Diferencias: Racket usa `(first lst)` y `(rest lst)` prefija, OCaml usa `List.hd lst` y `List.tl lst` con módulo `List`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `if`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `9`. Diferencias: Racket usa `'(2 3 4)`, OCaml usa `[2; 3; 4]` con punto y coma."
      ]
    },
    "ejercicio-2": {
      "title": "Triplicar elementos con map",
      "racket": {
        "lines": [
          "(define (triple-list lst)",
          "  (map (lambda (x) (* x 3))",
          "       lst",
          "  )",
          ")",
          "(triple-list '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let triple_list lst =",
          "  List.map (fun x -> x * 3) lst",
          "in",
          "triple_list [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función `triple-list` para multiplicar cada elemento de una lista por 3. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un chef triplicando cantidades de ingredientes.",
        "Usa `map` para aplicar `(lambda (x) (* x 3))` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura, como ajustar un inventario sin modificar el original.",
        "Pasa la lista `lst` a `map`, aplicando la transformación a todos los elementos.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `triple-list` con `'(1 2 3)`, retornando `(3 6 9)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `triple_list` para triplicar elementos, usando `let nombre params = cuerpo`. Es funcional, como ajustar cantidades en una receta.",
        "Usa `List.map` para aplicar `(fun x -> x * 3)` a cada elemento, retornando una nueva lista. `List.map` es una función de alto orden pura, como escalar un inventario.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `triple_list` con `[1; 2; 3]`, retornando `[3; 6; 9]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para triplicar elementos usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (* x 3))` prefija, OCaml usa `(fun x -> x * 3)` infija, con `List.map` explícito.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml integra en `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(3 6 9)`. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]`."
      ]
    },
    "ejercicio-3": {
      "title": "Filtrar números impares con filter",
      "racket": {
        "lines": [
          "(define (odd-numbers lst)",
          "  (filter (lambda (x) (= (remainder x 2) 1))",
          "          lst",
          "  )",
          ")",
          "(odd-numbers '(1 2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let odd_numbers lst =",
          "  List.filter (fun x -> x mod 2 = 1) lst",
          "in",
          "odd_numbers [1; 2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `odd-numbers` para filtrar números impares. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un sorteo seleccionando números impares.",
        "Usa `filter` para aplicar `(lambda (x) (= (remainder x 2) 1))`, verificando si un número es impar, retornando una nueva lista. `filter` es una función de alto orden pura, como elegir boletos específicos.",
        "Pasa la lista `lst` a `filter`, evaluando cada elemento.",
        "Cierra el bloque de `filter`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `odd-numbers` con `'(1 2 3 4)`, retornando `(1 3)`, mostrando el filtrado."
      ],
      "explanations_ocaml": [
        "Define una función `odd_numbers` para filtrar números impares, usando `let nombre params = cuerpo`. Es funcional, como seleccionar valores en un sorteo.",
        "Usa `List.filter` para aplicar `(fun x -> x mod 2 = 1)`, seleccionando impares. `List.filter` es una función de alto orden pura, como un tamiz para datos.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `odd_numbers` con `[1; 2; 3; 4]`, retornando `[1; 3]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar impares usando `filter`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `filter`/`List.filter` para seleccionar elementos puros. Diferencias: Racket usa `(lambda (x) (= (remainder x 2) 1))` prefija, OCaml usa `(fun x -> x mod 2 = 1)` infija, con `List.filter` explícito.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml integra en `List.filter`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `filter`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando `(1 3)`. Diferencias: Racket usa `'(1 2 3 4)`, OCaml usa `[1; 2; 3; 4]`."
      ]
    },
    "ejercicio-4": {
      "title": "Invertir lista recursivamente",
      "racket": {
        "lines": [
          "(define (reverse-list lst)",
          "  (if (empty? lst)",
          "      null",
          "      (append (reverse-list (rest lst))",
          "              (list (first lst))))",
          "  )",
          ")",
          "(reverse-list '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec reverse_list lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    reverse_list (List.tl lst) @ [List.hd lst]",
          "in",
          "reverse_list [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función `reverse-list` que invierte una lista recursivamente. La sintaxis `(define (nombre params) cuerpo)` es funcional, como priorizar tareas recientes en un sistema.",
        "Usa `if` para verificar si la lista está vacía con `(empty? lst)`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `null`, como una lista vacía de tareas.",
        "Si no está vacía, concatena la recursión del resto con el primer elemento. `(append ...)` combina listas, en notación prefija.",
        "Llama recursivamente a `reverse-list` con `(rest lst)`, invirtiendo el resto, y pone `(first lst)` al final usando `(list ...)`, manteniendo pureza.",
        "Cierra el bloque `if` y la función, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `reverse-list` con `'(1 2 3)`, retornando `(3 2 1)`, mostrando la inversión recursiva."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `reverse_list` con `let rec` para invertir una lista, usando `let nombre params = cuerpo`. Es funcional, como reordenar tareas en un sistema.",
        "Usa `if` para verificar si la lista es vacía con `lst = []`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `[]`, como una lista vacía de tareas.",
        "Introduce `else` para el caso no vacío, requerido en OCaml, para manejar la recursión.",
        "Concatena la recursión de `reverse_list (List.tl lst)` con `[List.hd lst]` usando `@`, poniendo el primer elemento al final, en notación infija, pura.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `reverse_list` con `[1; 2; 3]`, retornando `[3; 2; 1]`, demostrando la inversión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para invertir listas, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija.",
        "Similitudes: Ambas retornan una lista vacía para el caso base, con pureza. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket usa paréntesis, OCaml requiere `else` explícito.",
        "Similitudes: Ambas concatenan la recursión del resto con el primer elemento. Diferencias: Racket usa `(append ... (list (first lst)))` prefija, OCaml usa `@ [List.hd lst]` infija con módulo `List`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `if`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(3 2 1)`. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]`."
      ]
    },
    "ejercicio-5": {
      "title": "Sumar con foldl",
      "racket": {
        "lines": [
          "(define (sum-fold lst)",
          "  (foldl + 0 lst)",
          ")",
          "(sum-fold '(10 20 30))"
        ]
      },
      "ocaml": {
        "lines": [
          "let sum_fold lst =",
          "  List.fold_left (+) 0 lst",
          "in",
          "sum_fold [10; 20; 30]"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-fold` para sumar elementos usando `foldl`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como una tienda sumando ventas totales.",
        "Usa `foldl` para aplicar la función `+` con un acumulador inicial `0` a la lista `lst`, retornando la suma total. `foldl` es una función de alto orden pura, como un contador acumulando ventas.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `sum-fold` con `'(10 20 30)`, evaluando 10 + 20 + 30 = 60, mostrando la acumulación."
      ],
      "explanations_ocaml": [
        "Define una función `sum_fold` para sumar elementos con `List.fold_left`, usando `let nombre params = cuerpo`. Es funcional, como un sistema sumando ingresos.",
        "Usa `List.fold_left` para aplicar el operador `(+)`, con acumulador inicial `0`, a `lst`. Es una función de alto orden pura, como un registro acumulando valores.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `sum_fold` con `[10; 20; 30]`, evaluando 10 + 20 + 30 = 60, demostrando la acumulación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para sumar con fold, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `foldl`/`List.fold_left` para acumular con `+` y `0`, con pureza. Diferencias: Racket usa `+` prefija, OCaml usa `(+)`, con `List.fold_left` explícito.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `60`. Diferencias: Racket usa `'(10 20 30)`, OCaml usa `[10; 20; 30]`."
      ]
    },
    "ejercicio-6": {
      "title": "Filtrar valores true con filter",
      "racket": {
        "lines": [
          "(define (true-values lst)",
          "  (filter (lambda (x) x) lst)",
          ")",
          "(true-values '(#t #f #t))"
        ]
      },
      "ocaml": {
        "lines": [
          "let true_values lst =",
          "  List.filter (fun x -> x) lst",
          "in",
          "true_values [true; false; true]"
        ]
      },
      "explanations_racket": [
        "Define una función `true-values` para filtrar valores `#t` de una lista. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un organizador seleccionando tareas completadas.",
        "Usa `filter` para aplicar `(lambda (x) x)`, que selecciona solo los valores `#t`, retornando una nueva lista. `filter` es una función de alto orden pura, como elegir tareas marcadas como hechas.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `true-values` con `'(#t #f #t)`, retornando `(#t #t)`, mostrando el filtrado."
      ],
      "explanations_ocaml": [
        "Define una función `true_values` para filtrar valores `true`, usando `let nombre params = cuerpo`. Es funcional, como seleccionar tareas completadas en un sistema.",
        "Usa `List.filter` para aplicar `(fun x -> x)`, seleccionando solo `true`. `List.filter` es una función de alto orden pura, como un filtro de tareas finalizadas.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `true_values` con `[true; false; true]`, retornando `[true; true]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar valores `true`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `filter`/`List.filter` para seleccionar `true`, con pureza. Diferencias: Racket usa `(lambda (x) x)` prefija, OCaml usa `(fun x -> x)` infija, con `List.filter` explícito.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 booleanos, dando `(true true)`. Diferencias: Racket usa `'(#t #f #t)`, OCaml usa `[true; false; true]`."
      ]
    },
    "ejercicio-7": {
      "title": "Multiplicar por 10 con map",
      "racket": {
        "lines": [
          "(define (times-ten lst)",
          "  (map (lambda (x) (* x 10))",
          "       lst",
          "  )",
          ")",
          "(times-ten '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let times_ten lst =",
          "  List.map (fun x -> x * 10) lst",
          "in",
          "times_ten [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `times-ten` para multiplicar cada elemento por 10. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un analista ajustando precios en una tienda.",
        "Usa `map` para aplicar `(lambda (x) (* x 10))` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura, como escalar costos sin modificar originales.",
        "Pasa la lista `lst` a `map`, aplicando la transformación a todos los elementos.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `times-ten` con `'(2 3 4)`, retornando `(20 30 40)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `times_ten` para multiplicar por 10, usando `let nombre params = cuerpo`. Es funcional, como ajustar precios en un sistema.",
        "Usa `List.map` para aplicar `(fun x -> x * 10)` a cada elemento. `List.map` es una función de alto orden pura, como escalar valores en un catálogo.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `times_ten` con `[2; 3; 4]`, retornando `[20; 30; 40]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para multiplicar por 10 usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (* x 10))` prefija, OCaml usa `(fun x -> x * 10)` infija, con `List.map` explícito.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml integra en `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(20 30 40)`. Diferencias: Racket usa `'(2 3 4)`, OCaml usa `[2; 3; 4]`."
      ]
    }
  }
}
