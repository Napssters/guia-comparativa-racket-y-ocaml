{
  "paradigma-funcional": {
    "ejercicio-1": {
      "title": "Sumar distancias de un viaje",
      "racket": {
        "lines": ["(+ 5 3)", "(+ 2 7)", "(+ 10 4)", "(+ 1 6)", "(+ 8 2)"]
      },
      "ocaml": {
        "lines": ["5 + 3", "2 + 7", "10 + 4", "1 + 6", "8 + 2"]
      },
      "explanations_racket": [
        "Calcula la distancia sumando 5 km y 3 km con '+', resultando en 8. La notación prefija (+ 5 3) en Racket enfatiza la suma como función pura, ideal para modelar tramos de un viaje, como ir a la escuela y volver, con resultados predecibles y sin estado.",
        "Suma 2 km y 7 km con '+', dando 9. La notación (+ 2 7) muestra cómo Racket trata la suma como función, útil para caminatas cortas, como de casa al parque, manteniendo inmutabilidad.",
        "Suma 10 km y 4 km, resultando en 14. La expresión (+ 10 4) refuerza la pureza funcional, modelando viajes largos con determinismo para principiantes.",
        "Suma 1 km y 6 km, dando 7. La notación (+ 1 6) es clara para tramos pequeños, como ir a una tienda, sin alterar estado.",
        "Suma 8 km y 2 km, resultando en 10. (+ 8 2) enseña cómo sumar distancias, como paseos matutinos y vespertinos, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula la distancia sumando 5 km y 3 km con '+', dando 8. La notación infija 5 + 3 en OCaml es intuitiva, como matemáticas escolares, ideal para modelar tramos de un viaje con pureza y sin efectos secundarios.",
        "Suma 2 km y 7 km, resultando en 9. La expresión 2 + 7 es simple, como sumar distancias de caminatas diarias, con tipado estático asegurando enteros.",
        "Suma 10 km y 4 km, dando 14. La expresión 10 + 4 modela viajes largos, manteniendo determinismo y facilidad para principiantes.",
        "Suma 1 km y 6 km, resultando en 7. La notación 1 + 6 es clara para tramos cortos, como ir al mercado, con pureza funcional.",
        "Suma 8 km y 2 km, dando 10. La expresión 8 + 2 representa caminatas combinadas, con OCaml asegurando resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan 5 + 3 = 8, con pureza funcional, usando suma para modelar distancias de un viaje. Diferencias: Racket usa notación prefija (+ 5 3) con paréntesis, explícita como función, mientras que OCaml usa infija 5 + 3, más concisa y matemática. Racket tiene tipado dinámico, OCaml infiere enteros.",
        "Similitudes: Ambas calculan 2 + 7 = 9, con pureza funcional, para caminatas cortas. Diferencias: Racket usa prefija (+ 2 7), destacando la función, mientras que OCaml usa infija 2 + 7, más natural. Racket dinámico, OCaml estático, pero resultado idéntico.",
        "Similitudes: Ambas calculan 10 + 4 = 14, con pureza funcional, modelando viajes largos. Diferencias: Racket usa prefija (+ 10 4), explícita, mientras que OCaml usa infija 10 + 4, concisa. Tipado dinámico en Racket, estático en OCaml.",
        "Similitudes: Ambas calculan 1 + 6 = 7, con pureza funcional, para tramos pequeños. Diferencias: Racket usa prefija (+ 1 6), mientras que OCaml usa infija 1 + 6, más intuitiva. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 8 + 2 = 10, con pureza funcional, para paseos combinados. Diferencias: Racket usa prefija (+ 8 2), explícita, mientras que OCaml usa infija 8 + 2, concisa. Tipado dinámico vs. estático, pero idéntico."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar paridad con resto",
      "racket": {
        "lines": [
          "(remainder 7 2)",
          "(remainder 4 2)",
          "(remainder 9 2)",
          "(remainder 6 2)",
          "(remainder 3 2)"
        ]
      },
      "ocaml": {
        "lines": ["7 mod 2", "4 mod 2", "9 mod 2", "6 mod 2", "3 mod 2"]
      },
      "explanations_racket": [
        "Calcula el resto de 7 ÷ 2 con 'remainder', dando 1 (impar). La notación prefija (remainder 7 2) muestra la operación como función pura, ideal para verificar si un número de sillas deja sobrantes en pares, manteniendo inmutabilidad.",
        "Calcula 4 ÷ 2, dando 0 (par). (remainder 4 2) enseña paridad, como dividir dulces equitativamente, con pureza funcional y sin efectos secundarios.",
        "Calcula 9 ÷ 2, resultando en 1 (impar). (remainder 9 2) modela casos como organizar invitados, asegurando determinismo para principiantes.",
        "Calcula 6 ÷ 2, dando 0 (par). (remainder 6 2) es útil para dividir objetos en grupos, manteniendo la inmutabilidad del estado.",
        "Calcula 3 ÷ 2, dando 1 (impar). (remainder 3 2) refuerza paridad, como clasificar frutas, con pureza funcional y resultados predecibles."
      ],
      "explanations_ocaml": [
        "Calcula el resto de 7 ÷ 2 con 'mod', dando 1 (impar). La notación infija 7 mod 2 es intuitiva, como verificar sillas sobrantes, con pureza funcional y sin efectos secundarios.",
        "Calcula 4 ÷ 2, dando 0 (par). 4 mod 2 modela división equitativa, como repartir dulces, con tipado estático asegurando enteros.",
        "Calcula 9 ÷ 2, resultando en 1 (impar). 9 mod 2 es útil para organizar grupos, manteniendo determinismo y facilidad para principiantes.",
        "Calcula 6 ÷ 2, dando 0 (par). 6 mod 2 enseña división en pares, como clasificar objetos, con pureza funcional.",
        "Calcula 3 ÷ 2, dando 1 (impar). 3 mod 2 modela paridad, como contar frutas sobrantes, con resultados predecibles y sin estado."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan resto de 7 ÷ 2 = 1, con pureza funcional, verificando imparidad. Diferencias: Racket usa 'remainder' prefija, explícita, mientras que OCaml usa 'mod' infija, concisa. Racket dinámico, OCaml estático, pero resultado idéntico.",
        "Similitudes: Ambas calculan 4 ÷ 2 = 0, con pureza funcional, verificando paridad. Diferencias: Racket usa 'remainder' prefija, mientras que OCaml usa 'mod' infija. Tipado dinámico vs. estático, pero idéntico.",
        "Similitudes: Ambas calculan 9 ÷ 2 = 1, con pureza funcional, para imparidad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 6 ÷ 2 = 0, con pureza funcional, para paridad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 3 ÷ 2 = 1, con pureza funcional, verificando imparidad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-3": {
      "title": "Comparar inventarios con sumas",
      "racket": {
        "lines": [
          "(> (+ 12 4) 15)",
          "(> (+ 5 5) 12)",
          "(> (+ 15 3) 10)",
          "(> (+ 3 3) 6)",
          "(> (+ 9 6) 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "12 + 4 > 15",
          "5 + 5 > 12",
          "15 + 3 > 10",
          "3 + 3 > 6",
          "9 + 6 > 8"
        ]
      },
      "explanations_racket": [
        "Compara el resultado de 12 + 4 = 16 con 15 usando '>', dando #t. La notación prefija (> (+ 12 4) 15) en Racket muestra la comparación como función pura, ideal para evaluar inventarios con nuevas unidades frente a la competencia, manteniendo inmutabilidad.",
        "Compara 5 + 5 = 10 con 12, dando #f. (> (+ 5 5) 12) enseña decisiones funcionales, como verificar existencias, con determinismo y sin efectos secundarios.",
        "Compara 15 + 3 = 18 con 10, resultando en #t. (> (+ 15 3) 10) modela comparar cantidades de productos, asegurando pureza funcional.",
        "Compara 3 + 3 = 6 con 6, dando #f. (> (+ 3 3) 6) enseña que igual no es mayor, útil para inventarios equilibrados, con resultados predecibles.",
        "Compara 9 + 6 = 15 con 8, dando #t. (> (+ 9 6) 8) modela comparar ventas con adiciones, manteniendo la inmutabilidad del estado."
      ],
      "explanations_ocaml": [
        "Compara 12 + 4 = 16 con 15 usando '>', dando true. La notación infija 12 + 4 > 15 es intuitiva, como comparar inventarios con nuevas unidades, con pureza funcional y sin efectos secundarios.",
        "Compara 5 + 5 = 10 con 12, dando false. 5 + 5 > 12 modela decisiones de stock, con tipado estático asegurando enteros y determinismo.",
        "Compara 15 + 3 = 18 con 10, dando true. 15 + 3 > 10 es útil para comparar cantidades, manteniendo pureza funcional para principiantes.",
        "Compara 3 + 3 = 6 con 6, dando false. 3 + 3 > 6 enseña que igual no es mayor, con pureza y sin estado.",
        "Compara 9 + 6 = 15 con 8, dando true. 9 + 6 > 8 modela comparar ventas con adiciones, asegurando resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan 12 + 4 = 16 > 15, dando #t/true, con pureza funcional, para inventarios con sumas. Diferencias: Racket usa '>' prefija con paréntesis anidados (> (+ 12 4) 15), explícita, mientras que OCaml usa infija 12 + 4 > 15, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 5 + 5 = 10 > 12, dando #f/false, con pureza funcional, para existencias. Diferencias: Racket usa '>' prefija (> (+ 5 5) 12), OCaml infija 5 + 5 > 12. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 15 + 3 = 18 > 10, dando #t/true, con pureza funcional, para cantidades. Diferencias: Racket usa '>' prefija (> (+ 15 3) 10), OCaml infija 15 + 3 > 10. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 3 + 3 = 6 > 6, dando #f/false, con pureza funcional, para inventarios equilibrados. Diferencias: Racket usa '>' prefija (> (+ 3 3) 6), OCaml infija 3 + 3 > 6. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 9 + 6 = 15 > 8, dando #t/true, con pureza funcional, para ventas. Diferencias: Racket usa '>' prefija (> (+ 9 6) 8), OCaml infija 9 + 6 > 8. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-4": {
      "title": "Dividir ganancias netas",
      "racket": {
        "lines": [
          "(/ (- 20 10) 2)",
          "(/ (- 15 3) 4)",
          "(/ (- 18 10) 2)",
          "(/ (- 12 3) 3)",
          "(/ (- 24 4) 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "(20 - 10) / 2",
          "(15 - 3) / 4",
          "(18 - 10) / 2",
          "(12 - 3) / 3",
          "(24 - 4) / 5"
        ]
      },
      "explanations_racket": [
        "Calcula (20 - 10) / 2 con '/', dando 5. La notación prefija (/ (- 20 10) 2) en Racket muestra la división como función pura, ideal para repartir ganancias netas entre 2 personas, con inmutabilidad y determinismo.",
        "Calcula (15 - 3) / 4, dando 3. (/ (- 15 3) 4) modela dividir ganancias entre 4 personas, con pureza funcional y sin efectos secundarios.",
        "Calcula (18 - 10) / 2, resultando en 4. (/ (- 18 10) 2) enseña cómo dividir ingresos netos, como en proyectos, manteniendo inmutabilidad.",
        "Calcula (12 - 3) / 3, dando 3. (/ (- 12 3) 3) modela repartir beneficios entre 3, con resultados predecibles y sin estado.",
        "Calcula (24 - 4) / 5, dando 4. (/ (- 24 4) 5) representa dividir ganancias entre 5, con pureza funcional para escenarios más complejos."
      ],
      "explanations_ocaml": [
        "Calcula (20 - 10) / 2 con '/', dando 5. La notación infija (20 - 10) / 2 es intuitiva, como repartir ganancias netas entre 2, con pureza funcional y sin efectos secundarios.",
        "Calcula (15 - 3) / 4, dando 3. (15 - 3) / 4 modela dividir beneficios entre 4, con tipado estático asegurando enteros y determinismo.",
        "Calcula (18 - 10) / 2, resultando en 4. (18 - 10) / 2 enseña repartir ingresos netos, manteniendo pureza funcional.",
        "Calcula (12 - 3) / 3, dando 3. (12 - 3) / 3 modela dividir entre 3, con resultados predecibles y sin estado.",
        "Calcula (24 - 4) / 5, dando 4. (24 - 4) / 5 representa repartir entre 5, con OCaml asegurando cálculos predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan (20 - 10) / 2 = 5, con pureza funcional, para repartir ganancias. Diferencias: Racket usa '/' prefija (/ (- 20 10) 2), explícita, mientras que OCaml usa infija (20 - 10) / 2, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan (15 - 3) / 4 = 3, con pureza funcional, para beneficios. Diferencias: Racket usa '/' prefija (/ (- 15 3) 4), OCaml infija (15 - 3) / 4. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan (18 - 10) / 2 = 4, con pureza funcional, para ingresos netos. Diferencias: Racket usa '/' prefija (/ (- 18 10) 2), OCaml infija (18 - 10) / 2. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan (12 - 3) / 3 = 3, con pureza funcional, para dividir beneficios. Diferencias: Racket usa '/' prefija (/ (- 12 3) 3), OCaml infija (12 - 3) / 3. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan (24 - 4) / 5 = 4, con pureza funcional, para repartir entre 5. Diferencias: Racket usa '/' prefija (/ (- 24 4) 5), OCaml infija (24 - 4) / 5. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-5": {
      "title": "Comparar cálculos con igualdad",
      "racket": {
        "lines": [
          "(= (- (+ 5 3) 1) 7)",
          "(= (* 2 3) 7)",
          "(= (+ (* 4 2) 1) 9)",
          "(= (- 10 3) 6)",
          "(= (* 5 1) 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "(5 + 3 - 1) = 7",
          "(2 * 3) = 7",
          "((4 * 2) + 1) = 9",
          "(10 - 3) = 6",
          "(5 * 1) = 5"
        ]
      },
      "explanations_racket": [
        "Compara (5 + 3 - 1) = 7 con '=', dando #t (7 = 7). La notación prefija (= (- (+ 5 3) 1) 7) muestra igualdad como función pura, ideal para validar inventarios con operaciones compuestas, con inmutabilidad.",
        "Compara (2 * 3) = 7, dando #f (6 ≠ 7). (= (* 2 3) 7) enseña verificar resultados, como en cálculos de stock, con pureza funcional.",
        "Compara (4 * 2 + 1) = 9, dando #t (9 = 9). (= (+ (* 4 2) 1) 9) modela validar operaciones complejas, como en inventarios, sin efectos secundarios.",
        "Compara (10 - 3) = 6, dando #f (7 ≠ 6). (= (- 10 3) 6) enseña verificar diferencias, con resultados predecibles.",
        "Compara (5 * 1) = 5, dando #t (5 = 5). (= (* 5 1) 5) modela validar cálculos simples, manteniendo inmutabilidad."
      ],
      "explanations_ocaml": [
        "Compara (5 + 3 - 1) = 7 con '=', dando true (7 = 7). La notación infija (5 + 3 - 1) = 7 es intuitiva, como validar inventarios con operaciones, con pureza funcional.",
        "Compara (2 * 3) = 7, dando false (6 ≠ 7). (2 * 3) = 7 modela verificar cálculos, con tipado estático asegurando enteros.",
        "Compara ((4 * 2) + 1) = 9, dando true (9 = 9). ((4 * 2) + 1) = 9 valida operaciones complejas, manteniendo determinismo.",
        "Compara (10 - 3) = 6, dando false (7 ≠ 6). (10 - 3) = 6 enseña verificar diferencias, con pureza funcional.",
        "Compara (5 * 1) = 5, dando true (5 = 5). (5 * 1) = 5 modela validar cálculos simples, con resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan (5 + 3 - 1) = 7, dando #t/true, con pureza funcional, para validar inventarios. Diferencias: Racket usa '=' prefija (= (- (+ 5 3) 1) 7), explícita, mientras que OCaml usa infija (5 + 3 - 1) = 7, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan (2 * 3) = 7, dando #f/false, con pureza funcional, para cálculos. Diferencias: Racket usa '=' prefija (= (* 2 3) 7), OCaml infija (2 * 3) = 7. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan (4 * 2 + 1) = 9, dando #t/true, con pureza funcional, para operaciones complejas. Diferencias: Racket usa '=' prefija (= (+ (* 4 2) 1) 9), OCaml infija ((4 * 2) + 1) = 9. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan (10 - 3) = 6, dando #f/false, con pureza funcional, para diferencias. Diferencias: Racket usa '=' prefija (= (- 10 3) 6), OCaml infija (10 - 3) = 6. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan (5 * 1) = 5, dando #t/true, con pureza funcional, para cálculos simples. Diferencias: Racket usa '=' prefija (= (* 5 1) 5), OCaml infija (5 * 1) = 5. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-6": {
      "title": "Calcular distancias absolutas con anidaciones",
      "racket": {
        "lines": [
          "(abs (- (+ 5 3) 10))",
          "(abs (* -2 3))",
          "(abs (- 4 (+ 1 6)))",
          "(abs (abs (- (* 3 4) 15)))",
          "(abs (- (abs (- 12 18)) 2))"
        ]
      },
      "ocaml": {
        "lines": [
          "abs (5 + 3 - 10)",
          "abs (-2 * 3)",
          "abs (4 - (1 + 6))",
          "abs (abs ((3 * 4) - 15))",
          "abs ((abs (12 - 18)) - 2)"
        ]
      },
      "explanations_racket": [
        "Calcula |5 + 3 - 10| con 'abs', dando 2 (|8 - 10| = |-2|). (abs (- (+ 5 3) 10)) representa una desviación base entre mediciones positivas y negativas, garantizando pureza funcional.",
        "Calcula |-2 * 3| con 'abs', dando 6 (|-6|). (abs (* -2 3)) muestra cómo convertir productos negativos en distancias positivas, útil en cálculos direccionales.",
        "Calcula |4 - (1 + 6)|, dando 3 (|4 - 7| = |-3|). (abs (- 4 (+ 1 6))) enseña composición funcional simple con suma anidada, manteniendo determinismo.",
        "Calcula ||(3 * 4) - 15|| con 'abs' anidado, dando 3. (abs (abs (- (* 3 4) 15))) ilustra valor absoluto doble, demostrando idempotencia de 'abs' sobre resultados positivos.",
        "Calcula |(|12 - 18| - 2)| con 'abs' anidado, dando 4 (|6 - 2| = 4). (abs (- (abs (- 12 18)) 2)) combina restas y valores absolutos internos, ejemplo de anidación coherente."
      ],
      "explanations_ocaml": [
        "Calcula |5 + 3 - 10| con 'abs', dando 2 (|8 - 10| = |-2|). abs (5 + 3 - 10) mantiene claridad infija y pureza funcional para desviaciones aritméticas.",
        "Calcula |-2 * 3| con 'abs', dando 6 (|-6|). abs (-2 * 3) muestra corrección de signos en multiplicaciones negativas, asegurando determinismo.",
        "Calcula |4 - (1 + 6)| con 'abs', dando 3. abs (4 - (1 + 6)) usa estructura infija clara, con resultados predecibles.",
        "Calcula ||(3 * 4) - 15||, dando 3. abs (abs ((3 * 4) - 15)) demuestra composición funcional pura, ya que 'abs' aplicado dos veces produce el mismo valor.",
        "Calcula |(|12 - 18| - 2)|, dando 4. abs ((abs (12 - 18)) - 2) muestra cómo las anidaciones producen resultados correctos incluso con negativos internos."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan |5 + 3 - 10| = 2 con pureza funcional. Diferencias: Racket usa notación prefija (abs (- (+ 5 3) 10)), OCaml usa infija abs (5 + 3 - 10). Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan |-2 * 3| = 6, preservando pureza. Diferencias: Racket usa 'abs' prefija (abs (* -2 3)), OCaml usa abs (-2 * 3) infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan |4 - (1 + 6)| = 3. Diferencias: Notación prefija vs. infija; Racket más explícito, OCaml más conciso. Ambos son deterministas.",
        "Similitudes: Ambas aplican 'abs' doblemente para obtener 3, ilustrando idempotencia. Diferencias: Racket (abs (abs (- (* 3 4) 15))) vs. OCaml abs (abs ((3 * 4) - 15)), expresividad vs. concisión.",
        "Similitudes: Ambas calculan |(|12 - 18| - 2)| = 4, demostrando anidación funcional. Diferencias: Prefija en Racket, infija en OCaml; ambos mantienen pureza funcional."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular hipotenusas con raíces cuadradas anidadas",
      "racket": {
        "lines": [
          "(sqrt (+ (* 3 3) (* 4 4)))",
          "(sqrt (+ (sqrt (+ (* 5 5) (* 12 12))) 1))",
          "(sqrt (+ (* (sqrt 8) (sqrt 8)) (* 6 6)))",
          "(sqrt (+ (* 7 7) (sqrt (+ (* 24 24) 1))))",
          "(sqrt (sqrt (+ (* 20 20) (* 21 21))))"
        ]
      },
      "ocaml": {
        "lines": [
          "sqrt (3.0 *. 3.0 +. 4.0 *. 4.0)",
          "sqrt (sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) +. 1.0)",
          "sqrt ((sqrt 8.0) *. (sqrt 8.0) +. 6.0 *. 6.0)",
          "sqrt (7.0 *. 7.0 +. sqrt (24.0 *. 24.0 +. 1.0))",
          "sqrt (sqrt (20.0 *. 20.0 +. 21.0 *. 21.0)))"
        ]
      },
      "explanations_racket": [
        "Calcula √(3² + 4²) = √(9 + 16) = 5. (sqrt (+ (* 3 3) (* 4 4))) representa la hipotenusa clásica, ideal para estructuras simples.",
        "Calcula √(√(5² + 12²) + 1) ≈ √(√169 + 1) ≈ √(13 + 1) ≈ 3.74. (sqrt (+ (sqrt (+ (* 5 5) (* 12 12))) 1)) demuestra uso de raíz doble para obtener resultados compuestos.",
        "Calcula √((√8 * √8) + 6²) = √(8 + 36) = √44 ≈ 6.63. (sqrt (+ (* (sqrt 8) (sqrt 8)) (* 6 6))) aplica raíz dentro de multiplicación para mantener coherencia matemática.",
        "Calcula √(7² + √(24² + 1)) = √(49 + √577) ≈ √(49 + 24.02) = √73.02 ≈ 8.54. (sqrt (+ (* 7 7) (sqrt (+ (* 24 24) 1)))) ejemplifica mezcla de niveles de raíces.",
        "Calcula √(√(20² + 21²)) = √(√(400 + 441)) = √(√841) = √29 ≈ 5.38. (sqrt (sqrt (+ (* 20 20) (* 21 21)))) muestra composición extrema de raíces anidadas."
      ],
      "explanations_ocaml": [
        "Calcula √(3.0² + 4.0²) = √(9 + 16) = 5. sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) representa la hipotenusa clásica, usando operadores flotantes.",
        "Calcula √(√(5.0² + 12.0²) + 1.0) ≈ 3.74. sqrt (sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) +. 1.0) aplica raíz doble, mostrando expresividad funcional.",
        "Calcula √((√8.0 *. √8.0) + 6.0²) ≈ 6.63. sqrt ((sqrt 8.0) *. (sqrt 8.0) +. 6.0 *. 6.0) mantiene exactitud en flotantes.",
        "Calcula √(7.0² + √(24.0² + 1.0)) ≈ 8.54. sqrt (7.0 *. 7.0 +. sqrt (24.0 *. 24.0 +. 1.0)) muestra composición jerárquica con precisión decimal.",
        "Calcula √(√(20.0² + 21.0²)) ≈ 5.38. sqrt (sqrt (20.0 *. 20.0 +. 21.0 *. 21.0))) ejemplifica raíces dobles en OCaml con flotantes precisos."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan √(3² + 4²) = 5. Diferencias: Racket usa notación prefija explícita, OCaml infija con operadores flotantes (*. +.).",
        "Similitudes: Ambas aplican doble raíz √(√(5² + 12²) + 1) ≈ 3.74. Diferencias: Prefija en Racket, infija en OCaml, ambas puras y deterministas.",
        "Similitudes: Ambas calculan √((√8 * √8) + 6²) ≈ 6.63, con pureza funcional. Diferencias: Prefija Racket vs. infija OCaml, ambas con precisión matemática.",
        "Similitudes: Ambas resuelven √(7² + √(24² + 1)) ≈ 8.54, representando composición jerárquica. Diferencias: OCaml declara flotantes explícitamente.",
        "Similitudes: Ambas calculan √(√(20² + 21²)) ≈ 5.38, demostrando raíces anidadas. Diferencias: Prefija Racket (sqrt (sqrt ...)), infija OCaml (sqrt (sqrt ...)), con precisión numérica distinta."
      ]
    }
  },
  "expresiones": {
    "ejercicio-1": {
      "title": "Verificar igualdad de paquetes",
      "racket": {
        "lines": ["(= 8 8)", "(= 5 6)", "(= 7 7)", "(= 3 3)", "(= 9 10)"]
      },
      "ocaml": {
        "lines": ["8 = 8", "5 = 6", "7 = 7", "3 = 3", "9 = 10"]
      },
      "explanations_racket": [
        "Verifica si 8 = 8 con '=', dando #t. La notación prefija (= 8 8) en Racket muestra igualdad como función pura, ideal para comparar paquetes de galletas en inventarios.",
        "Verifica 5 = 6, dando #f. (= 5 6) enseña comparar cantidades distintas, como cajas de productos, con determinismo.",
        "Verifica 7 = 7, dando #t. (= 7 7) modela validar medidas iguales, como en control de calidad, con inmutabilidad.",
        "Verifica 3 = 3, dando #t. (= 3 3) es útil para confirmar inventarios, sin efectos secundarios.",
        "Verifica 9 = 10, dando #f. (= 9 10) enseña comparar cantidades distintas, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Verifica 8 = 8 con '=', dando true. La notación infija 8 = 8 es intuitiva, como comparar galletas, con pureza funcional.",
        "Verifica 5 = 6, dando false. 5 = 6 modela comparar cantidades, con tipado estático asegurando enteros.",
        "Verifica 7 = 7, dando true. 7 = 7 enseña validar medidas, con determinismo.",
        "Verifica 3 = 3, dando true. 3 = 3 es útil para inventarios, sin efectos secundarios.",
        "Verifica 9 = 10, dando false. 9 = 10 modela comparar cantidades distintas, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican 8 = 8, dando #t/true, con pureza funcional, para comparar galletas. Diferencias: Racket usa '=' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas verifican 5 = 6, dando #f/false, con pureza funcional, para cantidades distintas. Diferencias: Racket usa '=' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas verifican 7 = 7, dando #t/true, con pureza funcional, para medidas. Diferencias: Racket usa '=' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas verifican 3 = 3, dando #t/true, con pureza funcional, para inventarios. Diferencias: Racket usa '=' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas verifican 9 = 10, dando #f/false, con pureza funcional, para cantidades distintas. Diferencias: Racket usa '=' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-2": {
      "title": "Comparar presupuesto con límite",
      "racket": {
        "lines": ["(> 15 10)", "(> 8 9)", "(> 12 5)", "(> 10 10)", "(> 20 15)"]
      },
      "ocaml": {
        "lines": ["15 > 10", "8 > 9", "12 > 5", "10 > 10", "20 > 15"]
      },
      "explanations_racket": [
        "Compara 15 > 10 con '>', dando #t. La notación prefija (> 15 10) en Racket muestra comparación como función pura, ideal para verificar presupuestos en planificación financiera.",
        "Compara 8 > 9, dando #f. (> 8 9) enseña decisiones de límites, con determinismo.",
        "Compara 12 > 5, dando #t. (> 12 5) modela comparar gastos, sin efectos secundarios.",
        "Compara 10 > 10, dando #f. (> 10 10) enseña que igual no es mayor, útil para presupuestos equilibrados.",
        "Compara 20 > 15, dando #t. (> 20 15) modela verificar excedentes, con inmutabilidad."
      ],
      "explanations_ocaml": [
        "Compara 15 > 10 con '>', dando true. La notación infija 15 > 10 es intuitiva, como verificar presupuestos, con pureza funcional.",
        "Compara 8 > 9, dando false. 8 > 9 modela decisiones de límites, con tipado estático.",
        "Compara 12 > 5, dando true. 12 > 5 es útil para comparar gastos, con determinismo.",
        "Compara 10 > 10, dando false. 10 > 10 enseña que igual no es mayor, con pureza.",
        "Compara 20 > 15, dando true. 20 > 15 modela verificar excedentes, sin efectos secundarios."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan 15 > 10, dando #t/true, con pureza funcional, para presupuestos. Diferencias: Racket usa '>' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 8 > 9, dando #f/false, con pureza funcional, para límites. Diferencias: Racket usa '>' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 12 > 5, dando #t/true, con pureza funcional, para gastos. Diferencias: Racket usa '>' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 10 > 10, dando #f/false, con pureza funcional, para presupuestos equilibrados. Diferencias: Racket usa '>' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 20 > 15, dando #t/true, con pureza funcional, para excedentes. Diferencias: Racket usa '>' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-3": {
      "title": "Sumar distancias caminadas",
      "racket": {
        "lines": ["(+ 7 5)", "(+ 3 4)", "(+ 6 8)", "(+ 2 9)", "(+ 10 3)"]
      },
      "ocaml": {
        "lines": ["7 + 5", "3 + 4", "6 + 8", "2 + 9", "10 + 3"]
      },
      "explanations_racket": [
        "Calcula 7 + 5 con '+', dando 12. La notación prefija (+ 7 5) en Racket muestra suma como función pura, ideal para combinar distancias de caminatas.",
        "Suma 3 + 4, dando 7. (+ 3 4) modela tramos cortos, como ir al parque, con determinismo.",
        "Suma 6 + 8, dando 14. (+ 6 8) es útil para recorridos largos, sin efectos secundarios.",
        "Suma 2 + 9, dando 11. (+ 2 9) enseña sumar distancias variadas, con inmutabilidad.",
        "Suma 10 + 3, dando 13. (+ 10 3) modela combinar tramos, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 7 + 5 con '+', dando 12. La notación infija 7 + 5 es intuitiva, como sumar tramos de caminatas, con pureza funcional.",
        "Suma 3 + 4, dando 7. 3 + 4 modela tramos cortos, con tipado estático asegurando enteros.",
        "Suma 6 + 8, dando 14. 6 + 8 es útil para recorridos largos, con determinismo.",
        "Suma 2 + 9, dando 11. 2 + 9 enseña sumar distancias, sin efectos secundarios.",
        "Suma 10 + 3, dando 13. 10 + 3 modela combinar tramos, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan 7 + 5 = 12, con pureza funcional, para distancias de caminatas. Diferencias: Racket usa '+' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 3 + 4 = 7, con pureza funcional, para tramos cortos. Diferencias: Racket usa '+' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 6 + 8 = 14, con pureza funcional, para recorridos largos. Diferencias: Racket usa '+' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 2 + 9 = 11, con pureza funcional, para distancias variadas. Diferencias: Racket usa '+' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 10 + 3 = 13, con pureza funcional, para combinar tramos. Diferencias: Racket usa '+' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-4": {
      "title": "Calcular caramelos sobrantes",
      "racket": {
        "lines": ["(- 20 6)", "(- 15 4)", "(- 12 3)", "(- 8 2)", "(- 10 5)"]
      },
      "ocaml": {
        "lines": ["20 - 6", "15 - 4", "12 - 3", "8 - 2", "10 - 5"]
      },
      "explanations_racket": [
        "Calcula 20 - 6 con '-', dando 14. La notación prefija (- 20 6) en Racket muestra resta como función pura, ideal para calcular caramelos sobrantes.",
        "Resta 15 - 4, dando 11. (- 15 4) modela distribución de recursos, con determinismo.",
        "Resta 12 - 3, dando 9. (- 12 3) enseña calcular sobrantes, sin efectos secundarios.",
        "Resta 8 - 2, dando 6. (- 8 2) es útil para repartir objetos, con inmutabilidad.",
        "Resta 10 - 5, dando 5. (- 10 5) modela calcular sobrantes, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 20 - 6 con '-', dando 14. La notación infija 20 - 6 es intuitiva, como calcular caramelos sobrantes, con pureza funcional.",
        "Resta 15 - 4, dando 11. 15 - 4 modela distribución, con tipado estático.",
        "Resta 12 - 3, dando 9. 12 - 3 enseña calcular sobrantes, con determinismo.",
        "Resta 8 - 2, dando 6. 8 - 2 es útil para repartir objetos, sin efectos secundarios.",
        "Resta 10 - 5, dando 5. 10 - 5 modela sobrantes, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas restan 20 - 6 = 14, con pureza funcional, para caramelos sobrantes. Diferencias: Racket usa '-' prefija, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas restan 15 - 4 = 11, con pureza funcional, para distribución. Diferencias: Racket usa '-' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas restan 12 - 3 = 9, con pureza funcional, para sobrantes. Diferencias: Racket usa '-' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas restan 8 - 2 = 6, con pureza funcional, para repartir objetos. Diferencias: Racket usa '-' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas restan 10 - 5 = 5, con pureza funcional, para sobrantes. Diferencias: Racket usa '-' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-5": {
      "title": "Verificar divisibilidad de libros",
      "racket": {
        "lines": [
          "(remainder 10 3)",
          "(remainder 8 2)",
          "(remainder 7 4)",
          "(remainder 12 5)",
          "(remainder 9 3)"
        ]
      },
      "ocaml": {
        "lines": ["10 mod 3", "8 mod 2", "7 mod 4", "12 mod 5", "9 mod 3"]
      },
      "explanations_racket": [
        "Calcula resto de 10 ÷ 3 con 'remainder', dando 1. La notación prefija (remainder 10 3) en Racket muestra módulo como función pura, ideal para verificar sobrantes de libros.",
        "Calcula 8 ÷ 2, dando 0. (remainder 8 2) enseña divisibilidad exacta, con determinismo.",
        "Calcula 7 ÷ 4, dando 3. (remainder 7 4) modela sobrantes en grupos, sin efectos secundarios.",
        "Calcula 12 ÷ 5, dando 2. (remainder 12 5) es útil para organización, con inmutabilidad.",
        "Calcula 9 ÷ 3, dando 0. (remainder 9 3) modela división exacta, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula resto de 10 ÷ 3 con 'mod', dando 1. La notación infija 10 mod 3 es intuitiva, como verificar sobrantes de libros, con pureza funcional.",
        "Calcula 8 ÷ 2, dando 0. 8 mod 2 modela divisibilidad exacta, con tipado estático.",
        "Calcula 7 ÷ 4, dando 3. 7 mod 4 enseña sobrantes, con determinismo.",
        "Calcula 12 ÷ 5, dando 2. 12 mod 5 es útil para organización, sin efectos secundarios.",
        "Calcula 9 ÷ 3, dando 0. 9 mod 3 modela división exacta, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan resto de 10 ÷ 3 = 1, con pureza funcional, para sobrantes de libros. Diferencias: Racket usa 'remainder' prefija, explícita, mientras que OCaml usa 'mod' infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 8 ÷ 2 = 0, con pureza funcional, para divisibilidad exacta. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 7 ÷ 4 = 3, con pureza funcional, para sobrantes en grupos. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 12 ÷ 5 = 2, con pureza funcional, para organización. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 9 ÷ 3 = 0, con pureza funcional, para división exacta. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-6": {
      "title": "Repartir huevos entre personas",
      "racket": {
        "lines": ["(/ 12 3)", "(/ 8 2)", "(/ 15 5)", "(/ 6 2)", "(/ 9 3)"]
      },
      "ocaml": {
        "lines": ["12 / 3", "8 / 2", "15 / 5", "6 / 2", "9 / 3"]
      },
      "explanations_racket": [
        "Calcula 12 ÷ 3 con '/', dando 4. La notación prefija (/ 12 3) en Racket muestra división como función pura, ideal para repartir huevos entre personas.",
        "Divide 8 ÷ 2, dando 4. (/ 8 2) modela reparto equitativo, con determinismo.",
        "Divide 15 ÷ 5, dando 3. (/ 15 5) enseña distribución, sin efectos secundarios.",
        "Divide 6 ÷ 2, dando 3. (/ 6 2) es útil para repartir recursos, con inmutabilidad.",
        "Divide 9 ÷ 3, dando 3. (/ 9 3) modela reparto en recetas, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 12 ÷ 3 con '/', dando 4. La notación infija 12 / 3 es intuitiva, como repartir huevos, con pureza funcional.",
        "Divide 8 ÷ 2, dando 4. 8 / 2 modela reparto equitativo, con tipado estático.",
        "Divide 15 ÷ 5, dando 3. 15 / 5 enseña distribución, con determinismo.",
        "Divide 6 ÷ 2, dando 3. 6 / 2 es útil para repartir recursos, sin efectos secundarios.",
        "Divide 9 ÷ 3, dando 3. 9 / 3 modela reparto en recetas, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas dividen 12 ÷ 3 = 4, con pureza funcional, para repartir huevos. Diferencias: Racket usa '/' prefija, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas dividen 8 ÷ 2 = 4, con pureza funcional, para reparto equitativo. Diferencias: Racket usa '/' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas dividen 15 ÷ 5 = 3, con pureza funcional, para distribución. Diferencias: Racket usa '/' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas dividen 6 ÷ 2 = 3, con pureza funcional, para repartir recursos. Diferencias: Racket usa '/' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas dividen 9 ÷ 3 = 3, con pureza funcional, para recetas. Diferencias: Racket usa '/' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-7": {
      "title": "Comparar área ajustada con operaciones compuestas y trigonometría",
      "racket": {
        "lines": [
          "(> (- (sqrt (+ (* 3 3) (* 4 4))) 2) 5)",
          "(> (- (round (sqrt (+ (* 4 4) (* 12 12)))) 1) 7)",
          "(> (- (expt 2 2) (remainder 3 2)) 1)",
          "(> (- (round (* (tan 1.5) 5)) 5) 10)",
          "(> (- (expt 6 2) (round (sin 2))) 15)"
        ]
      },
      "ocaml": {
        "lines": [
          "((sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) -. 2.0) >. 5.0)",
          "((Float.round (sqrt (4.0 *. 4.0 +. 12.0 *. 12.0)) -. 1.0) >. 7.0)",
          "(((2.0 ** 2.0) -. float_of_int (3 mod 2)) >. 1.0)",
          "((Float.round (Float.tan 1.5 *. 5.0) -. 5.0) >. 10.0)",
          "((6.0 ** 2.0 -. Float.round (Float.sin 2.0)) >. 15.0)"
        ]
      },
      "explanations_racket": [
        "Calcula (> (- (sqrt (+ (* 3 3) (* 4 4))) 2) 5). Aquí sqrt(9 + 16) = 5; 5 - 2 = 3; 3 > 5 → #f. (Usa raíz clásica luego resta y comparación.)",
        "Calcula (> (- (round (sqrt (+ (* 4 4) (* 12 12)))) 1) 7). sqrt(16 + 144) ≈ 12.649…; round → 13; 13 - 1 = 12; 12 > 7 → #t. (Combina raíz y redondeo antes de comparar.)",
        "Calcula (> (- (expt 2 2) (remainder 3 2)) 1). expt 2 2 = 4; remainder 3 2 = 1; 4 - 1 = 3; 3 > 1 → #t. (Integra potencia con resto entero.)",
        "Calcula (> (- (round (* (tan 1.5) 5)) 5) 10). tan(1.5) ≈ 14.1014; *5 ≈ 70.507; round → 71; 71 - 5 = 66; 66 > 10 → #t. (Ejemplo de trigonometría, escala y redondeo antes de comparar.)",
        "Calcula (> (- (expt 6 2) (round (sin 2))) 15). expt 6 2 = 36; sin(2) ≈ 0.9093; round → 1; 36 - 1 = 35; 35 > 15 → #t. (Mezcla potencia y función trigonométrica con redondeo.)"
      ],
      "explanations_ocaml": [
        "Calcula ((sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) -. 2.0) >. 5.0). sqrt(9.0 + 16.0) = 5.0; 5.0 -. 2.0 = 3.0; 3.0 >. 5.0 → false. (Equivalente en flotantes.)",
        "Calcula ((Float.round (sqrt (4.0 *. 4.0 +. 12.0 *. 12.0)) -. 1.0) >. 7.0). sqrt(160.0) ≈ 12.649…; Float.round → 13.0; 13.0 -. 1.0 = 12.0; 12.0 >. 7.0 → true.",
        "Calcula (((2.0 ** 2.0) -. float_of_int (3 mod 2)) >. 1.0). 2.0 ** 2.0 = 4.0; 3 mod 2 = 1 -> float_of_int 1 = 1.0; 4.0 -. 1.0 = 3.0; 3.0 >. 1.0 → true.",
        "Calcula ((Float.round (Float.tan 1.5 *. 5.0) -. 5.0) >. 10.0). Float.tan 1.5 ≈ 14.1014; *5.0 ≈ 70.507; Float.round → 71.0; 71.0 -. 5.0 = 66.0; 66.0 >. 10.0 → true.",
        "Calcula ((6.0 ** 2.0 -. Float.round (Float.sin 2.0)) >. 15.0). 6.0 ** 2.0 = 36.0; Float.sin 2.0 ≈ 0.9093; Float.round → 1.0; 36.0 -. 1.0 = 35.0; 35.0 >. 15.0 → true."
      ],
      "comparisons": [
        "Similitudes: Ambas plataformas realizan la misma lógica: componer funciones (raíz, trigonometría, round, remainder) y comparar el resultado con un umbral. Las diferencias notacionales reflejan Racket prefija vs OCaml infija y el uso de operadores de punto para flotantes en OCaml (>., +., -., *.).",
        "Linea 1: Racket devuelve #f porque (sqrt(9+16)-2)=3 no supera 5; OCaml devuelve false por la misma razón (flotantes).",
        "Linea 2: Racket y OCaml devuelven verdadero (Racket #t / OCaml true) tras redondear sqrt(160) a 13 y comparar 12 > 7.",
        "Linea 3: Uso de potencia y resto entero: ambas dan verdadero (Racket #t / OCaml true) porque 4 - 1 = 3 > 1.",
        "Linea 4: La versión con tan + escala + round produce un gran entero tras redondeo (71), por tanto ambas evaluaciones son verdaderas. Racket usa (round ( * (tan 1.5) 5 )), OCaml usa Float.tan y Float.round.",
        "Linea 5: Mezcla expt y sin redondeado da verdadero (36 - 1 = 35 > 15). Notación diferente pero semántica equivalente."
      ]
    }
  },
  "funciones": {
    "ejercicio-1": {
      "title": "Calcular el Área de un Terreno Rectangular",
      "racket": {
        "lines": [
          "(define (rectangle-area base height)",
          "  (* base height)",
          ")",
          "(rectangle-area 10 7)"
        ]
      },
      "ocaml": {
        "lines": [
          "let rectangle_area base height =",
          "  base * height",
          "in",
          "rectangle_area 10 7"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función llamada `rectangle-area` que toma dos números, `base` y `height`, para calcular el área de un rectángulo. Imagina que eres un agricultor midiendo un terreno para saber cuánta manguera necesitas para el riego. En Racket, `(define (nombre params) cuerpo)` es como escribir una receta que puedes usar cada vez que quieras calcular un área.",
        "Aquí multiplicamos `base` por `height` con `(* base height)`, como medir un terreno de 10 metros de largo por 7 de ancho para obtener el área. En Racket, usamos paréntesis porque todo se escribe como una lista, lo que hace que las operaciones sean claras y ordenadas. Esta línea es el corazón del cálculo.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para que Racket entienda que la función está completa.",
        "Esta línea usa la función con los números 10 y 7, calculando `10 * 7 = 70`. Es como probar la receta con un terreno específico para saber que el área es 70 metros cuadrados, útil para planificar el riego."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `rectangle_area` que toma `base` y `height`, como si quisieras calcular el tamaño de un terreno para sembrar. En OCaml, `let nombre params = cuerpo` es como hacer una receta sencilla para calcular áreas. La función está lista para recibir dos números y multiplicarlos.",
        "Aquí multiplicamos `base` por `height` con `base * height`, como contar el espacio de un terreno de 10 por 7 metros. En OCaml, escribimos `*` como en matemáticas, lo que lo hace fácil de entender. Esta línea hace el cálculo principal y da el resultado.",
        "Esta línea usa `in` para decir que vamos a usar la función después, como preparar la receta antes de probarla. Es una regla de OCaml para organizar el código, no hace cálculos, pero es importante para la estructura.",
        "Esta línea aplica la función con 10 y 7, calculando `10 * 7 = 70`. Es como usar la receta para confirmar que el terreno tiene 70 metros cuadrados, perfecto para planificar cuánto material necesitas."
      ],
      "comparisons": [
        "Similitudes: Ambas líneas crean una función que calcula el área de un rectángulo tomando dos números, usando el mismo nombre y propósito. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, como una lista clara, mientras que OCaml usa `let nombre params = cuerpo`, más corto y sin paréntesis. Racket no necesita especificar si los números son enteros, pero OCaml asume que `base` y `height` son enteros automáticamente.",
        "Similitudes: Ambas multiplican `base` por `height` para obtener el área, dando el mismo resultado. Diferencias: Racket usa `(* base height)` con paréntesis, porque en Racket `*` es como una instrucción, mientras que OCaml usa `base * height`, que se ve como una multiplicación matemática. OCaml es más corto y parece más familiar para principiantes.",
        "Similitudes: Ambas son partes estructurales del código, sin cálculos. Diferencias: Racket cierra la función con `)`, porque todo en Racket usa paréntesis, mientras que OCaml usa `in` para indicar que viene el uso de la función, una diferencia en cómo organizan el código.",
        "Similitudes: Ambas aplican la función con 10 y 7, dando 70. Diferencias: Racket escribe `(rectangle-area 10 7)` con paréntesis, mientras que OCaml escribe `rectangle_area 10 7`, más simple y sin paréntesis. Ambos logran lo mismo, pero OCaml se ve más limpio."
      ]
    },
    "ejercicio-2": {
      "title": "Contar Eventos Ajustados por Retrasos",
      "racket": {
        "lines": [
          "(define (adjusted-event-count total-time interval)",
          "  (let ((count (/ total-time interval))",
          "        (margin 2))",
          "    (- count margin)))",
          ")",
          "(adjusted-event-count 25 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let adjusted_event_count total_time interval =",
          "  let count = total_time / interval in",
          "  let margin = 2 in",
          "  count - margin",
          "in",
          "adjusted_event_count 25 5"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función llamada `adjusted-event-count` que toma dos números: `total-time` (el tiempo total) y `interval` (cada cuánto ocurre algo). Imagina que organizas un espectáculo de luces que parpadea cada 5 segundos durante 25 segundos. En Racket, `(define (nombre params) cuerpo)` es como escribir una receta para contar los parpadeos.",
        "Aquí comenzamos un bloque `let` para crear dos cajas temporales: `count` guarda el resultado de dividir `total-time` por `interval` (como dividir 25 entre 5 para saber cuántas veces parpadea la luz). Es como anotar el primer paso en una libreta para no perder el cálculo.",
        "Esta línea define `margin` como 2, un ajuste por retrasos técnicos, como anotar en la libreta que restarás 2 parpadeos por posibles demoras.",
        "Esta línea resta `margin` (2) de `count` con `(- count margin)` para obtener el resultado final, como ajustar el conteo de parpadeos. Los paréntesis en Racket mantienen todo claro y ordenado.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para completar la función.",
        "Esta línea usa la función con 25 y 5, calculando `(25 / 5) - 2 = 3`. Es como probar la receta para saber que la luz parpadea 3 veces después de ajustar por retrasos."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `adjusted_event_count` que toma `total_time` y `interval`, como contar cuántas veces suena una alarma en 25 segundos si suena cada 5 segundos. En OCaml, `let nombre params = cuerpo` es como hacer una receta clara para este cálculo.",
        "Usamos `let count = total_time / interval in` para guardar la división en una caja llamada `count`, como calcular cuántas veces suena la alarma (25 / 5 = 5). El `in` dice que este valor se usará después.",
        "Esta línea guarda el número 2 en una caja llamada `margin`, como anotar un ajuste por retrasos. El `in` indica que este valor se usará en el siguiente paso.",
        "Aquí restamos `margin` (2) de `count` con `count - margin`, como ajustar el conteo de alarmas. La notación se ve como una resta normal, fácil de entender.",
        "Esta línea usa `in` para conectar la función con su uso, como decir 'ahora probemos la receta'. Es una regla de OCaml para organizar el código, sin cálculos.",
        "Esta línea aplica la función con 25 y 5, dando `(25 / 5) - 2 = 3`, como confirmar que la alarma suena 3 veces después del ajuste."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que toma dos números para contar eventos ajustados, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, como una lista, mientras que OCaml usa `let nombre params = cuerpo`, más directo. OCaml asume enteros para los parámetros, Racket no especifica tipos.",
        "Similitudes: Ambas guardan la división en una variable local `count` usando `let`, como una libreta temporal. Diferencias: Racket escribe `(let ((count (/ total-time interval)))` con paréntesis dobles, mientras que OCaml usa `let count = total_time / interval in`, más simple y con `in` para conectar.",
        "Similitudes: Ambas guardan el valor 2 en `margin` con `let`. Diferencias: Racket incluye `margin` en el mismo `let` que `count`, usando `(margin 2)`, mientras que OCaml usa una línea separada `let margin = 2 in`, lo que hace el código más largo pero claro.",
        "Similitudes: Ambas restan `margin` de `count` para el resultado final. Diferencias: Racket usa `(- count margin)` con paréntesis, mientras que OCaml usa `count - margin`, como una resta matemática. Ambos dan el mismo resultado, pero OCaml es más intuitivo para principiantes.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para indicar que viene la llamada de la función, una diferencia en la organización.",
        "Similitudes: Ambas aplican la función con 25 y 5, dando 3. Diferencias: Racket usa `(adjusted-event-count 25 5)` con paréntesis, mientras que OCaml usa `adjusted_event_count 25 5`, más corto y sin paréntesis."
      ]
    },
    "ejercicio-3": {
      "title": "Calcular Daño de Ataque en un Videojuego",
      "racket": {
        "lines": [
          "(define (damage level)",
          "  (let ((square (* level level))",
          "        (double (* 2 level)))",
          "    (+ square double)))",
          ")",
          "(damage 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "let damage level =",
          "  let square = level * level in",
          "  let double = 2 * level in",
          "  square + double",
          "in",
          "damage 8"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `damage` que toma un número `level`, como el nivel de un personaje en un videojuego. Imagina que eres un diseñador calculando cuánto daño hace un ataque. En Racket, `(define (nombre params) cuerpo)` es como hacer una receta para calcular el daño según el nivel.",
        "Aquí comenzamos un bloque `let` para crear dos cajas temporales: `square` guarda el cuadrado del nivel (`level * level`), como calcular la fuerza base del ataque. Es como anotar el primer paso en una libreta.",
        "Esta línea define `double` como `2 * level`, un bono extra por el nivel, como escribir el segundo paso en la libreta para no mezclar los números.",
        "Aquí sumamos `square` y `double` con `(+ square double)` para obtener el daño total, como combinar la fuerza base y el bono para el ataque final. Los paréntesis en Racket mantienen todo claro.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para completar la función.",
        "Esta línea usa la función con el nivel 8, calculando `(8 * 8) + (2 * 8) = 64 + 16 = 80`. Es como probar la receta para saber cuánto daño hace un personaje de nivel 8."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `damage` que toma `level`, como el nivel de un héroe en un juego. En OCaml, `let nombre params = cuerpo` es como hacer una receta para calcular el daño del ataque. La función está lista para recibir un número y procesarlo.",
        "Usamos `let square = level * level in` para guardar el cuadrado del nivel en una caja llamada `square`, como calcular la fuerza principal del ataque. El `in` dice que este valor se usará después.",
        "Esta línea guarda el doble del nivel (`2 * level`) en una caja llamada `double`, como un extra por la experiencia del héroe. El `in` indica que este valor se usará en el siguiente paso.",
        "Aquí sumamos `square` y `double` con `square + double`, como combinar la fuerza base y el extra para el daño total. En OCaml, la suma se escribe como en matemáticas, fácil de entender.",
        "Esta línea usa `in` para conectar la función con su uso, como decir 'ahora probemos la receta'. Es una regla de OCaml para organizar el código.",
        "Esta línea aplica la función con 8, dando `(8 * 8) + (2 * 8) = 64 + 16 = 80`, como confirmar el daño de un héroe de nivel 8."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el daño según el nivel, usando el mismo nombre y propósito. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml asume que `level` es un entero, Racket no especifica tipos.",
        "Similitudes: Ambas guardan el cuadrado del nivel en `square` usando `let`, como una libreta temporal. Diferencias: Racket usa `(let ((square (* level level)))` con paréntesis dobles, mientras que OCaml usa `let square = level * level in`, más simple y con `in`.",
        "Similitudes: Ambas guardan el doble del nivel en `double` con `let`. Diferencias: Racket incluye `double` en el mismo `let` que `square`, mientras que OCaml usa una línea separada `let double = 2 * level in`, haciendo el código más largo pero claro.",
        "Similitudes: Ambas suman `square` y `double` para el resultado final. Diferencias: Racket usa `(+ square double)` con paréntesis, mientras que OCaml usa `square + double`, como una suma matemática. Ambos dan el mismo resultado, pero OCaml es más intuitivo.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada, una diferencia en la organización.",
        "Similitudes: Ambas aplican la función con 8, dando 80. Diferencias: Racket usa `(damage 8)` con paréntesis, mientras que OCaml usa `damage 8`, más corto."
      ]
    },
    "ejercicio-4": {
      "title": "Calcular la Hipotenusa de un Triángulo",
      "racket": {
        "lines": [
          "(define (hypotenuse a b)",
          "  (let ((a-square (* a a))",
          "        (b-square (* b b)))",
          "    (sqrt (+ a-square b-square)))",
          ")",
          "(hypotenuse 6 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "let hypotenuse a b =",
          "  let a_square = a *. a in",
          "  let b_square = b *. b in",
          "  sqrt (a_square +. b_square)",
          "in",
          "hypotenuse 6.0 8.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `hypotenuse` que toma dos números, `a` y `b`, los lados de un triángulo. Imagina que eres un ingeniero diseñando un puente y necesitas la longitud de un soporte diagonal. En Racket, `(define (nombre params) cuerpo)` es como hacer una receta para este cálculo.",
        "Aquí comenzamos un bloque `let` para crear dos cajas: `a-square` guarda el cuadrado de `a` (`a * a`), como calcular una parte de la fórmula de Pitágoras. Es como anotar el primer paso en una libreta.",
        "Esta línea define `b-square` como `b * b`, el cuadrado del otro lado, como el segundo paso en la libreta para mantener los cálculos organizados.",
        "Aquí sumamos `a-square` y `b-square` con `(+ a-square b-square)`, luego tomamos la raíz cuadrada con `sqrt`, como encontrar la longitud del soporte diagonal. Los paréntesis en Racket hacen que todo esté claro.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con 6 y 8, calculando `sqrt((6 * 6) + (8 * 8)) = sqrt(36 + 64) = 10`. Es como probar la receta para un triángulo con lados de 6 y 8 metros."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `hypotenuse` que toma `a` y `b`, como los lados de un triángulo para un soporte. En OCaml, `let nombre params = cuerpo` es como hacer una receta para calcular la longitud diagonal. La función está lista para recibir dos números.",
        "Usamos `let a_square = a *. a in` para guardar el cuadrado de `a` en una caja llamada `a_square`, como un paso de la fórmula de Pitágoras. El `*.` es para números con decimales, y `in` dice que usaremos este valor después.",
        "Esta línea guarda el cuadrado de `b` (`b *. b`) en `b_square`, como otro paso de la fórmula. El `in` indica que este valor se usará a continuación.",
        "Aquí sumamos `a_square` y `b_square` con `+.`, luego tomamos la raíz cuadrada con `sqrt`, como calcular la longitud final del soporte. En OCaml, usamos `+.` para sumas con decimales, y la notación es como en matemáticas.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta para probarla. Es una regla de OCaml para organizar el código.",
        "Esta línea aplica la función con 6.0 y 8.0, dando `sqrt((6.0 * 6.0) + (8.0 * 8.0)) = 10`. Es como confirmar la longitud del soporte para un triángulo de 6 y 8 metros."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula la hipotenusa con dos números, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere números con decimales (6.0, 8.0), Racket acepta enteros.",
        "Similitudes: Ambas guardan el cuadrado de `a` en `a_square` usando `let`. Diferencias: Racket usa `(let ((a-square (* a a)))` con paréntesis, mientras que OCaml usa `let a_square = a *. a in`, con `*.` para decimales y `in` para conectar.",
        "Similitudes: Ambas guardan el cuadrado de `b` en `b_square`. Diferencias: Racket incluye `b-square` en el mismo `let`, mientras que OCaml usa una línea separada `let b_square = b *. b in`, más clara pero más larga.",
        "Similitudes: Ambas suman los cuadrados y toman la raíz cuadrada. Diferencias: Racket usa `(sqrt (+ a-square b-square))` con paréntesis, mientras que OCaml usa `sqrt (a_square +. b_square)` con `+.` para decimales. OCaml es más parecido a una fórmula matemática.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada, una diferencia en la organización.",
        "Similitudes: Ambas aplican la función con 6 y 8, dando 10. Diferencias: Racket usa `(hypotenuse 6 8)` con enteros, mientras que OCaml usa `hypotenuse 6.0 8.0` con decimales, porque OCaml es más estricto con los tipos."
      ]
    },
    "ejercicio-5": {
      "title": "Calcular el Volumen de una Olla Esférica",
      "racket": {
        "lines": [
          "(define (sphere-volume r)",
          "  (let ((cube (* r r r))",
          "        (pi 3.14159)",
          "        (fraction (/ 4 3)))",
          "    (* fraction pi cube)))",
          ")",
          "(sphere-volume 0.3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let sphere_volume r =",
          "  let cube = r *. r *. r in",
          "  let pi = 3.14159 in",
          "  let fraction = 4.0 /. 3.0 in",
          "  fraction *. pi *. cube",
          "in",
          "sphere_volume 0.3"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `sphere-volume` que toma un número `r` (radio), como si fueras un chef diseñando una olla redonda. En Racket, `(define (nombre params) cuerpo)` es como hacer una receta para calcular cuánto cabe en la olla.",
        "Aquí comenzamos un bloque `let` para crear tres cajas: `cube` guarda el cubo del radio (`r * r * r`), como calcular una parte de la fórmula del volumen. Es como anotar el primer paso en una libreta.",
        "Esta línea define `pi` como 3.14159, una constante para cálculos circulares, como un número mágico en la receta.",
        "Esta línea define `fraction` como `4/3`, otro paso de la fórmula, como anotar una proporción en la libreta.",
        "Aquí multiplicamos `fraction`, `pi`, y `cube` con `(* fraction pi cube)` para obtener el volumen, como mezclar todos los ingredientes para saber cuánto cabe en la olla. Los paréntesis mantienen todo ordenado.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con 0.3, calculando `(4/3) * 3.14159 * (0.3 * 0.3 * 0.3) ≈ 0.11309724`. Es como probar la receta para una olla con radio de 0.3 metros."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `sphere_volume` que toma `r`, como calcular el espacio en una olla esférica. En OCaml, `let nombre params = cuerpo` es como hacer una receta para el volumen. La función está lista para recibir un número.",
        "Usamos `let cube = r *. r *. r in` para guardar el cubo del radio en `cube`, como un paso de la fórmula. El `*.` es para números con decimales, y `in` dice que usaremos este valor después.",
        "Esta línea guarda 3.14159 en `pi`, como un número especial para cálculos de círculos. El `in` indica que se usará a continuación.",
        "Esta línea guarda `4.0 / 3.0` en `fraction`, como otro paso de la fórmula. El `/.` es para divisiones con decimales.",
        "Aquí multiplicamos `fraction`, `pi`, y `cube` con `fraction *. pi *. cube`, como combinar los pasos para el volumen final. En OCaml, usamos `*.` para multiplicaciones con decimales.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. Es una regla de OCaml.",
        "Esta línea aplica la función con 0.3, dando `(4.0 / 3.0) * 3.14159 * (0.3 * 0.3 * 0.3) ≈ 0.11309724`, como confirmar el volumen de la olla."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el volumen de una esfera, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (0.3), Racket acepta números sin especificar tipo.",
        "Similitudes: Ambas guardan el cubo del radio en `cube` usando `let`. Diferencias: Racket usa `(let ((cube (* r r r)))` con paréntesis, mientras que OCaml usa `let cube = r *. r *. r in` con `*.` para decimales y `in` para conectar.",
        "Similitudes: Ambas guardan 3.14159 en `pi`. Diferencias: Racket incluye `pi` en el mismo `let`, mientras que OCaml usa una línea separada `let pi = 3.14159 in`, más clara pero más larga.",
        "Similitudes: Ambas guardan `4/3` en `fraction`. Diferencias: Racket usa `(/ 4 3)` como fracción, mientras que OCaml usa `4.0 /. 3.0` con decimales y `/.` para división.",
        "Similitudes: Ambas multiplican `fraction`, `pi`, y `cube` para el volumen. Diferencias: Racket usa `(* fraction pi cube)` con paréntesis, mientras que OCaml usa `fraction *. pi *. cube` con `*.` para decimales, más parecido a una fórmula matemática.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada.",
        "Similitudes: Ambas aplican la función con 0.3, dando ≈0.11309724. Diferencias: Racket usa `(sphere-volume 0.3)`, OCaml usa `sphere_volume 0.3` con decimal explícito."
      ]
    },
    "ejercicio-6": {
      "title": "Calcular Interés Compuesto con Tarifa",
      "racket": {
        "lines": [
          "(define (compound-interest p r n t)",
          "  (let ((rate-factor (+ 1 (/ r n)))",
          "        (periods (* n t))",
          "        (fee 50))",
          "    (- (* p (expt rate-factor periods)) fee)))",
          ")",
          "(compound-interest 1000 0.04 12 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compound_interest p r n t =",
          "  let rate_factor = 1.0 +. (r /. n) in",
          "  let periods = n *. t in",
          "  let fee = 50.0 in",
          "  (p *. (rate_factor ** periods)) -. fee",
          "in",
          "compound_interest 1000.0 0.04 12.0 3.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `compound-interest` que toma cuatro números: `p` (dinero inicial), `r` (tasa de interés), `n` (veces que se aplica al año), y `t` (años). Imagina que eres un financiero calculando cuánto crecerá 1000 dólares. En Racket, `(define (nombre params) cuerpo)` es como una receta para este cálculo.",
        "Aquí comenzamos un bloque `let` para crear tres cajas: `rate-factor` guarda `1 + (r / n)`, como el crecimiento por período. Es como anotar el primer paso en una libreta.",
        "Esta línea define `periods` como `n * t`, como contar cuántas veces se aplica el interés, un segundo paso en la libreta.",
        "Esta línea define `fee` como 50, una tarifa fija que se resta al final, como un tercer paso en la libreta.",
        "Aquí multiplicamos `p` por `rate-factor` elevado a `periods` con `(expt rate-factor periods)`, luego restamos `fee`, como calcular el dinero final menos la tarifa. Los paréntesis mantienen todo ordenado.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con 1000, 0.04, 12, y 3, dando ≈1077.49786. Es como probar la receta para saber cuánto dinero tendrás después de 3 años."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `compound_interest` que toma `p`, `r`, `n`, y `t`, como calcular cuánto crecerá un ahorro. En OCaml, `let nombre params = cuerpo` es como una receta para este cálculo financiero.",
        "Usamos `let rate_factor = 1.0 +. (r /. n) in` para guardar el factor de crecimiento por período, como un paso de la fórmula. Los operadores `+.` y `/.` son para decimales, y `in` dice que usaremos este valor después.",
        "Esta línea guarda `n * t` en `periods`, como contar los períodos de interés. El `*.` es para multiplicaciones con decimales.",
        "Esta línea guarda 50.0 en `fee`, como una tarifa que se resta al final. El `in` organiza el cálculo.",
        "Aquí multiplicamos `p` por `rate-factor` elevado a `periods` con `(rate_factor ** periods)`, luego restamos `fee` con `-.`, como calcular el dinero final. En OCaml, usamos operadores para decimales.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. Es una regla de OCaml.",
        "Esta línea aplica la función con 1000.0, 0.04, 12.0, y 3.0, dando ≈1077.49786, como confirmar el crecimiento del dinero."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función para calcular interés compuesto, usando el mismo nombre y cuatro parámetros. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (1000.0, 0.04), Racket acepta números sin especificar tipo.",
        "Similitudes: Ambas guardan el factor de interés en `rate_factor` con `let`. Diferencias: Racket usa `(let ((rate-factor (+ 1 (/ r n))))` con paréntesis, mientras que OCaml usa `let rate_factor = 1.0 +. (r /. n) in` con operadores para decimales y `in`.",
        "Similitudes: Ambas guardan `n * t` en `periods`. Diferencias: Racket incluye `periods` en el mismo `let`, mientras que OCaml usa una línea separada `let periods = n *. t in`, más clara pero más larga.",
        "Similitudes: Ambas guardan 50 en `fee`. Diferencias: Racket usa `(fee 50)`, OCaml usa `let fee = 50.0 in` con decimal explícito.",
        "Similitudes: Ambas calculan `p * (rate-factor ^ periods) - fee`. Diferencias: Racket usa `(* p (expt rate-factor periods))` y `(- ... fee)` con paréntesis, mientras que OCaml usa `(p *. (rate_factor ** periods)) -. fee` con operadores para decimales, más parecido a matemáticas.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada.",
        "Similitudes: Ambas aplican la función con los mismos valores, dando ≈1077.49786. Diferencias: Racket usa `(compound-interest 1000 0.04 12 3)`, OCaml usa `compound_interest 1000.0 0.04 12.0 3.0` con decimales."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular Distancia entre Estrellas en 3D",
      "racket": {
        "lines": [
          "(define (distance-3d x1 y1 z1 x2 y2 z2)",
          "  (let ((dx (- x2 x1))",
          "        (dy (- y2 y1))",
          "        (dz (- z2 z1)))",
          "    (let ((dx-square (* dx dx))",
          "          (dy-square (* dy dy))",
          "          (dz-square (* dz dz)))",
          "      (sqrt (+ dx-square dy-square dz-square))))",
          ")",
          "(distance-3d 2 3 4 5 7 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "let distance_3d x1 y1 z1 x2 y2 z2 =",
          "  let dx = x2 -. x1 in",
          "  let dy = y2 -. y1 in",
          "  let dz = z2 -. z1 in",
          "  let dx_square = dx *. dx in",
          "  let dy_square = dy *. dy in",
          "  let dz_square = dz *. dz in",
          "  sqrt (dx_square +. dy_square +. dz_square)",
          "in",
          "distance_3d 2.0 3.0 4.0 5.0 7.0 8.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `distance-3d` que toma seis números (coordenadas de dos puntos en el espacio: `x1, y1, z1` y `x2, y2, z2`). Imagina que eres un astrónomo midiendo la distancia entre dos estrellas. En Racket, `(define (nombre params) cuerpo)` es como una receta para este cálculo complejo.",
        "Aquí comenzamos un bloque `let` para crear tres cajas: `dx` guarda la diferencia `x2 - x1`, como medir cuánto se mueven las estrellas en la dirección horizontal. Es como anotar el primer paso en una libreta.",
        "Esta línea define `dy` como `y2 - y1`, la diferencia en la dirección vertical, como un segundo paso en la libreta.",
        "Esta línea define `dz` como `z2 - z1`, la diferencia en profundidad, completando las diferencias en las tres direcciones.",
        "Aquí comenzamos otro bloque `let` para crear tres cajas más: `dx-square` guarda el cuadrado de `dx`, como calcular una parte de la fórmula de distancia. Es como un nuevo paso en la libreta.",
        "Esta línea define `dy-square` como el cuadrado de `dy`, la diferencia vertical al cuadrado, como otro paso.",
        "Esta línea define `dz-square` como el cuadrado de `dz`, la diferencia en profundidad al cuadrado, completando los cuadrados.",
        "Aquí sumamos `dx-square`, `dy-square`, y `dz-square` con `(+ dx-square dy-square dz-square)`, luego tomamos la raíz cuadrada con `sqrt`, como encontrar la distancia final entre las estrellas. Los paréntesis mantienen todo claro.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria.",
        "Esta línea usa la función con las coordenadas (2, 3, 4) y (5, 7, 8), dando ≈6.403124237. Es como probar la receta para medir la distancia entre dos estrellas."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `distance_3d` que toma seis números, las coordenadas de dos puntos, como medir la distancia entre dos planetas. En OCaml, `let nombre params = cuerpo` es como una receta para este cálculo.",
        "Usamos `let dx = x2 -. x1 in` para guardar la diferencia horizontal en `dx`, como un paso de la fórmula. El `-.` es para restas con decimales, y `in` dice que usaremos este valor.",
        "Esta línea guarda la diferencia vertical en `dy`, como medir cuánto se mueve un planeta hacia arriba.",
        "Esta línea guarda la diferencia en profundidad en `dz`, completando las diferencias en las tres direcciones.",
        "Usamos `let dx_square = dx *. dx in` para guardar el cuadrado de `dx`, como un paso para la fórmula de distancia.",
        "Esta línea guarda el cuadrado de `dy` en `dy_square`, como otro paso.",
        "Esta línea guarda el cuadrado de `dz` en `dz_square`, completando los cuadrados.",
        "Aquí sumamos `dx_square`, `dy_square`, y `dz_square` con `+.`, luego tomamos la raíz cuadrada con `sqrt`, como calcular la distancia final. En OCaml, usamos `+.` para sumas con decimales.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con (2.0, 3.0, 4.0) y (5.0, 7.0, 8.0), dando ≈6.403124237, como confirmar la distancia entre planetas."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula la distancia 3D con seis parámetros, usando el mismo nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (2.0, 3.0, etc.), Racket acepta enteros.",
        "Similitudes: Ambas guardan la diferencia horizontal en `dx` con `let`. Diferencias: Racket usa `(let ((dx (- x2 x1)))` con paréntesis, mientras que OCaml usa `let dx = x2 -. x1 in` con `-.` para decimales y `in`.",
        "Similitudes: Ambas guardan la diferencia vertical en `dy`. Diferencias: Racket incluye `dy` en el mismo `let`, mientras que OCaml usa una línea separada, más clara pero más larga.",
        "Similitudes: Ambas guardan la diferencia en profundidad en `dz`. Diferencias: Como antes, Racket usa un solo `let`, OCaml usa líneas separadas.",
        "Similitudes: Ambas guardan el cuadrado de `dx` en `dx_square`. Diferencias: Racket usa un segundo `let` con paréntesis, OCaml usa una nueva línea con `*.` para decimales.",
        "Similitudes: Ambas guardan el cuadrado de `dy`. Diferencias: Racket incluye `dy-square` en el segundo `let`, OCaml usa una línea separada.",
        "Similitudes: Ambas guardan el cuadrado de `dz`. Diferencias: Igual que con `dy-square`, OCaml usa más líneas, Racket es más compacto.",
        "Similitudes: Ambas suman los cuadrados y toman la raíz cuadrada. Diferencias: Racket usa `(sqrt (+ dx-square dy-square dz-square))` con paréntesis, mientras que OCaml usa `sqrt (dx_square +. dy_square +. dz_square)` con `+.` para decimales, más matemático.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para la llamada.",
        "Similitudes: Ambas aplican la función con las mismas coordenadas, dando ≈6.403124237. Diferencias: Racket usa `(distance-3d 2 3 4 5 7 8)` con enteros, OCaml usa `distance_3d 2.0 3.0 4.0 5.0 7.0 8.0` con decimales."
      ]
    }
  },
  "funciones-multiples": {
    "ejercicio-1": {
      "title": "Calcular el Área de un Mural Triangular",
      "racket": {
        "lines": [
          "(define (triangle-area base height)",
          "  (/ (* base height) 2)",
          ")",
          "(triangle-area 8 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let triangle_area base height =",
          "  (base *. height) /. 2.0",
          "in",
          "triangle_area 8.0 5.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `triangle-area` que toma dos parámetros, `base` y `height`, para calcular el área de un triángulo. Imagina que eres un artista pintando un mural triangular de 8 metros de base y 5 de altura. En Racket, `(define (nombre params) cuerpo)` es como escribir una receta sencilla para saber cuánta pintura necesitas.",
        "Aquí multiplicamos `base` por `height` con `(* base height)` y dividimos por 2 con `(/ ... 2)`, como calcular el área (base * altura / 2). Los paréntesis organizan la operación en una línea clara, dando el resultado final.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta. No hace cálculos, pero es necesaria para completar la función.",
        "Esta línea aplica la función con 8 y 5, dando `(8 * 5) / 2 = 20`. Es como probar la receta para confirmar que el mural requiere pintura para 20 metros cuadrados."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `triangle_area` que toma `base` y `height`, como calcular el área de un mural triangular. En OCaml, `let nombre params = cuerpo` es como una receta sencilla. La función está lista para recibir dos números.",
        "Aquí multiplicamos `base` por `height` con `base *. height` y dividimos por 2.0 con `/.`, como calcular el área (base * altura / 2). El `*.` y `/.` son para números con decimales, dando un resultado preciso.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta antes de probarla. Es una regla de OCaml, sin cálculos.",
        "Esta línea aplica la función con 8.0 y 5.0, dando `(8.0 * 5.0) / 2.0 = 20.0`. Es como confirmar el área del mural para planificar la pintura."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el área de un triángulo con dos parámetros, con el mismo propósito y resultado (20). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales (8.0, 5.0), Racket acepta enteros.",
        "Similitudes: Ambas realizan la multiplicación y división en una línea, dando el mismo resultado. Diferencias: Racket usa `(/ (* base height) 2)` con notación prefija y paréntesis, mientras que OCaml usa `(base *. height) /. 2.0` con notación infija, más parecida a matemáticas. OCaml usa operadores `*.` y `/.` para decimales.",
        "Similitudes: Ambas son estructurales, sin cálculos. Diferencias: Racket cierra la función con `)`, mientras que OCaml usa `in` para conectar con la evaluación.",
        "Similitudes: Ambas aplican la función con 8 y 5, dando 20. Diferencias: Racket usa `(triangle-area 8 5)` con paréntesis y enteros, mientras que OCaml usa `triangle_area 8.0 5.0` sin paréntesis y con decimales."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar si Tres Tiempos de Tareas Están en Orden Ascendente",
      "racket": {
        "lines": [
          "(define (ascending? a b c)",
          "  (let ((ab (< a b))",
          "        (bc (< b c)))",
          "    (and ab bc))",
          ")",
          "(ascending? 2 3 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let ascending a b c =",
          "  let ab = a < b in",
          "  let bc = b < c in",
          "  ab && bc",
          "in",
          "ascending 2 3 4"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `ascending?` que toma tres parámetros, `a`, `b`, `c`, como tiempos de tareas (2, 3, 4 minutos). Imagina que eres un organizador verificando si las tareas toman tiempos crecientes. En Racket, `(define (nombre params) cuerpo)` es como una receta para esta validación lógica.",
        "Aquí comenzamos un bloque `let` para crear una variable `ab` que guarda si `a` es menor que `b` con `(< a b)`. Es como anotar en una libreta si la primera tarea es más corta que la segunda.",
        "Esta línea define `bc` como `(< b c)`, verificando si `b` es menor que `c`. Es como anotar si la segunda tarea es más corta que la tercera.",
        "Aquí combinamos `ab` y `bc` con `and` para verificar que ambas condiciones son ciertas, retornando `true` si los tiempos están en orden ascendente. Es como revisar la libreta para confirmar el orden.",
        "Esta línea cierra la definición de la función con un paréntesis, como poner el punto final en la receta.",
        "Esta línea aplica la función con 2, 3, 4, verificando `2 < 3` y `3 < 4`, dando `true`. Es como probar la receta para confirmar el orden ascendente."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `ascending` que toma `a`, `b`, `c`, como tiempos de tareas. En OCaml, `let nombre params = cuerpo` es como una receta para verificar si los tiempos crecen. La función está lista para tres números.",
        "Aquí definimos `ab` como `a < b`, verificando si `a` es menor que `b`. Es como anotar si la primera tarea es más corta que la segunda. El `in` indica que usaremos este valor después.",
        "Esta línea define `bc` como `b < c`, verificando si `b` es menor que `c`. Es como anotar si la segunda tarea es más corta que la tercera.",
        "Aquí combinamos `ab` y `bc` con `&&`, retornando `true` si ambas son ciertas. Es como revisar las anotaciones para confirmar el orden ascendente.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. No hace cálculos.",
        "Esta línea aplica la función con 2, 3, 4, verificando `2 < 3` y `3 < 4`, dando `true`. Es como confirmar el orden de las tareas."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que verifica si tres números están en orden ascendente, con el mismo propósito y resultado (`true`). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis y `ascending?` (con ? para booleano), mientras que OCaml usa `let nombre params = cuerpo` y `ascending`, más corto.",
        "Similitudes: Ambas definen una variable para `a < b`. Diferencias: Racket usa `(let ((ab (< a b)))` con paréntesis y notación prefija, mientras que OCaml usa `let ab = a < b in` con notación infija y `in` para conectar pasos.",
        "Similitudes: Ambas definen una variable para `b < c`. Diferencias: Racket incluye `bc` en el mismo `let`, mientras OCaml usa una línea separada `let bc = b < c in`, más clara para principiantes.",
        "Similitudes: Ambas combinan las condiciones con un operador lógico (`and` en Racket, `&&` en OCaml). Diferencias: Racket usa `(and ab bc)` con paréntesis, mientras que OCaml usa `ab && bc`, más simple y matemático.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in` para la evaluación.",
        "Similitudes: Ambas aplican la función con 2, 3, 4, dando `true`. Diferencias: Racket usa `(ascending? 2 3 4)` con paréntesis, OCaml usa `ascending 2 3 4`, más corto."
      ]
    },
    "ejercicio-3": {
      "title": "Calcular la Distancia Euclidiana entre Dos Puntos",
      "racket": {
        "lines": [
          "(define (distance x1 y1 x2 y2)",
          "  (sqrt (+ (expt (- x2 x1) 2)",
          "           (expt (- y2 y1) 2))",
          "  )",
          ")",
          "(distance 1 2 4 6)"
        ]
      },
      "ocaml": {
        "lines": [
          "let distance x1 y1 x2 y2 =",
          "  sqrt ((x2 -. x1) ** 2.0 +.",
          "        (y2 -. y1) ** 2.0)",
          "in",
          "distance 1.0 2.0 4.0 6.0"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `distance` que toma cuatro parámetros, `x1`, `y1`, `x2`, `y2`, como coordenadas de dos puntos (1,2) y (4,6). Imagina que eres un estudiante midiendo cuánto caminaste entre esos puntos. En Racket, `(define (nombre params) cuerpo)` es como una receta para calcular la distancia euclidiana.",
        "Aquí calculamos la raíz cuadrada con `sqrt` de una suma. La suma incluye `(expt (- x2 x1) 2)`, que calcula el cuadrado de la diferencia horizontal (x2-x1). Es como medir cuánto te moviste en horizontal.",
        "Esta línea agrega `(expt (- y2 y1) 2)`, el cuadrado de la diferencia vertical (y2-y1), completando la fórmula `sqrt((x2-x1)^2 + (y2-y1)^2)`. Es como medir el movimiento vertical y combinarlo.",
        "Esta línea cierra el bloque `sqrt` con un paréntesis, asegurando que la suma se calcule primero. No hace cálculos, pero organiza la fórmula.",
        "Esta línea cierra la definición de la función con otro paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 1, 2, 4, 6, dando `sqrt((4-1)^2 + (6-2)^2) = sqrt(9 + 16) = 5`. Es como probar la receta para medir la caminata."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `distance` que toma `x1`, `y1`, `x2`, `y2`, como coordenadas. En OCaml, `let nombre params = cuerpo` es como una receta para calcular la distancia. La función está lista para cuatro números.",
        "Aquí calculamos la raíz cuadrada con `sqrt` de una suma. `(x2 -. x1) ** 2.0` calcula el cuadrado de la diferencia horizontal, usando `-.` y `**` para decimales. Es como medir el movimiento horizontal.",
        "Esta línea agrega `(y2 -. y1) ** 2.0` con `+.`, completando la fórmula `sqrt((x2-x1)^2 + (y2-y1)^2)`. Es como medir el movimiento vertical y sumarlo.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta. No hace cálculos.",
        "Esta línea aplica la función con 1.0, 2.0, 4.0, 6.0, dando `sqrt((4.0-1.0)^2 + (6.0-2.0)^2) = 5.0`. Es como confirmar la distancia de la caminata."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula la distancia euclidiana con cuatro parámetros, con el mismo propósito y resultado (5). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales, Racket acepta enteros.",
        "Similitudes: Ambas calculan el cuadrado de la diferencia horizontal dentro de una raíz. Diferencias: Racket usa `(expt (- x2 x1) 2)` con notación prefija, mientras que OCaml usa `(x2 -. x1) ** 2.0` con notación infija y operadores `-.` y `**` para decimales.",
        "Similitudes: Ambas suman el cuadrado de la diferencia vertical para completar la fórmula. Diferencias: Racket usa `(+ ...)` con paréntesis, mientras que OCaml usa `+.` para suma con decimales, más intuitiva como ecuación matemática.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `sqrt` con `)`, OCaml usa `in` para la evaluación.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml no necesita un cierre adicional aquí.",
        "Similitudes: Ambas aplican la función con 1, 2, 4, 6, dando 5. Diferencias: Racket usa `(distance 1 2 4 6)` con paréntesis y enteros, OCaml usa `distance 1.0 2.0 4.0 6.0` con decimales."
      ]
    },
    "ejercicio-4": {
      "title": "Encontrar el Máximo de Tres Puntajes en un Torneo",
      "racket": {
        "lines": [
          "(define (max-of-three a b c)",
          "  (let ((bc (max b c))",
          "        (max-abc (max a bc)))",
          "    max-abc)",
          ")",
          "(max-of-three 6 8 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let max_of_three a b c =",
          "  let bc = max b c in",
          "  let max_abc = max a bc in",
          "  max_abc",
          "in",
          "max_of_three 6 8 4"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `max-of-three` que toma tres parámetros, `a`, `b`, `c`, como puntajes en un torneo (6, 8, 4). Imagina que eres un juez buscando el puntaje más alto. En Racket, `(define (nombre params) cuerpo)` es como una receta para esta comparación.",
        "Aquí comenzamos un bloque `let` y definimos `bc` como `(max b c)`, que encuentra el mayor entre `b` y `c`. Es como anotar en una libreta cuál de los dos últimos puntajes es mayor.",
        "Esta línea define `max-abc` como `(max a bc)`, comparando `a` con el resultado anterior. Es como decidir si el primer puntaje supera al mayor de los otros dos.",
        "Aquí retornamos `max-abc`, el puntaje más alto. Es como entregar el resultado final de la comparación.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 6, 8, 4, dando `max(6, max(8, 4)) = max(6, 8) = 8`. Es como probar la receta para encontrar el puntaje más alto."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `max_of_three` que toma `a`, `b`, `c`, como puntajes. En OCaml, `let nombre params = cuerpo` es como una receta para encontrar el máximo. La función está lista para tres números.",
        "Aquí definimos `bc` como `max b c`, que encuentra el mayor entre `b` y `c`. Es como anotar cuál de los dos últimos puntajes es mayor. El `in` indica que usaremos este valor.",
        "Esta línea define `max_abc` como `max a bc`, comparando `a` con el resultado anterior. Es como verificar si el primer puntaje es mayor.",
        "Aquí retornamos `max_abc`, el puntaje más alto. Es como entregar el resultado final.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 6, 8, 4, dando `max(6, max(8, 4)) = 8`. Es como confirmar el puntaje más alto."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que encuentra el máximo de tres números, con el mismo propósito y resultado (8). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml asume enteros, Racket no especifica tipos.",
        "Similitudes: Ambas definen una variable para el máximo de `b` y `c`. Diferencias: Racket usa `(let ((bc (max b c)))` con paréntesis, mientras que OCaml usa `let bc = max b c in` con notación infija y `in`.",
        "Similitudes: Ambas comparan `a` con el máximo anterior. Diferencias: Racket incluye `max-abc` en el mismo `let`, mientras que OCaml usa una línea separada `let max_abc = max a bc in`, más clara.",
        "Similitudes: Ambas retornan el resultado final (`max-abc`). Diferencias: Racket usa `max-abc` dentro del `let`, OCaml lo retorna directamente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 6, 8, 4, dando 8. Diferencias: Racket usa `(max-of-three 6 8 4)` con paréntesis, OCaml usa `max_of_three 6 8 4`, más corto."
      ]
    },
    "ejercicio-5": {
      "title": "Calcular el Promedio de Tres Gastos de Amigos",
      "racket": {
        "lines": [
          "(define (average-three a b c)",
          "  (let ((sum (+ a b c))",
          "        (avg (/ sum 3)))",
          "    avg)",
          ")",
          "(average-three 10 15 20)"
        ]
      },
      "ocaml": {
        "lines": [
          "let average_three a b c =",
          "  let sum = a + b + c in",
          "  let avg = sum / 3 in",
          "  avg",
          "in",
          "average_three 10 15 20"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `average-three` que toma tres parámetros, `a`, `b`, `c`, como gastos de amigos (10, 15, 20 dólares). Imagina que quieres saber cuánto gastaron en promedio. En Racket, `(define (nombre params) cuerpo)` es como una receta para calcular promedios.",
        "Aquí comenzamos un bloque `let` y definimos `sum` como `(+ a b c)`, sumando los tres gastos. Es como anotar en una libreta el total gastado por los amigos.",
        "Esta línea define `avg` como `(/ sum 3)`, dividiendo la suma por 3 para obtener el promedio. Es como calcular cuánto le toca a cada amigo si dividen el total.",
        "Aquí retornamos `avg`, el promedio final. Es como entregar el resultado de la división.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 10, 15, 20, dando `(10 + 15 + 20) / 3 = 15`. Es como probar la receta para confirmar el promedio."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `average_three` que toma `a`, `b`, `c`, como gastos. En OCaml, `let nombre params = cuerpo` es como una receta para promedios. La función está lista para tres números.",
        "Aquí definimos `sum` como `a + b + c`, sumando los gastos. Es como anotar el total en una libreta. El `in` indica que usaremos este valor.",
        "Esta línea define `avg` como `sum / 3`, dividiendo la suma por 3. Es como calcular el promedio por amigo.",
        "Aquí retornamos `avg`, el promedio final. Es como entregar el resultado.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 10, 15, 20, dando `(10 + 15 + 20) / 3 = 15`. Es como confirmar el promedio."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el promedio de tres números, con el mismo propósito y resultado (15). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml asume enteros, Racket no especifica tipos.",
        "Similitudes: Ambas suman los tres parámetros en una variable `sum`. Diferencias: Racket usa `(let ((sum (+ a b c)))` con paréntesis, mientras que OCaml usa `let sum = a + b + c in` con notación infija y `in`.",
        "Similitudes: Ambas dividen la suma por 3 para el promedio. Diferencias: Racket usa `(/ sum 3)` en el `let`, mientras que OCaml usa `let avg = sum / 3 in`, más clara.",
        "Similitudes: Ambas retornan el promedio (`avg`). Diferencias: Racket usa `avg` dentro del `let`, OCaml lo retorna directamente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 10, 15, 20, dando 15. Diferencias: Racket usa `(average-three 10 15 20)` con paréntesis, OCaml usa `average_three 10 15 20`, más corto."
      ]
    },
    "ejercicio-6": {
      "title": "Verificar si Tres Presiones Son Positivas y Ascendentes",
      "racket": {
        "lines": [
          "(define (positive-and-ascending? a b c)",
          "  (let ((pos-a (> a 0))",
          "        (pos-b (> b 0))",
          "        (pos-c (> c 0))",
          "        (asc-ab (< a b))",
          "        (asc-bc (< b c)))",
          "    (and pos-a pos-b pos-c asc-ab asc-bc))",
          ")",
          "(positive-and-ascending? 2 3 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let positive_and_ascending a b c =",
          "  let pos_a = a > 0 in",
          "  let pos_b = b > 0 in",
          "  let pos_c = c > 0 in",
          "  let asc_ab = a < b in",
          "  let asc_bc = b < c in",
          "  pos_a && pos_b && pos_c && asc_ab && asc_bc",
          "in",
          "positive_and_ascending 2 3 4"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `positive-and-ascending?` que toma tres parámetros, `a`, `b`, `c`, como presiones (2, 3, 4 kPa). Imagina que eres un científico verificando si todas son positivas y en orden ascendente. En Racket, `(define (nombre params) cuerpo)` es como una receta para esta validación compleja.",
        "Aquí comenzamos un bloque `let` y definimos `pos-a` como `> a 0`, verificando si `a` es positivo. Es como anotar si la primera presión es válida.",
        "Esta línea define `pos-b` como `> b 0`, verificando si `b` es positivo. Es como chequear la segunda presión.",
        "Esta línea define `pos-c` como `> c 0`, verificando si `c` es positivo. Es como confirmar la tercera presión.",
        "Esta línea define `asc-ab` como `(< a b)`, verificando si `a` es menor que `b`. Es como anotar si la primera presión es menor que la segunda.",
        "Esta línea define `asc-bc` como `(< b c)`, verificando si `b` es menor que `c`. Es como confirmar el orden ascendente.",
        "Aquí combinamos todas las condiciones con `and`, retornando `true` si todas son ciertas. Es como revisar la libreta para confirmar positividad y orden.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 2, 3, 4, verificando `2 > 0`, `3 > 0`, `4 > 0`, `2 < 3`, `3 < 4`, dando `true`. Es como probar la receta."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `positive_and_ascending` que toma `a`, `b`, `c`, como presiones. En OCaml, `let nombre params = cuerpo` es como una receta para verificar positividad y orden. La función está lista para tres números.",
        "Aquí definimos `pos_a` como `a > 0`, verificando si `a` es positivo. Es como anotar si la primera presión es válida. El `in` indica que usaremos este valor.",
        "Esta línea define `pos_b` como `b > 0`, verificando la segunda presión.",
        "Esta línea define `pos_c` como `c > 0`, verificando la tercera presión.",
        "Esta línea define `asc_ab` como `a < b`, verificando el orden entre la primera y segunda presión.",
        "Esta línea define `asc_bc` como `b < c`, verificando el orden entre la segunda y tercera presión.",
        "Aquí combinamos todas las condiciones con `&&`, retornando `true` si todas son ciertas. Es como revisar todas las anotaciones.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 2, 3, 4, verificando todas las condiciones, dando `true`. Es como confirmar la validez y orden de las presiones."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que verifica positividad y orden ascendente, con el mismo propósito y resultado (`true`). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis y `positive-and-ascending?` (con ? para booleano), mientras que OCaml usa `let nombre params = cuerpo` y `positive_and_ascending`.",
        "Similitudes: Ambas verifican si `a` es positivo. Diferencias: Racket usa `(let ((pos-a (> a 0)))` con paréntesis, OCaml usa `let pos_a = a > 0 in` con notación infija y `in`.",
        "Similitudes: Ambas verifican si `b` es positivo. Diferencias: Racket incluye `pos-b` en el mismo `let`, OCaml usa una línea separada `let pos_b = b > 0 in`.",
        "Similitudes: Ambas verifican si `c` es positivo. Diferencias: Racket usa el mismo `let`, OCaml usa `let pos_c = c > 0 in`.",
        "Similitudes: Ambas verifican si `a < b`. Diferencias: Racket usa `(< a b)`, OCaml usa `a < b` con `in`.",
        "Similitudes: Ambas verifican si `b < c`. Diferencias: Racket usa `(< b c)`, OCaml usa `b < c` con `in`.",
        "Similitudes: Ambas combinan condiciones con un operador lógico (`and` en Racket, `&&` en OCaml). Diferencias: Racket usa `(and ...)` con paréntesis, OCaml usa `&&` con notación infija.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 2, 3, 4, dando `true`. Diferencias: Racket usa `(positive-and-ascending? 2 3 4)` con paréntesis, OCaml usa `positive_and_ascending 2 3 4`."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular el Volumen Útil de una Caja con Márgenes",
      "racket": {
        "lines": [
          "(define (useful-cuboid-volume l w h margin)",
          "  (let ((adj-l (- l (* 2 margin)))",
          "        (adj-w (- w (* 2 margin)))",
          "        (adj-h (- h (* 2 margin)))",
          "        (lw (* adj-l adj-w))",
          "        (volume (* lw adj-h)))",
          "    volume)",
          ")",
          "(useful-cuboid-volume 3 2 4 0.1)"
        ]
      },
      "ocaml": {
        "lines": [
          "let useful_cuboid_volume l w h margin =",
          "  let adj_l = l -. (2.0 *. margin) in",
          "  let adj_w = w -. (2.0 *. margin) in",
          "  let adj_h = h -. (2.0 *. margin) in",
          "  let lw = adj_l *. adj_w in",
          "  let volume = lw *. adj_h in",
          "  volume",
          "in",
          "useful_cuboid_volume 3.0 2.0 4.0 0.1"
        ]
      },
      "explanations_racket": [
        "Esta línea crea una función `useful-cuboid-volume` que toma cuatro parámetros, `l`, `w`, `h`, `margin`, como dimensiones de una caja (3, 2, 4 metros) y un margen (0.1 metros). Imagina que eres una empresa calculando el volumen útil de una caja, descontando márgenes en cada lado. En Racket, `(define (nombre params) cuerpo)` es como una receta compleja.",
        "Aquí comenzamos un bloque `let` y definimos `adj-l` como `(- l (* 2 margin))`, restando el doble del margen al largo. Es como anotar el largo útil después de descontar espacio en ambos lados.",
        "Esta línea define `adj-w` como `(- w (* 2 margin))`, ajustando el ancho. Es como calcular el ancho útil.",
        "Esta línea define `adj-h` como `(- h (* 2 margin))`, ajustando la altura. Es como obtener la altura útil.",
        "Esta línea define `lw` como `(* adj-l adj-w)`, multiplicando largo y ancho ajustados. Es como calcular el área útil de la base.",
        "Esta línea define `volume` como `(* lw adj-h)`, multiplicando el área por la altura ajustada. Es como obtener el volumen útil final.",
        "Aquí retornamos `volume`, el resultado final. Es como entregar el volumen útil de la caja.",
        "Esta línea cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Esta línea aplica la función con 3, 2, 4, 0.1, dando `(3-2*0.1) * (2-2*0.1) * (4-2*0.1) = 2.8 * 1.8 * 3.8 = 19.008`. Es como probar la receta."
      ],
      "explanations_ocaml": [
        "Esta línea crea una función `useful_cuboid_volume` que toma `l`, `w`, `h`, `margin`, como dimensiones y un margen. En OCaml, `let nombre params = cuerpo` es como una receta para calcular el volumen útil. La función está lista para cuatro números.",
        "Aquí definimos `adj_l` como `l -. (2.0 *. margin)`, restando el doble del margen al largo. Es como anotar el largo útil. El `-.` y `*.` son para decimales.",
        "Esta línea define `adj_w` como `w -. (2.0 *. margin)`, ajustando el ancho útil.",
        "Esta línea define `adj_h` como `h -. (2.0 *. margin)`, ajustando la altura útil.",
        "Esta línea define `lw` como `adj_l *. adj_w`, calculando el área útil de la base.",
        "Esta línea define `volume` como `lw *. adj_h`, calculando el volumen útil final.",
        "Aquí retornamos `volume`, el resultado final.",
        "Esta línea usa `in` para conectar la función con su uso, como preparar la receta.",
        "Esta línea aplica la función con 3.0, 2.0, 4.0, 0.1, dando `2.8 * 1.8 * 3.8 = 19.008`. Es como confirmar el volumen útil."
      ],
      "comparisons": [
        "Similitudes: Ambas crean una función que calcula el volumen útil de una caja con cuatro parámetros, con el mismo propósito y resultado (19.008). Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más corto. OCaml requiere decimales, Racket acepta enteros.",
        "Similitudes: Ambas ajustan el largo restando el doble del margen. Diferencias: Racket usa `(- l (* 2 margin))` con paréntesis, OCaml usa `l -. (2.0 *. margin)` con notación infija y operadores `-.`, `*.`.",
        "Similitudes: Ambas ajustan el ancho. Diferencias: Racket incluye `adj-w` en el mismo `let`, OCaml usa `let adj_w = ... in`.",
        "Similitudes: Ambas ajustan la altura. Diferencias: Racket usa el mismo `let`, OCaml usa una línea separada.",
        "Similitudes: Ambas calculan el área de la base. Diferencias: Racket usa `(* adj-l adj-w)`, OCaml usa `adj_l *. adj_w` con `*.`.",
        "Similitudes: Ambas calculan el volumen final. Diferencias: Racket usa `(* lw adj-h)`, OCaml usa `lw *. adj_h`.",
        "Similitudes: Ambas retornan el volumen. Diferencias: Racket usa `volume` en el `let`, OCaml lo retorna directamente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con 3, 2, 4, 0.1, dando 19.008. Diferencias: Racket usa `(useful-cuboid-volume 3 2 4 0.1)` con paréntesis, OCaml usa `useful_cuboid_volume 3.0 2.0 4.0 0.1`."
      ]
    }
  },
  "condicionales": {
    "ejercicio-1": {
      "title": "Máximo de dos números",
      "racket": {
        "lines": [
          "(define (max-two a b)",
          "  (if (> a b)",
          "      a",
          "      b",
          "  )",
          ")",
          "(max-two 10 7)"
        ]
      },
      "ocaml": {
        "lines": [
          "let max_two a b =",
          "  if a > b then",
          "    a",
          "  else",
          "    b",
          "in",
          "max_two 10 7"
        ]
      },
      "explanations_racket": [
        "Define una función `max-two` que toma dos parámetros (`a`, `b`) para encontrar el mayor. La sintaxis `(define (nombre params) cuerpo)` es funcional, como elegir el mayor de dos ofertas en una subasta.",
        "Inicia un condicional `if` que evalúa si `a > b` usando `>` en notación prefija. Es una expresión pura, como decidir cuál de dos precios es más alto.",
        "Si `a > b` es verdadero, retorna `a`, seleccionando el mayor valor, como elegir la oferta más alta.",
        "Si `a > b` es falso, retorna `b`, formando la rama 'else' del condicional.",
        "Cierra el bloque `if`, asegurando que la función retorne un valor puro.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `max-two` con 10 y 7, retornando 10 porque `10 > 7`, mostrando la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `max_two` con dos parámetros para encontrar el mayor, usando `let nombre params = cuerpo`. Es una abstracción funcional, como seleccionar la mayor puja en un mercado.",
        "Inicia un condicional `if` con `a > b` en notación infija, evaluando cuál es mayor. Es una expresión pura, como comparar dos cantidades.",
        "Si `a > b`, retorna `a`, seleccionando el mayor valor, como elegir el mejor precio.",
        "Introduce la rama `else`, necesaria en OCaml para garantizar un valor en todos los casos, retornando `b` si `a` no es mayor.",
        "Cierra la rama `else` con `b`, completando el condicional con un valor puro.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `max_two` con 10 y 7, retornando 10 porque `10 > 7`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para encontrar el máximo de dos números, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, reflejando su herencia Lisp, mientras que OCaml usa `let nombre params = cuerpo`, más conciso. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas evalúan `a > b` con pureza funcional. Diferencias: Racket usa `>` en notación prefija, más explícita, mientras que OCaml usa infija, más matemática y concisa.",
        "Similitudes: Ambas retornan `a` si es mayor, con pureza. Diferencias: Racket integra la rama 'then' en el `if`, mientras que OCaml usa `then` explícitamente, requiriendo una estructura más verbal.",
        "Similitudes: Ambas retornan `b` si `a` no es mayor, con pureza. Diferencias: Racket incluye el caso falso en el `if`, mientras que OCaml usa `else` explícitamente, requiriendo una línea adicional.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if` con un paréntesis, OCaml cierra la rama `else` con `b`, aumentando el número de líneas en OCaml.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 10 y 7, retornando 10. Diferencias: Racket usa `(max-two 10 7)` con paréntesis, OCaml usa `max_two 10 7`, más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Clasificar número positivo, negativo o cero",
      "racket": {
        "lines": [
          "(define (classify-number x)",
          "  (cond",
          "    [(> x 0) 'positive]",
          "    [(< x 0) 'negative]",
          "    [else 'zero]",
          "  )",
          ")",
          "(classify-number 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let classify_number x =",
          "  if x > 0 then",
          "    \"positive\"",
          "  else if x < 0 then",
          "    \"negative\"",
          "  else",
          "    \"zero\"",
          "in",
          "classify_number 3"
        ]
      },
      "explanations_racket": [
        "Define una función `classify-number` que toma un parámetro `x` para clasificar un número como positivo, negativo o cero. La sintaxis `(define (nombre params) cuerpo)` es funcional, como etiquetar una temperatura según su valor.",
        "Inicia un condicional `cond`, que permite múltiples ramas en Racket. Es una expresión pura que evalúa condiciones secuencialmente, ideal para clasificaciones complejas.",
        "Evalúa si `x > 0`, retornando el símbolo `'positive` si es verdadero, como etiquetar una temperatura positiva.",
        "Evalúa si `x < 0`, retornando `'negative`, para el caso negativo, manteniendo pureza.",
        "Si ninguna condición previa es verdadera, retorna `'zero` con la rama `else`, como clasificar un valor neutro.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `classify-number` con 3, retornando `'positive` porque `3 > 0`, mostrando la clasificación."
      ],
      "explanations_ocaml": [
        "Define una función `classify_number` con un parámetro `x` para clasificar un número, usando `let nombre params = cuerpo`. Es una abstracción funcional, como categorizar un nivel de batería.",
        "Inicia un condicional `if` con `x > 0` en notación infija, evaluando la primera condición con pureza funcional.",
        "Si `x > 0`, retorna la cadena `\"positive\"`, como asignar una etiqueta a un valor positivo.",
        "Introduce un `else if` para evaluar `x < 0`, retornando `\"negative\"`, necesario para manejar múltiples condiciones en OCaml.",
        "Introduce la rama `else`, retornando `\"zero\"` si ninguna condición previa es verdadera, necesaria para completar el condicional.",
        "Cierra la rama `else` con `\"zero\"`, asegurando un valor puro en todos los casos.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `classify_number` con 3, retornando `\"positive\"` porque `3 > 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para clasificar un número como positivo, negativo o cero, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa cadenas, Racket usa símbolos.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza funcional. Diferencias: Racket usa `cond` para múltiples ramas, más flexible, mientras que OCaml usa `if` con anidamiento `else if`, más explícito.",
        "Similitudes: Ambas retornan un valor para el caso positivo. Diferencias: Racket usa el símbolo `'positive`, OCaml usa la cadena `\"positive\"` con `then`.",
        "Similitudes: Ambas manejan el caso negativo. Diferencias: Racket usa una rama de `cond` con `'negative`, más concisa, mientras que OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas manejan el caso cero. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `\"zero\"`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 3, retornando 'positive'. Diferencias: Racket usa `(classify-number 3)` con un símbolo, OCaml usa `classify_number 3` con una cadena."
      ]
    },
    "ejercicio-3": {
      "title": "Año bisiesto",
      "racket": {
        "lines": [
          "(define (leap-year? year)",
          "  (cond",
          "    [(= (remainder year 400) 0) #t]",
          "    [(= (remainder year 100) 0) #f]",
          "    [(= (remainder year 4) 0) #t]",
          "    [else #f]",
          "  )",
          ")",
          "(leap-year? 2024)"
        ]
      },
      "ocaml": {
        "lines": [
          "let leap_year year =",
          "  if year mod 400 = 0 then",
          "    true",
          "  else if year mod 100 = 0 then",
          "    false",
          "  else if year mod 4 = 0 then",
          "    true",
          "  else",
          "    false",
          "in",
          "leap_year 2024"
        ]
      },
      "explanations_racket": [
        "Define una función `leap-year?` que toma un parámetro `year` para verificar si un año es bisiesto. La sintaxis `(define (nombre params) cuerpo)` es funcional, como decidir si un año necesita un día extra en un calendario.",
        "Inicia un condicional `cond` para evaluar las reglas del año bisiesto, una expresión pura que verifica condiciones en orden.",
        "Evalúa si `year` es divisible por 400 usando `(= (remainder year 400) 0)`, retornando `#t` si es verdadero, como 2000.",
        "Evalúa si `year` es divisible por 100, retornando `#f`, como 1900, donde no se añade un día extra.",
        "Evalúa si `year` es divisible por 4, retornando `#t`, como 2024, un año bisiesto típico.",
        "Si ninguna condición es verdadera, retorna `#f` con `else`, para años no bisiestos.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `leap-year?` con 2024, retornando `#t` porque `2024 mod 4 = 0` y no es divisible por 100, mostrando que es bisiesto."
      ],
      "explanations_ocaml": [
        "Define una función `leap_year` con un parámetro `year` para verificar si es bisiesto, usando `let nombre params = cuerpo`. Es una abstracción funcional, como programar un calendario.",
        "Inicia un condicional `if` con `year mod 400 = 0` en notación infija, evaluando la primera regla del año bisiesto con pureza.",
        "Si `year mod 400 = 0`, retorna `true`, para años como 2000.",
        "Introduce un `else if` para `year mod 100 = 0`, retornando `false`, para años como 1900.",
        "Introduce otro `else if` para `year mod 4 = 0`, retornando `true`, para años como 2024.",
        "Introduce la rama `else`, retornando `false` para años no bisiestos, necesaria para completar el condicional.",
        "Cierra la rama `else` con `false`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `leap_year` con 2024, retornando `true` porque `2024 mod 4 = 0` y no es divisible por 100, demostrando que es bisiesto."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si un año es bisiesto, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas inician un condicional para evaluar reglas, con pureza. Diferencias: Racket usa `cond`, más flexible, mientras que OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas verifican divisibilidad por 400, retornando verdadero. Diferencias: Racket usa `(remainder year 400)` en notación prefija, OCaml usa `mod 400` infijo, más matemático.",
        "Similitudes: Ambas verifican divisibilidad por 100, retornando falso. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas verifican divisibilidad por 4, retornando verdadero. Diferencias: Racket usa una rama de `cond`, OCaml usa otro `else if`.",
        "Similitudes: Ambas manejan el caso no bisiesto. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `false`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 2024, retornando verdadero. Diferencias: Racket usa `(leap-year? 2024)`, OCaml usa `leap_year 2024`, más simple."
      ]
    },
    "ejercicio-4": {
      "title": "Signo de un número",
      "racket": {
        "lines": [
          "(define (sign x)",
          "  (cond",
          "    [(> x 0) 1]",
          "    [(< x 0) -1]",
          "    [else 0]",
          "  )",
          ")",
          "(sign -2)"
        ]
      },
      "ocaml": {
        "lines": [
          "let sign x =",
          "  if x > 0 then",
          "    1",
          "  else if x < 0 then",
          "    -1",
          "  else",
          "    0",
          "in",
          "sign (-2)"
        ]
      },
      "explanations_racket": [
        "Define una función `sign` que toma un parámetro `x` para determinar su signo (1, -1, 0). La sintaxis `(define (nombre params) cuerpo)` es funcional, como etiquetar el cambio en una reseña.",
        "Inicia un condicional `cond` para evaluar múltiples casos, una expresión pura que clasifica según condiciones.",
        "Evalúa si `x > 0`, retornando `1`, como indicar un cambio positivo en una puntuación.",
        "Evalúa si `x < 0`, retornando `-1`, para valores negativos, manteniendo pureza.",
        "Si ninguna condición previa es verdadera, retorna `0` con `else`, para el caso neutro.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `sign` con -2, retornando `-1` porque `-2 < 0`, mostrando la función."
      ],
      "explanations_ocaml": [
        "Define una función `sign` con un parámetro `x` para determinar su signo, usando `let nombre params = cuerpo`. Es una abstracción funcional, como clasificar una variación en datos.",
        "Inicia un condicional `if` con `x > 0` en notación infija, evaluando la primera condición con pureza.",
        "Si `x > 0`, retorna `1`, para valores positivos.",
        "Introduce un `else if` para `x < 0`, retornando `-1`, para valores negativos.",
        "Introduce la rama `else`, retornando `0` para el caso neutro, necesaria para completar el condicional.",
        "Cierra la rama `else` con `0`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `sign` con -2, retornando `-1` porque `-2 < 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para determinar el signo de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza. Diferencias: Racket usa `cond`, más flexible, OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas retornan `1` para el caso positivo. Diferencias: Racket usa una rama de `cond`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas retornan `-1` para el caso negativo. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas retornan `0` para el caso neutro. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `0`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con -2, retornando `-1`. Diferencias: Racket usa `(sign -2)`, OCaml usa `sign (-2)` con paréntesis para el negativo."
      ]
    },
    "ejercicio-5": {
      "title": "Sistema de calificación con subniveles (+ y -)",
      "racket": {
        "lines": [
          "(define (grade score)",
          "  (let ((rounded (round score)))",
          "    (cond",
          "      [(>= rounded 90)",
          "       (if (>= rounded 95)",
          "           'A+",
          "           'A-)]",
          "      [(>= rounded 80)",
          "       (if (>= rounded 85)",
          "           'B+",
          "           'B-)]",
          "      [(>= rounded 70)",
          "       (if (>= rounded 75)",
          "           'C+",
          "           'C-)]",
          "      [(>= rounded 60)",
          "       (if (>= rounded 65)",
          "           'D+",
          "           'D-)]",
          "      [else 'F]",
          "    )",
          "  )",
          ")",
          "(grade 92.3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let grade score =",
          "  let rounded = int_of_float (Float.round score) in",
          "  if rounded >= 90 then",
          "    if rounded >= 95 then \"A+\" else \"A-\"",
          "  else if rounded >= 80 then",
          "    if rounded >= 85 then \"B+\" else \"B-\"",
          "  else if rounded >= 70 then",
          "    if rounded >= 75 then \"C+\" else \"C-\"",
          "  else if rounded >= 60 then",
          "    if rounded >= 65 then \"D+\" else \"D-\"",
          "  else",
          "    \"F\"",
          "in",
          "grade 92.3"
        ]
      },
      "explanations_racket": [
        "Define una función `grade` que recibe una nota `score`. Esta función decidirá qué letra corresponde según la calificación numérica.",
        "Dentro de la función, se usa `let` para crear una variable local llamada `rounded` que guarda el valor redondeado de `score` (por ejemplo, 92.3 se convierte en 92).",
        "`cond` inicia un bloque de condiciones que se evalúan una por una. Cada caso representa un rango de calificaciones.",
        "Si la nota es 90 o más (`(>= rounded 90)`), entra en esta condición. Dentro de ella, hay otro `if` que evalúa si la nota es 95 o más.",
        "Si es 95 o más, devuelve `'A+` (nota excelente). Si está entre 90 y 94, devuelve `'A-`, lo que muestra un nivel alto pero no perfecto.",
        "El siguiente bloque evalúa si la nota es al menos 80. Dentro, otro `if` decide entre `'B+` y `'B-`, añadiendo subniveles dentro del rango B.",
        "De igual forma, el siguiente rango (70–79) se evalúa con `if` anidado, devolviendo `'C+` o `'C-`, según esté cerca del 80 o más bajo.",
        "Luego, si la nota está entre 60 y 69, se aplica la misma lógica para `'D+` y `'D-`, diferenciando entre apenas aprobada o más alta.",
        "Si ninguna de las condiciones anteriores se cumple, se ejecuta `else` y devuelve `'F`, que representa una nota reprobatoria.",
        "Finalmente, se llama a `(grade 92.3)`. Como el valor redondeado es 92, devuelve `'A-`."
      ],
      "explanations_ocaml": [
        "Define una función `grade` en OCaml que recibe una nota `score`.",
        "Crea una variable local `rounded` que guarda el número redondeado de `score` (por ejemplo, 92.3 se convierte en 92).",
        "El condicional principal empieza: si `rounded >= 90`, entonces entra al primer bloque.",
        "Dentro de ese bloque, hay un `if` anidado: si la nota es 95 o más, devuelve \"A+\"; si no, devuelve \"A-\".",
        "Si no cumple el rango anterior, pasa al siguiente bloque `else if rounded >= 80`. Allí se repite la estructura con `if` anidado para decidir entre \"B+\" o \"B-\".",
        "Cada bloque siguiente (70 y 60) repite la misma idea: un rango principal con una decisión interna, agregando detalle y precisión al resultado.",
        "Si la nota es menor a 60, entra al `else` final que devuelve \"F\", indicando reprobación.",
        "El `in` introduce la llamada final a la función.",
        "Se llama a `grade 92.3`. El valor 92 no alcanza 95, por lo que devuelve \"A-\"."
      ],
      "comparisons": [
        "Ambas definen funciones para clasificar calificaciones, pero Racket usa `cond` y símbolos (`'A-`), mientras OCaml usa `if` y cadenas (\"A-\").",
        "Ambas crean una variable local: `let` en OCaml y `(let ...)` en Racket, aunque con sintaxis distinta.",
        "Ambas usan estructuras anidadas (`if` dentro de `cond` o `if` dentro de `if`) para refinar los resultados.",
        "OCaml agrupa los `if` con `else if`, mientras Racket los separa con `cond` y paréntesis, lo que hace más clara la jerarquía de decisiones.",
        "Ambas llamadas finales evalúan con 92.3 y devuelven una nota alta pero no perfecta: `'A-` o \"A-\"."
      ]
    },
    "ejercicio-6": {
      "title": "Activar alarma con condiciones anidadas",
      "racket": {
        "lines": [
          "(define (activate-alarm? x)",
          "  (if (and (= (remainder x 2) 0)",
          "           (= (remainder x 3) 0))",
          "      #t",
          "      (if (or (= (remainder (round (sqrt x)) 5) 0)",
          "              (= (remainder (round (sqrt x)) 7) 0))",
          "          #t",
          "          #f)))",
          "(activate-alarm? 12)"
        ]
      },
      "ocaml": {
        "lines": [
          "let activate_alarm x =",
          "  if x mod 2 = 0 && x mod 3 = 0 then",
          "    true",
          "  else if ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 5 = 0)",
          "       || ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 7 = 0) then",
          "    true",
          "  else",
          "    false",
          "in",
          "activate_alarm 12"
        ]
      },
      "explanations_racket": [
        "Define una función `activate-alarm?` que recibe un número `x` y determina si debe activarse una alarma según ciertas reglas matemáticas.",
        "El primer `if` comprueba si el número es divisible por 2 y por 3. Si ambas condiciones son ciertas, retorna `#t` (verdadero).",
        "Si no es divisible por ambos, entra al segundo `if` anidado.",
        "Dentro del segundo `if`, se calcula la raíz cuadrada de `x`, se redondea, y se verifica si ese número es divisible por 5 o por 7.",
        "Si se cumple alguna de esas dos condiciones, retorna `#t`, indicando que la alarma también se activa en esos casos especiales.",
        "Si ninguna de las condiciones anteriores se cumple, retorna `#f` (falso), lo que significa que la alarma no se activa.",
        "Finalmente, al ejecutar `(activate-alarm? 12)`, el resultado es `#t`, porque 12 es divisible tanto por 2 como por 3."
      ],
      "explanations_ocaml": [
        "Define una función `activate_alarm` que recibe un número `x` y devuelve `true` o `false` según ciertas condiciones.",
        "Primero verifica si `x` es divisible por 2 y por 3 usando `mod` y el operador lógico `&&`. Si ambas condiciones son ciertas, devuelve `true`.",
        "Si no se cumple la primera parte, evalúa el `else if` anidado.",
        "En este segundo caso, convierte `x` a número decimal (`float_of_int x`), calcula su raíz cuadrada, la redondea, la vuelve a entero y verifica si ese número es divisible por 5 o por 7.",
        "Si alguna de esas condiciones se cumple (`||`), devuelve `true`.",
        "Si ninguna se cumple, llega al `else` final que devuelve `false`.",
        "Finalmente, `activate_alarm 12` devuelve `true`, porque cumple la primera condición (divisible por 2 y 3)."
      ],
      "comparisons": [
        "Ambas funciones evalúan condiciones numéricas anidadas: primero divisibilidad directa, luego divisibilidad del valor derivado de la raíz cuadrada.",
        "Racket usa `and` y `or` con notación prefija, OCaml usa `&&` y `||` en notación infija, pero la lógica es la misma.",
        "Ambas devuelven valores booleanos: `#t` / `#f` en Racket y `true` / `false` en OCaml.",
        "El flujo condicional es idéntico: una verificación principal seguida de una secundaria más compleja.",
        "Ambas devuelven verdadero con el número 12."
      ]
    },
    "ejercicio-7": {
      "title": "Clasificación geométrica con validación y tamaño",
      "racket": {
        "lines": [
          "(define (triangle-type a b c)",
          "  (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))",
          "      (cond",
          "        [(and (= a b) (= b c))",
          "         (if (< a 5)",
          "             'small-equilateral",
          "             'equilateral)]",
          "        [(or (= a b) (= b c) (= a c))",
          "         (if (< a 5)",
          "             'small-isosceles",
          "             'isosceles)]",
          "        [else",
          "         (if (< a 5)",
          "             'small-scalene",
          "             'scalene)])",
          "      'invalid))",
          "(triangle-type 3 3 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let triangle_type a b c =",
          "  if a + b > c && a + c > b && b + c > a then",
          "    if a = b && b = c then",
          "      if a < 5 then \"small-equilateral\" else \"equilateral\"",
          "    else if a = b || b = c || a = c then",
          "      if a < 5 then \"small-isosceles\" else \"isosceles\"",
          "    else",
          "      if a < 5 then \"small-scalene\" else \"scalene\"",
          "  else",
          "    \"invalid\"",
          "in",
          "triangle_type 3 3 3"
        ]
      },
      "explanations_racket": [
        "Define una función `triangle-type` que recibe tres lados (`a`, `b`, `c`) y determina qué tipo de triángulo forman.",
        "Primero evalúa si los tres lados pueden formar un triángulo. Esto se hace comprobando que la suma de dos lados sea siempre mayor que el tercero.",
        "Si la figura es válida, entra a un `cond` para clasificar su tipo.",
        "Si los tres lados son iguales (`(and (= a b) (= b c))`), entra en el primer bloque.",
        "Dentro de este bloque hay un `if` anidado que evalúa si los lados son menores que 5. Si lo son, devuelve `'small-equilateral`, indicando un triángulo equilátero pequeño; si no, `'equilateral`.",
        "Si no todos los lados son iguales, pasa al siguiente caso que usa `or` para verificar si al menos dos lados son iguales, es decir, si es isósceles.",
        "Dentro de este caso también hay un `if` anidado para determinar si el triángulo isósceles es pequeño (`'small-isosceles`) o normal (`'isosceles`).",
        "El último caso del `cond` corresponde al triángulo escaleno (todos los lados distintos). También anida un `if` para distinguir si es pequeño o normal.",
        "Si los lados no forman un triángulo válido, la función devuelve `'invalid`.",
        "Finalmente, al ejecutar `(triangle-type 3 3 3)`, devuelve `'small-equilateral` porque todos los lados son iguales y menores que 5."
      ],
      "explanations_ocaml": [
        "Define una función `triangle_type` con tres parámetros (`a`, `b`, `c`). Esta función clasifica un triángulo según sus lados.",
        "Primero verifica si los tres lados cumplen la regla del triángulo: la suma de dos debe ser mayor que el tercero.",
        "Si se cumple, entra al bloque principal donde se analizan los tipos.",
        "Si los tres lados son iguales (`a = b && b = c`), entra al primer bloque.",
        "Dentro, hay un `if` anidado que evalúa si `a < 5`. Si lo es, devuelve \"small-equilateral\"; si no, devuelve \"equilateral\".",
        "Si no es equilátero, evalúa el siguiente `else if` que comprueba si al menos dos lados son iguales (isósceles).",
        "Allí también hay un `if` anidado que devuelve \"small-isosceles\" o \"isosceles\" según el tamaño.",
        "Si ninguno de los anteriores se cumple, es escaleno, y otro `if` anidado determina si es pequeño o no.",
        "Si no cumple la regla del triángulo, devuelve \"invalid\".",
        "Al ejecutar `triangle_type 3 3 3`, devuelve \"small-equilateral\" porque todos los lados son iguales y menores que 5."
      ],
      "comparisons": [
        "Ambas funciones comienzan validando si los lados forman un triángulo real antes de clasificarlo.",
        "Ambas usan estructuras anidadas (`if` dentro de `cond` en Racket, `if` dentro de `if` en OCaml) para combinar lógica de forma y tamaño.",
        "Racket usa símbolos (`'small-equilateral`), OCaml usa cadenas (\"small-equilateral\"), pero los significados son equivalentes.",
        "La validación geométrica (a+b>c, etc.) es igual en ambas versiones, solo cambia la sintaxis.",
        "Ambas devuelven la misma clasificación final con los valores dados."
      ]
    }
  },
  "recursion": {
    "ejercicio-1": {
      "title": "Suma de los primeros n números",
      "racket": {
        "lines": [
          "(define (sum-n n)",
          "  (if (<= n 0)",
          "      0",
          "      (+ n (sum-n (- n 1))))",
          ")",
          "(sum-n 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [4, 3, 2, 1]
      },
      "ocaml": {
        "lines": [
          "let rec sum_n n =",
          "  if n <= 0 then",
          "    0",
          "  else",
          "    n + sum_n (n - 1)",
          "in",
          "sum_n 4"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [4, 3, 2, 1]
      },
      "explanations_racket": [
        "Define una función recursiva `sum-n` que suma los números de 1 a `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como sumar las ventas diarias de un comerciante hasta el día n.",
        "Inicia un condicional `if` que verifica si `n <= 0` con notación prefija `(<= n 0)`, una expresión pura para el caso base, como decidir cuándo detener la suma.",
        "Si `n <= 0`, retorna 0, el caso base, indicando que no hay ventas si no hay días.",
        "Si `n > 0`, suma `n` con `sum-n` de `n - 1` usando `(+ n (sum-n (- n 1)))`, una recursión pura, como sumar la venta actual con las anteriores.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `sum-n` con 4, calculando 4 + 3 + 2 + 1 = 10, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_n` para sumar de 1 a `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, ideal para cálculos funcionales, como sumar ingresos diarios.",
        "Inicia un condicional `if` con `n <= 0` en notación infija, una expresión pura para el caso base.",
        "Si `n <= 0`, retorna 0, como no sumar nada si no hay días.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma `n` con `sum_n (n - 1)` usando notación infija `n + sum_n (n - 1)`, una recursión pura, como sumar el día actual con los anteriores.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_n` con 4, calculando 4 + 3 + 2 + 1 = 10, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar de 1 a n, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito para recursión. OCaml infiere que `n` es entero, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 0` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 0)`, OCaml usa infija `n <= 0`, más matemática.",
        "Similitudes: Ambas retornan 0 como caso base, esencial para detener la recursión. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo sumando `n`. Diferencias: Racket usa `(+ n ...)` en una línea, OCaml separa `else` y la recursión, requiriendo más líneas por estructura.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 4, retornando 10. Diferencias: Racket usa `(sum-n 4)` con paréntesis, OCaml usa `sum_n 4`, más conciso en la invocación."
      ]
    },
    "ejercicio-2": {
      "title": "Potencia de un número",
      "racket": {
        "lines": [
          "(define (power base exp)",
          "  (if (= exp 0)",
          "      1",
          "      (* base (power base (- exp 1))))",
          ")",
          "(power 2 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [2, 4, 8, 16]
      },
      "ocaml": {
        "lines": [
          "let rec power base exp =",
          "  if exp = 0 then",
          "    1",
          "  else",
          "    base * power base (exp - 1)",
          "in",
          "power 2 4"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [2, 4, 8, 16]
      },
      "explanations_racket": [
        "Define una función recursiva `power` para calcular `base` elevado a `exp`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el crecimiento de una inversión que se duplica repetidamente.",
        "Inicia un condicional `if` con `(= exp 0)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `exp = 0`, retorna 1, el caso base (base^0 = 1), como una inversión sin crecimiento.",
        "Si `exp ≠ 0`, multiplica `base` por `power` de `exp - 1` usando `(* base (power base (- exp 1)))`, una recursión pura, como calcular 2^4 = 2 * 2^3.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `power` con 2 y 4, calculando 2^4 = 16, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `power` para calcular `base` elevado a `exp`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un crecimiento exponencial.",
        "Inicia un condicional `if` con `exp = 0` en notación infija, verificando el caso base con pureza.",
        "Si `exp = 0`, retorna 1, el caso base, como un cálculo sin multiplicaciones.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica `base` por `power base (exp - 1)` en notación infija, una recursión pura, como calcular 2^4 = 2 * 2^3.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `power` con 2 y 4, calculando 2^4 = 16, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular potencias, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito.",
        "Similitudes: Ambas verifican `exp = 0` con pureza funcional. Diferencias: Racket usa notación prefija `(= exp 0)`, OCaml usa infija `exp = 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo multiplicando `base`. Diferencias: Racket usa `(* base ...)` en notación prefija, OCaml usa `base * ...` infija, más concisa y matemática.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 2 y 4, retornando 16. Diferencias: Racket usa `(power 2 4)` con paréntesis, OCaml usa `power 2 4`, más simple."
      ]
    },
    "ejercicio-3": {
      "title": "Factorial de un número",
      "racket": {
        "lines": [
          "(define (factorial n)",
          "  (if (<= n 1)",
          "      1",
          "      (* n (factorial (- n 1))))",
          ")",
          "(factorial 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [1, 2, 6, 24]
      },
      "ocaml": {
        "lines": [
          "let rec factorial n =",
          "  if n <= 1 then",
          "    1",
          "  else",
          "    n * factorial (n - 1)",
          "in",
          "factorial 4"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 2, 6, 24]
      },
      "explanations_racket": [
        "Define una función recursiva `factorial` que calcula n!. La sintaxis `(define (nombre params) cuerpo)` es funcional, como contar las formas de organizar n cajas en un almacén.",
        "Inicia un condicional `if` con `(<= n 1)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 1`, retorna 1, el caso base (0! = 1, 1! = 1), como definir una sola forma de organizar una caja o ninguna.",
        "Si `n > 1`, multiplica `n` por `factorial` de `n - 1` usando `(* n (factorial (- n 1)))`, una recursión pura, como calcular 4! = 4 * 3!.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `factorial` con 4, calculando 4! = 4 * 3 * 2 * 1 = 24, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `factorial` para calcular n!, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como calcular combinaciones de objetos.",
        "Inicia un condicional `if` con `n <= 1` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 1`, retorna 1, el caso base, como una sola configuración para una caja o ninguna.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica `n` por `factorial (n - 1)` en notación infija, una recursión pura, como calcular 4! = 4 * 3!.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `factorial` con 4, calculando 4! = 24, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular el factorial, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere que `n` es entero, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 1` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 1)`, OCaml usa infija `n <= 1`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo multiplicando `n`. Diferencias: Racket usa `(* n ...)` en notación prefija, OCaml usa `n * ...` infija, requiriendo una línea extra para `else`.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 4, retornando 24. Diferencias: Racket usa `(factorial 4)` con paréntesis, OCaml usa `factorial 4`, más conciso."
      ]
    },
    "ejercicio-4": {
      "title": "Fibonacci en la posición n",
      "racket": {
        "lines": [
          "(define (fibonacci n)",
          "  (if (<= n 1)",
          "      n",
          "      (+ (fibonacci (- n 1))",
          "         (fibonacci (- n 2)))",
          "  )",
          ")",
          "(fibonacci 6)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [0, 1, 1, 2, 3, 5, 8]
      },
      "ocaml": {
        "lines": [
          "let rec fibonacci n =",
          "  if n <= 1 then",
          "    n",
          "  else",
          "    fibonacci (n - 1) +",
          "    fibonacci (n - 2)",
          "in",
          "fibonacci 6"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 5, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 5, 0, 1, 2],
        "recursion-step-answer": [0, 1, 1, 2, 3, 5, 8]
      },
      "explanations_racket": [
        "Define una función recursiva `fibonacci` para calcular el número de Fibonacci en la posición `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como modelar el crecimiento de una población de conejos en un ecosistema.",
        "Inicia un condicional `if` con `(<= n 1)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 1`, retorna `n` (Fib(0) = 0, Fib(1) = 1), el caso base, como definir los primeros pasos de la población.",
        "Si `n > 1`, suma `fibonacci` de `n - 1` y `n - 2` usando notación prefija, iniciando una recursión doble, como sumar generaciones previas de conejos.",
        "Completa la recursión con `(+ (fibonacci (- n 1)) (fibonacci (- n 2)))`, una expresión pura que descompone el problema.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `fibonacci` con 6, calculando Fib(6) = 8, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `fibonacci` para calcular Fib(n), usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un patrón biológico de crecimiento.",
        "Inicia un condicional `if` con `n <= 1` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 1`, retorna `n` (Fib(0) = 0, Fib(1) = 1), como establecer los primeros valores de una secuencia.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma `fibonacci (n - 1)` y `fibonacci (n - 2)` en notación infija, una recursión doble pura, como combinar generaciones previas.",
        "Completa la suma recursiva, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `fibonacci` con 6, calculando Fib(6) = 8, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular Fibonacci, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 1` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 1)`, OCaml usa infija `n <= 1`, más matemática.",
        "Similitudes: Ambas retornan `n` como caso base (0 o 1). Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión doble para `n > 1`. Diferencias: Racket divide la suma en dos líneas por formato prefijo, OCaml usa `else` para iniciar la recursión.",
        "Similitudes: Ambas completan la recursión sumando dos llamadas. Diferencias: Racket cierra la suma en una línea separada, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la suma, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 6, retornando 8. Diferencias: Racket usa `(fibonacci 6)` con paréntesis, OCaml usa `fibonacci 6`, más conciso."
      ]
    },
    "ejercicio-5": {
      "title": "Suma de dígitos",
      "racket": {
        "lines": [
          "(define (sum-digits n)",
          "  (if (< n 10)",
          "      n",
          "      (+ (remainder n 10)",
          "         (sum-digits (quotient n 10)))",
          "  )",
          ")",
          "(sum-digits 12345)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [5, 4, 3, 2, 1]
      },
      "ocaml": {
        "lines": [
          "let rec sum_digits n =",
          "  if n < 10 then",
          "    n",
          "  else",
          "    (n mod 10) +",
          "    sum_digits (n / 10)",
          "in",
          "sum_digits 12345"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2],
        "recursion-step-answer": [5, 4, 3, 2, 1]
      },
      "explanations_racket": [
        "Define una función recursiva `sum-digits` para sumar los dígitos de `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como sumar los números de un código postal para validarlo.",
        "Inicia un condicional `if` con `(< n 10)`, verificando si `n` es un solo dígito, una expresión pura para el caso base.",
        "Si `n < 10`, retorna `n`, el caso base, como tomar un solo dígito de un código.",
        "Si `n >= 10`, suma el último dígito (`remainder n 10`) con la suma de los dígitos de `n` dividido por 10 (`quotient n 10`), iniciando la recursión, como descomponer 12345 en 5 + 4 + 3 + 2 + 1.",
        "Completa la recursión sumando el resultado de `sum-digits (quotient n 10)`, una expresión pura que reduce el número.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `sum-digits` con 12345, calculando 1 + 2 + 3 + 4 + 5 = 15, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_digits` para sumar los dígitos de `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como validar un número sumando sus partes.",
        "Inicia un condicional `if` con `n < 10` en notación infija, verificando el caso base con pureza.",
        "Si `n < 10`, retorna `n`, el caso base, como un solo dígito en un cálculo.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma el último dígito (`n mod 10`) con `sum_digits (n / 10)` en notación infija, iniciando la recursión pura.",
        "Completa la recursión con la suma, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_digits` con 12345, calculando 1 + 2 + 3 + 4 + 5 = 15, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar los dígitos de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n < 10` con pureza funcional. Diferencias: Racket usa notación prefija `(< n 10)`, OCaml usa infija `n < 10`, más matemática.",
        "Similitudes: Ambas retornan `n` como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión sumando el último dígito. Diferencias: Racket usa `remainder` y `quotient` en notación prefija, OCaml usa `mod` y `/` infijos, más concisos.",
        "Similitudes: Ambas completan la recursión sumando el resto del número. Diferencias: Racket divide la suma en dos líneas por formato prefijo, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la suma, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 12345, retornando 15. Diferencias: Racket usa `(sum-digits 12345)` con paréntesis, OCaml usa `sum_digits 12345`, más conciso."
      ]
    },
    "ejercicio-6": {
      "title": "Producto de los primeros n impares",
      "racket": {
        "lines": [
          "(define (product-odds n)",
          "  (if (<= n 0)",
          "      1",
          "      (* (+ (* 2 n) -1)",
          "         (product-odds (- n 1)))",
          "  )",
          ")",
          "(product-odds 3)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 3, 15]
      },
      "ocaml": {
        "lines": [
          "let rec product_odds n =",
          "  if n <= 0 then",
          "    1",
          "  else",
          "    (2 * n - 1) *",
          "    product_odds (n - 1)",
          "in",
          "product_odds 3"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2],
        "recursion-step-answer": [1, 3, 15]
      },
      "explanations_racket": [
        "Define una función recursiva `product-odds` para calcular el producto de los primeros n números impares (1, 3, 5, ...). La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el producto de valores alternados en un experimento matemático.",
        "Inicia un condicional `if` con `(<= n 0)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 0`, retorna 1, el caso base, como el producto vacío (neutro para la multiplicación).",
        "Si `n > 0`, multiplica el n-ésimo impar `(+ (* 2 n) -1)` por `product-odds` de `n - 1`, iniciando la recursión, como calcular 1 * 3 * 5 para n = 3.",
        "Completa la recursión con la multiplicación, una expresión pura que reduce el problema.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `product-odds` con 3, calculando 1 * 3 * 5 = 15, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `product_odds` para calcular el producto de los primeros n impares, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un cálculo matemático.",
        "Inicia un condicional `if` con `n <= 0` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 0`, retorna 1, el caso base, como un producto vacío.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica el n-ésimo impar `(2 * n - 1)` por `product_odds (n - 1)` en notación infija, iniciando la recursión pura.",
        "Completa la multiplicación recursiva, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `product_odds` con 3, calculando 1 * 3 * 5 = 15, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular el producto de impares, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 0` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 0)`, OCaml usa infija `n <= 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión multiplicando el n-ésimo impar. Diferencias: Racket usa `(+ (* 2 n) -1)` en notación prefija, OCaml usa `(2 * n - 1)` infija, más concisa.",
        "Similitudes: Ambas completan la recursión con la multiplicación. Diferencias: Racket divide la expresión en dos líneas por formato prefijo, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la multiplicación, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 3, retornando 15. Diferencias: Racket usa `(product-odds 3)` con paréntesis, OCaml usa `product_odds 3`, más conciso."
      ]
    },
    "ejercicio-7": {
      "title": "Contar dígitos",
      "racket": {
        "lines": [
          "(define (count-digits n)",
          "  (if (< n 10)",
          "      1",
          "      (+ 1 (count-digits (quotient n 10))))",
          ")",
          "(count-digits 1234)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "ocaml": {
        "lines": [
          "let rec count_digits n =",
          "  if n < 10 then",
          "    1",
          "  else",
          "    1 + count_digits (n / 10)",
          "in",
          "count_digits 1234"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "explanations_racket": [
        "Define una función recursiva `count-digits` para contar los dígitos de `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como validar un número de teléfono contando sus cifras.",
        "Inicia un condicional `if` con `(< n 10)`, verificando si `n` es un solo dígito, una expresión pura para el caso base.",
        "Si `n < 10`, retorna 1, el caso base, como contar una sola cifra en un número.",
        "Si `n >= 10`, suma 1 al conteo de dígitos de `n` dividido por 10 (`quotient n 10`), una recursión pura, como contar cada cifra de 1234.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `count-digits` con 1234, calculando 4 dígitos, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `count_digits` para contar los dígitos de `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como validar un código contando sus partes.",
        "Inicia un condicional `if` con `n < 10` en notación infija, verificando el caso base con pureza.",
        "Si `n < 10`, retorna 1, el caso base, como una sola cifra en un número.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma 1 a `count_digits (n / 10)` en notación infija, una recursión pura para contar los dígitos restantes.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `count_digits` con 1234, calculando 4 dígitos, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para contar los dígitos de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n < 10` con pureza funcional. Diferencias: Racket usa notación prefija `(< n 10)`, OCaml usa infija `n < 10`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo sumando 1. Diferencias: Racket usa `quotient` en notación prefija, OCaml usa `/` infija, más concisa y matemática.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 1234, retornando 4. Diferencias: Racket usa `(count-digits 1234)` con paréntesis, OCaml usa `count_digits 1234`, más conciso."
      ]
    }
  },
  "listas": {
    "ejercicio-1": {
      "title": "Contar Elementos en una Lista de Tareas",
      "racket": {
        "lines": [
          "(define (length lst)",
          "  (if (empty? lst)",
          "      0",
          "      (+ 1 (length (rest lst))))",
          "  )",
          ")",
          "(length '(1 2 3 4))"
        ],
        "recursion": [6, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "ocaml": {
        "lines": [
          "let rec length lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    1 + length (List.tl lst)",
          "in",
          "length [1; 2; 3; 4]"
        ],
        "recursion": [6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2],
        "recursion-step-answer": [1, 2, 3, 4]
      },
      "explanations_racket": [
        "Define una función `length` que toma una lista `lst`, como las tareas de una organizadora (1 2 3 4). En Racket, `(define (nombre params) cuerpo)` es como escribir una receta para contar cuántas tareas hay.",
        "Inicia un condicional `if` que verifica si la lista está vacía con `(empty? lst)`. Es como preguntar si la organizadora tiene tareas pendientes.",
        "Si la lista está vacía, retorna 0, indicando que no hay tareas. Es el caso base para detener la cuenta.",
        "Si la lista no está vacía, suma 1 al conteo de la lista sin su primer elemento con `(length (rest lst))`. Es como contar una tarea y pasar a las restantes.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket, como cerrar un paso en la receta.",
        "Cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Llama a `length` con la lista `(1 2 3 4)`, contando 4 elementos, como confirmar cuántas tareas tiene la organizadora."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `length` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` indica recursión, como una receta para contar tareas de una organizadora.",
        "Inicia un condicional `if` con `lst = []` para verificar si la lista está vacía. Es como preguntar si no hay tareas.",
        "Si la lista está vacía, retorna 0, el caso base, indicando cero tareas.",
        "Introduce la rama `else`, necesaria en OCaml para el caso no vacío, preparando el conteo.",
        "Suma 1 al conteo de la lista sin su primer elemento con `length (List.tl lst)`, como contar una tarea y continuar con las demás.",
        "Usa `in` para conectar la definición con la llamada, una regla estructural de OCaml.",
        "Llama a `length` con `[1; 2; 3; 4]`, contando 4 elementos, como confirmar el total de tareas."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para contar elementos en una lista, con recursión pura y resultado 4. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo` con `rec` explícito. OCaml usa `;` para listas, Racket usa espacios.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)` con notación prefija, OCaml usa `lst = []` con notación infija, más intuitiva.",
        "Similitudes: Ambas retornan 0 como caso base. Diferencias: Racket lo hace directamente en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas suman 1 al conteo recursivo. Diferencias: Racket usa `(+ 1 (length (rest lst)))` con paréntesis, OCaml usa `1 + length (List.tl lst)` con notación infija y `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `if` con `)`, OCaml usa `in` para la evaluación.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando 4. Diferencias: Racket usa `(length '(1 2 3 4))` con comillas, OCaml usa `length [1; 2; 3; 4]` con corchetes y `;`."
      ]
    },
    "ejercicio-2": {
      "title": "Obtener los Dos Primeros Elementos de una Lista de Tareas",
      "racket": {
        "lines": [
          "(define (first-two-elements lst)",
          "  (let ((len (length lst)))",
          "    (if (< len 1)",
          "        null",
          "        (let ((first-el (first lst))",
          "              (rest-lst (rest lst)))",
          "          (if (empty? rest-lst)",
          "              (list first-el)",
          "              (list first-el (first rest-lst)))))",
          "  )",
          ")",
          "(first-two-elements '(5 6 7 8 9))"
        ],
        "recursion-step-answer": [5, 6]
      },
      "ocaml": {
        "lines": [
          "let rec first_two_elements lst =",
          "  let len = List.length lst in",
          "  if len < 1 then",
          "    []",
          "  else",
          "    let first_el = List.hd lst in",
          "    let rest_lst = List.tl lst in",
          "    if rest_lst = [] then",
          "      [first_el]",
          "    else",
          "      [first_el; List.hd rest_lst]",
          "in",
          "first_two_elements [5; 6; 7; 8; 9]"
        ],
        "recursion-step-answer": [5, 6]
      },
      "explanations_racket": [
        "Define una función `first-two-elements` que toma una lista `lst`, como tareas de un gerente (5 6 7 8 9). En Racket, `(define (nombre params) cuerpo)` es como una receta para priorizar las dos primeras tareas.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar cuántas tareas hay antes de priorizar.",
        "Inicia un condicional `if` para verificar si la lista tiene menos de 1 elemento con `(< len 1)`, como asegurarse de que hay tareas.",
        "Si la lista está vacía, retorna `null`, indicando que no hay tareas para priorizar.",
        "Define `first-el` como `(first lst)`, tomando la primera tarea, como anotar la tarea inicial.",
        "Define `rest-lst` como `(rest lst)`, obteniendo la lista sin el primer elemento, como pasar a las tareas restantes.",
        "Verifica si `rest-lst` está vacía con `(empty? rest-lst)`, como preguntar si hay más tareas.",
        "Si `rest-lst` está vacía, retorna una lista con solo `first-el`, como priorizar solo la primera tarea si no hay más.",
        "Si `rest-lst` no está vacía, retorna una lista con `first-el` y el primer elemento de `rest-lst`, como priorizar las dos primeras tareas.",
        "Cierra el bloque `let` y el `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función con un paréntesis, como el punto final de la receta.",
        "Llama a `first-two-elements` con `(5 6 7 8 9)`, retornando `(5 6)`, como seleccionar las dos primeras tareas."
      ],
      "explanations_ocaml": [
        "Define una función `first_two_elements` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` permite recursión, aunque aquí no se usa, como una receta para priorizar tareas.",
        "Usa `let` para calcular la longitud con `List.length lst`, como contar las tareas del gerente.",
        "Inicia un condicional `if` con `len < 1` para verificar si la lista está vacía, como confirmar si hay tareas.",
        "Si la lista está vacía, retorna `[]`, indicando que no hay tareas.",
        "Introduce la rama `else`, necesaria en OCaml para el caso no vacío.",
        "Define `first_el` como `List.hd lst`, tomando la primera tarea.",
        "Define `rest_lst` como `List.tl lst`, obteniendo las tareas restantes.",
        "Verifica si `rest_lst` está vacía con `rest_lst = []`, como preguntar si hay más tareas.",
        "Si `rest_lst` está vacía, retorna `[first_el]`, como priorizar solo la primera tarea.",
        "Introduce `else` para el caso donde hay más tareas.",
        "Retorna una lista con `first_el` y el primer elemento de `rest_lst`, como priorizar las dos primeras tareas.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `first_two_elements` con `[5; 6; 7; 8; 9]`, retornando `[5; 6]`."
      ],
      "comparisons": [
        "Similitudes: Ambas extraen los dos primeros elementos de una lista, con el mismo propósito y resultado `(5 6)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, aunque aquí no hay recursión. OCaml usa `;` para listas, Racket usa espacios.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(< len 1)`, OCaml usa `len < 1`.",
        "Similitudes: Ambas retornan una lista vacía si no hay elementos. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket incluye esta lógica en el `let`, OCaml usa `else` explícitamente.",
        "Similitudes: Ambas extraen el primer elemento. Diferencias: Racket usa `(first lst)`, OCaml usa `List.hd lst`.",
        "Similitudes: Ambas obtienen el resto de la lista. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas verifican si el resto está vacío. Diferencias: Racket usa `(empty? rest-lst)`, OCaml usa `rest_lst = []`.",
        "Similitudes: Ambas retornan una lista con el primer elemento si el resto está vacío. Diferencias: Racket usa `(list first-el)`, OCaml usa `[first_el]`.",
        "Similitudes: Ambas manejan el caso con más elementos. Diferencias: Racket usa `(list first-el (first rest-lst))`, OCaml usa `[first_el; List.hd rest_lst]` con `;`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 5 elementos, dando `(5 6)`. Diferencias: Racket usa `(first-two-elements '(5 6 7 8 9))`, OCaml usa `first_two_elements [5; 6; 7; 8; 9]`."
      ]
    },
    "ejercicio-3": {
      "title": "Obtener el Último Elemento de una Cola",
      "racket": {
        "lines": [
          "(define (last-element lst)",
          "  (let ((len (length lst)))",
          "    (if (< len 1)",
          "        null",
          "        (let ((rest-lst (rest lst))",
          "              (len-rest (length rest-lst)))",
          "          (if (= len-rest 0)",
          "              (first lst)",
          "              (last-element rest-lst)))))",
          "  )",
          ")",
          "(last-element '(1 2 3 4 5))"
        ],
        "recursion": [11, 0, 1, 2, 4, 5, 6, 8, 0, 1, 2, 4, 5, 6, 8, 0, 1, 2, 4, 5, 6, 8, 0, 1, 2, 4, 5, 6, 7],
        "recursion-step-answer": [1, 2, 3, 4, 5]
      },
      "ocaml": {
        "lines": [
          "let rec last_element lst =",
          "  let len = List.length lst in",
          "  if len < 1 then",
          "    None",
          "  else",
          "    let rest_lst = List.tl lst in",
          "    let len_rest = List.length rest_lst in",
          "    if len_rest = 0 then",
          "      Some (List.hd lst)",
          "    else",
          "      last_element rest_lst",
          "in",
          "last_element [1; 2; 3; 4; 5]"
        ],
        "recursion": [12, 0, 1, 2, 4, 5, 6, 7, 10, 0, 1, 2, 4, 5, 6, 7, 10, 0, 1, 2, 4, 5, 6, 7, 10, 0, 1, 2, 4, 5, 6, 7, 8],
        "recursion-step-answer": [1, 2, 3, 4, 5]
      },
      "explanations_racket": [
        "Define una función `last-element` que toma una lista `lst`, como clientes en una cola (1 2 3 4 5). En Racket, `(define (nombre params) cuerpo)` es como una receta para encontrar al último cliente.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar cuántos clientes hay.",
        "Verifica si la lista está vacía con `(< len 1)`, como preguntar si no hay clientes.",
        "Si la lista está vacía, retorna `null`, indicando que no hay último cliente.",
        "Define `rest-lst` como `(rest lst)`, obteniendo la lista sin el primer cliente.",
        "Define `len-rest` como `(length rest-lst)`, contando los clientes restantes.",
        "Verifica si `rest-lst` tiene longitud 0 con `(= len-rest 0)`, como preguntar si solo queda un cliente.",
        "Si `rest-lst` está vacía, retorna `(first lst)`, el último cliente.",
        "Si `rest-lst` no está vacía, llama recursivamente a `last-element` con `rest-lst`, como avanzar en la cola.",
        "Cierra el bloque `let` y el `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `last-element` con `(1 2 3 4 5)`, retornando `5`, el último cliente."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `last_element` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para encontrar al último cliente.",
        "Usa `let` para calcular la longitud con `List.length lst`, como contar clientes.",
        "Verifica si la lista está vacía con `len < 1`, como preguntar si no hay clientes.",
        "Si la lista está vacía, retorna `None`, indicando que no hay último cliente.",
        "Introduce la rama `else`, necesaria en OCaml para el caso no vacío.",
        "Define `rest_lst` como `List.tl lst`, obteniendo los clientes restantes.",
        "Define `len_rest` como `List.length rest_lst`, contando los clientes restantes.",
        "Verifica si `rest_lst` tiene longitud 0 con `len_rest = 0`.",
        "Si `rest_lst` está vacía, retorna `Some (List.hd lst)`, el último cliente.",
        "Introduce `else` para el caso recursivo.",
        "Llama recursivamente a `last_element` con `rest_lst`, como avanzar en la cola.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `last_element` con `[1; 2; 3; 4; 5]`, retornando `Some 5`."
      ],
      "comparisons": [
        "Similitudes: Ambas encuentran el último elemento de una lista con recursión, dando `5`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`. OCaml retorna `Some 5`, Racket retorna `5` directamente.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(< len 1)`, OCaml usa `len < 1`.",
        "Similitudes: Ambas retornan un valor nulo si la lista está vacía. Diferencias: Racket usa `null`, OCaml usa `None`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket lo hace en el `let`, OCaml usa `else`.",
        "Similitudes: Ambas obtienen el resto de la lista. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas calculan la longitud del resto. Diferencias: Racket usa `(length rest-lst)`, OCaml usa `List.length rest_lst`.",
        "Similitudes: Ambas verifican si el resto está vacío. Diferencias: Racket usa `(= len-rest 0)`, OCaml usa `len_rest = 0`.",
        "Similitudes: Ambas retornan el primer elemento si el resto está vacío. Diferencias: Racket usa `(first lst)`, OCaml usa `Some (List.hd lst)`.",
        "Similitudes: Ambas manejan el caso recursivo. Diferencias: Racket usa `(last-element rest-lst)`, OCaml usa `last_element rest_lst` con `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la función con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 5 elementos, dando `5`. Diferencias: Racket usa `(last-element '(1 2 3 4 5))`, OCaml usa `last_element [1; 2; 3; 4; 5]`."
      ]
    },
    "ejercicio-4": {
      "title": "Concatenar Tres Listas de un Mercado",
      "racket": {
        "lines": [
          "(define (append-three lst1 lst2 lst3)",
          "  (let ((len1 (length lst1))",
          "        (append12 (if (empty? lst1)",
          "                      lst2",
          "                      (cons (first lst1)",
          "                            (append-three (rest lst1) lst2 lst3)))))",
          "    (if (empty? append12)",
          "        lst3",
          "        (let ((first-12 (first append12))",
          "              (rest-12 (rest append12)))",
          "          (cons first-12 (append-three rest-12 lst3 '())))))",
          "  )",
          ")",
          "(append-three '(1 2) '(3 4) '(5 6))"
        ],
        "recursion": [13, 0, 1, 2, 4, 5, 0, 2, 4, 5, 0, 2, 3, 6, 8, 10, 6, 8, 10, 6, 7],
        "recursion-step-answer": [1, 2, 3, 4, 5, 6]
      },
      "ocaml": {
        "lines": [
          "let rec append_three lst1 lst2 lst3 =",
          "  let len1 = List.length lst1 in",
          "  let append12 = if lst1 = [] then",
          "                   lst2",
          "                 else",
          "                   List.hd lst1 :: append_three (List.tl lst1) lst2 lst3 in",
          "  if append12 = [] then",
          "    lst3",
          "  else",
          "    let first_12 = List.hd append12 in",
          "    let rest_12 = List.tl append12 in",
          "    first_12 :: append_three rest_12 lst3 []",
          "in",
          "append_three [1; 2] [3; 4] [5; 6]"
        ],
        "recursion": [13, 0, 1, 2, 4, 5, 0, 2, 4, 5, 0, 2, 3, 6, 8, 9, 10, 11, 6, 8, 9, 10, 11, 6, 7],
        "recursion-step-answer": [1, 2, 3, 4, 5, 6]
      },
      "explanations_racket": [
        "Define una función `append-three` que toma tres listas `lst1`, `lst2`, `lst3`, como frutas (1 2), verduras (3 4), y lácteos (5 6). Es como una receta para combinar productos en una lista.",
        "Usa `let` para calcular la longitud de `lst1` con `(length lst1)`, como contar los productos de frutas.",
        "Define `append12` con un `if` que verifica si `lst1` está vacía con `(empty? lst1)`.",
        "Si `lst1` está vacía, usa `lst2`, como pasar a las verduras si no hay frutas.",
        "Si `lst1` no está vacía, usa `cons` para añadir el primer elemento de `lst1` y llama recursivamente a `append-three` con el resto de `lst1`, como combinar una fruta con el resto.",
        "Cierra el `if` de `append12`, necesario para la sintaxis.",
        "Verifica si `append12` está vacía con `(empty? append12)`, como preguntar si frutas y verduras se agotaron.",
        "Si `append12` está vacía, retorna `lst3`, como usar solo los lácteos.",
        "Define `first-12` como `(first append12)`, tomando el primer elemento combinado.",
        "Define `rest-12` como `(rest append12)`, obteniendo el resto combinado.",
        "Usa `cons` para añadir `first-12` y llama recursivamente a `append-three` con `rest-12` y una lista vacía, como seguir combinando productos.",
        "Cierra el bloque `let` y el `if`, necesario para Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `append-three` con `(1 2)`, `(3 4)`, `(5 6)`, dando `(1 2 3 4 5 6)`."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `append_three` que toma tres listas. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para combinar productos.",
        "Usa `let` para calcular la longitud de `lst1` con `List.length lst1`.",
        "Define `append12` con un `if` que verifica si `lst1` está vacía con `lst1 = []`.",
        "Si `lst1` está vacía, usa `lst2`, como pasar a las verduras.",
        "Introduce `else` para el caso no vacío.",
        "Añade el primer elemento de `lst1` con `::` y llama recursivamente a `append_three` con el resto de `lst1`.",
        "Verifica si `append12` está vacía con `append12 = []`.",
        "Si `append12` está vacía, retorna `lst3`.",
        "Introduce `else` para el caso no vacío.",
        "Define `first_12` como `List.hd append12`, tomando el primer elemento combinado.",
        "Define `rest_12` como `List.tl append12`, obteniendo el resto.",
        "Añade `first_12` con `::` y llama recursivamente a `append_three` con `rest_12` y una lista vacía.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `append_three` con `[1; 2]`, `[3; 4]`, `[5; 6]`, dando `[1; 2; 3; 4; 5; 6]`."
      ],
      "comparisons": [
        "Similitudes: Ambas concatenan tres listas, dando `(1 2 3 4 5 6)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas calculan la longitud de `lst1`. Diferencias: Racket usa `(length lst1)`, OCaml usa `List.length lst1`.",
        "Similitudes: Ambas verifican si `lst1` está vacía. Diferencias: Racket usa `(empty? lst1)`, OCaml usa `lst1 = []`.",
        "Similitudes: Ambas usan `lst2` si `lst1` está vacía. Diferencias: Racket usa `lst2` directamente, OCaml usa `lst2` en el `if`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket usa `(cons ...)` en el `if`, OCaml usa `::` con `else`.",
        "Similitudes: Ambas combinan el primer elemento de `lst1` recursivamente. Diferencias: Racket usa `(cons (first lst1) ...`, OCaml usa `List.hd lst1 :: ...`.",
        "Similitudes: Ambas verifican si `append12` está vacía. Diferencias: Racket usa `(empty? append12)`, OCaml usa `append12 = []`.",
        "Similitudes: Ambas retornan `lst3` si `append12` está vacía. Diferencias: Racket usa `lst3` directamente, OCaml usa `lst3` en el `if`.",
        "Similitudes: Ambas manejan el caso no vacío de `append12`. Diferencias: Racket usa `let`, OCaml usa `else`.",
        "Similitudes: Ambas extraen el primer elemento de `append12`. Diferencias: Racket usa `(first append12)`, OCaml usa `List.hd append12`.",
        "Similitudes: Ambas obtienen el resto de `append12`. Diferencias: Racket usa `(rest append12)`, OCaml usa `List.tl append12`.",
        "Similitudes: Ambas combinan el primer elemento recursivamente. Diferencias: Racket usa `(cons first-12 ...)`, OCaml usa `first_12 :: ...`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con tres listas, dando `(1 2 3 4 5 6)`. Diferencias: Racket usa `(append-three '(1 2) '(3 4) '(5 6))`, OCaml usa `append_three [1; 2] [3; 4] [5; 6]`."
      ]
    },
    "ejercicio-5": {
      "title": "Obtener Elementos Intermedios de una Lista de Tareas",
      "racket": {
        "lines": [
          "(define (middle-elements lst)",
          "  (let ((len (length lst))",
          "        (rest-lst (if (empty? lst) null (rest lst))))",
          "    (if (< len 2)",
          "        null",
          "        (let ((len-rest (length rest-lst))",
          "              (middle-rest (if (empty? rest-lst) null (rest rest-lst))))",
          "          (if (<= len-rest 1)",
          "              null",
          "              (cons (first rest-lst) (middle-elements rest-lst)))))",
          "  )",
          ")",
          "(middle-elements '(1 2 3 4 5 6))"
        ],
        "recursion": [12, 0, 1, 3, 5, 6, 7, 9, 0, 1, 3, 5, 6, 7, 9, 0, 1, 3, 5, 6, 7, 9, 0, 1, 3, 5, 6, 7, 8],
        "recursion-step-answer": [2, 3, 4, 5]
      },
      "ocaml": {
        "lines": [
          "let rec middle_elements lst =",
          "  let len = List.length lst in",
          "  let rest_lst = if lst = [] then [] else List.tl lst in",
          "  if len < 2 then",
          "    []",
          "  else",
          "    let len_rest = List.length rest_lst in",
          "    let middle_rest = if rest_lst = [] then [] else List.tl rest_lst in",
          "    if len_rest <= 1 then",
          "      []",
          "    else",
          "      List.hd rest_lst :: middle_elements rest_lst",
          "in",
          "middle_elements [1; 2; 3; 4; 5; 6]"
        ],
        "recursion": [13, 0, 1, 2, 3, 5, 6, 7, 8, 11, 0, 1, 2, 3, 5, 6, 7, 8, 11, 0, 1, 2, 3, 5, 6, 7, 8, 11, 0, 1, 2, 3, 5, 6, 7, 8, 9],
        "recursion-step-answer": [2, 3, 4, 5]
      },
      "explanations_racket": [
        "Define una función `middle-elements` que toma una lista `lst`, como tareas de un estudiante (1 2 3 4 5 6). Es como una receta para obtener tareas intermedias, sin la primera ni la última.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar todas las tareas.",
        "Define `rest-lst` con un `if` que retorna `null` si la lista está vacía o `(rest lst)` si no, como obtener las tareas sin la primera.",
        "Verifica si la lista tiene menos de 2 elementos con `(< len 2)`, como asegurar que hay suficientes tareas.",
        "Si la lista tiene menos de 2 elementos, retorna `null`, indicando que no hay tareas intermedias.",
        "Define `len-rest` como `(length rest-lst)`, contando las tareas restantes.",
        "Define `middle-rest` como el resto de `rest-lst`, como eliminar la primera tarea restante.",
        "Verifica si `rest-lst` tiene 1 o menos elementos con `(<= len-rest 1)`.",
        "Si `rest-lst` tiene 1 o menos elementos, retorna `null`, indicando que no hay intermedios.",
        "Si hay más elementos, usa `cons` para añadir el primer elemento de `rest-lst` y llama recursivamente a `middle-elements`, como construir la lista intermedia.",
        "Cierra el bloque `let` y el `if`, necesario para Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `middle-elements` con `(1 2 3 4 5 6)`, dando `(2 3 4 5)`."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `middle_elements` que toma una lista `lst`. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para tareas intermedias.",
        "Usa `let` para calcular la longitud con `List.length lst`.",
        "Define `rest_lst` con un `if` que retorna `[]` si la lista está vacía o `List.tl lst` si no.",
        "Verifica si la lista tiene menos de 2 elementos con `len < 2`.",
        "Si la lista tiene menos de 2 elementos, retorna `[]`.",
        "Introduce `else` para el caso con más elementos.",
        "Define `len_rest` como `List.length rest_lst`, contando las tareas restantes.",
        "Define `middle_rest` como el resto de `rest_lst` con `List.tl rest_lst`.",
        "Verifica si `rest_lst` tiene 1 o menos elementos con `len_rest <= 1`.",
        "Si `rest_lst` tiene 1 o menos elementos, retorna `[]`.",
        "Introduce `else` para el caso recursivo.",
        "Añade el primer elemento de `rest_lst` con `::` y llama recursivamente a `middle_elements`.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `middle_elements` con `[1; 2; 3; 4; 5; 6]`, dando `[2; 3; 4; 5]`."
      ],
      "comparisons": [
        "Similitudes: Ambas obtienen los elementos intermedios de una lista, dando `(2 3 4 5)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas obtienen el resto de la lista. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas verifican si la lista tiene menos de 2 elementos. Diferencias: Racket usa `(< len 2)`, OCaml usa `len < 2`.",
        "Similitudes: Ambas retornan una lista vacía si no hay suficientes elementos. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso con más elementos. Diferencias: Racket usa `let`, OCaml usa `else`.",
        "Similitudes: Ambas calculan la longitud del resto. Diferencias: Racket usa `(length rest-lst)`, OCaml usa `List.length rest_lst`.",
        "Similitudes: Ambas obtienen el resto del resto. Diferencias: Racket usa `(rest rest-lst)`, OCaml usa `List.tl rest_lst`.",
        "Similitudes: Ambas verifican si el resto tiene 1 o menos elementos. Diferencias: Racket usa `(<= len-rest 1)`, OCaml usa `len_rest <= 1`.",
        "Similitudes: Ambas retornan una lista vacía si no hay intermedios. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso recursivo. Diferencias: Racket usa `(cons ...)`, OCaml usa `::` con `else`.",
        "Similitudes: Ambas combinan el primer elemento del resto recursivamente. Diferencias: Racket usa `(cons (first rest-lst) ...)`, OCaml usa `List.hd rest_lst :: ...`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 6 elementos, dando `(2 3 4 5)`. Diferencias: Racket usa `(middle-elements '(1 2 3 4 5 6))`, OCaml usa `middle_elements [1; 2; 3; 4; 5; 6]`."
      ]
    },
    "ejercicio-6": {
      "title": "Verificar si Todas las Sublistas Están Vacías",
      "racket": {
        "lines": [
          "(define (all-empty? lst)",
          "  (let ((len (length lst))",
          "        (first-sublist (if (empty? lst) null (first lst)))",
          "        (rest-sublists (if (empty? lst) null (rest lst))))",
          "    (if (= len 0)",
          "        true",
          "        (let ((len-first (length first-sublist))",
          "              (rest-empty (all-empty? rest-sublists)))",
          "          (and (= len-first 0) rest-empty))))",
          "  )",
          ")",
          "(all-empty? '((1 2) () (3 4) ()))"
        ],
        "recursion": [11, 0, 1, 2, 3, 4, 6, 7, 8, 0, 1, 2, 3, 4, 6, 7, 8, 0, 1, 2, 3, 4, 6, 7, 8, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [false, true, false, true]
      },
      "ocaml": {
        "lines": [
          "let rec all_empty lst =",
          "  let len = List.length lst in",
          "  let first_sublist = if lst = [] then [] else List.hd lst in",
          "  let rest_sublists = if lst = [] then [] else List.tl lst in",
          "  if len = 0 then",
          "    true",
          "  else",
          "    let len_first = List.length first_sublist in",
          "    let rest_empty = all_empty rest_sublists in",
          "    len_first = 0 && rest_empty",
          "in",
          "all_empty [[1; 2]; []; [3; 4]; []]"
        ],
        "recursion": [11, 0, 1, 2, 3, 4, 6, 7, 8, 9, 0, 1, 2, 3, 4, 6, 7, 8, 9, 0, 1, 2, 3, 4, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [false, true, false, true]
      },
      "explanations_racket": [
        "Define una función `all-empty?` que toma una lista de listas `lst`, como sublistas de tareas ((1 2) () (3 4) ()). Es como una receta para verificar si todas las sublistas están vacías.",
        "Usa `let` para calcular la longitud de la lista con `(length lst)`, como contar cuántas sublistas hay.",
        "Define `first-sublist` con un `if` que retorna `null` si la lista está vacía o `(first lst)` si no, como tomar la primera sublista de tareas.",
        "Define `rest-sublists` como `(rest lst)` si no está vacía, como obtener las sublistas restantes.",
        "Verifica si la lista tiene longitud 0 con `(= len 0)`, como preguntar si no hay sublistas.",
        "Si la lista está vacía, retorna `true`, indicando que todas las sublistas están vacías por definición.",
        "Define `len-first` como `(length first-sublist)`, contando los elementos de la primera sublista.",
        "Define `rest-empty` como `(all-empty? rest-sublists)`, verificando recursivamente las sublistas restantes.",
        "Combina con `and` para verificar si `len-first` es 0 y `rest-empty` es `true`, como confirmar que todas las sublistas están vacías.",
        "Cierra el bloque `let` y el `if`, necesario para Racket.",
        "Cierra la definición de la función con un paréntesis.",
        "Llama a `all-empty?` con `((1 2) () (3 4) ())`, dando `false` porque no todas las sublistas están vacías."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `all_empty` que toma una lista de listas. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para verificar sublistas vacías.",
        "Usa `let` para calcular la longitud con `List.length lst`.",
        "Define `first_sublist` con un `if` que retorna `[]` si la lista está vacía o `List.hd lst` si no.",
        "Define `rest_sublists` como `List.tl lst` si no está vacía.",
        "Verifica si la lista tiene longitud 0 con `len = 0`.",
        "Si la lista está vacía, retorna `true`.",
        "Introduce `else` para el caso con sublistas.",
        "Define `len_first` como `List.length first_sublist`, contando los elementos de la primera sublista.",
        "Define `rest_empty` como `all_empty rest_sublists`, verificando recursivamente.",
        "Combina con `&&` para verificar si `len_first` es 0 y `rest_empty` es `true`.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `all_empty` con `[[1; 2]; []; [3; 4]; []]`, dando `false`."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican si todas las sublistas están vacías, dando `false`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas calculan la longitud de la lista. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst`.",
        "Similitudes: Ambas obtienen la primera sublista. Diferencias: Racket usa `(first lst)`, OCaml usa `List.hd lst`.",
        "Similitudes: Ambas obtienen las sublistas restantes. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(= len 0)`, OCaml usa `len = 0`.",
        "Similitudes: Ambas retornan `true` si la lista está vacía. Diferencias: Racket usa `true`, OCaml usa `true` en el `if`.",
        "Similitudes: Ambas manejan el caso con sublistas. Diferencias: Racket usa `let`, OCaml usa `else`.",
        "Similitudes: Ambas calculan la longitud de la primera sublista. Diferencias: Racket usa `(length first-sublist)`, OCaml usa `List.length first_sublist`.",
        "Similitudes: Ambas verifican recursivamente las sublistas restantes. Diferencias: Racket usa `(all-empty? rest-sublists)`, OCaml usa `all_empty rest_sublists`.",
        "Similitudes: Ambas combinan las condiciones con un operador lógico. Diferencias: Racket usa `(and ...)`, OCaml usa `&&`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `let` con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de listas, dando `false`. Diferencias: Racket usa `(all-empty? '((1 2) () (3 4) ()))`, OCaml usa `all_empty [[1; 2]; []; [3; 4]; []]`."
      ]
    },
    "ejercicio-7": {
      "title": "Añadir un Elemento Transformado a una Lista",
      "racket": {
        "lines": [
          "(define (cons-transformed-aux x lst acc)",
          "  (let ((transformed (* x 2))",
          "        (len (length lst))",
          "        (new-lst (cons transformed lst)))",
          "    (if (empty? new-lst)",
          "        acc",
          "        (let ((first-el (first new-lst))",
          "              (rest-el (rest new-lst))",
          "              (len-rest (length rest-el)))",
          "          (cons-transformed-aux 0 rest-el (cons first-el acc))))",
          ")",
          "(define (cons-transformed x lst)",
          "  (cons-transformed-aux x lst null)",
          ")",
          "(cons-transformed 0 '(1 2 3 4))"
        ],
        "recursion": [14, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [0, 1, 2, 3, 4]
      },
      "ocaml": {
        "lines": [
          "let rec cons_transformed_aux x lst acc =",
          "  let transformed = x * 2 in",
          "  let len = List.length lst in",
          "  let new_lst = transformed :: lst in",
          "  if new_lst = [] then",
          "    List.rev acc",
          "  else",
          "    let first_el = List.hd new_lst in",
          "    let rest_el = List.tl new_lst in",
          "    let len_rest = List.length rest_el in",
          "    cons_transformed_aux 0 rest_el (first_el :: acc)",
          "let cons_transformed x lst =",
          "  cons_transformed_aux x lst []",
          "in",
          "cons_transformed 0 [1; 2; 3; 4]"
        ],
        "recursion": [14, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5],
        "recursion-step-answer": [0, 1, 2, 3, 4]
      },
      "explanations_racket": [
        "Define una función auxiliar `cons-transformed-aux` que toma un elemento `x`, una lista `lst`, y un acumulador `acc`. Es como una receta para que un programador transforme un elemento (0*2=0) y lo añada a una lista como (1 2 3 4).",
        "Inicia un bloque `let` para definir variables intermedias, como anotar pasos en una libreta para organizar el cálculo.",
        "Define `transformed` como `(* x 2)`, duplicando el elemento, como calcular el nuevo valor a añadir.",
        "Define `len` como `(length lst)`, contando los elementos de la lista original para verificar su tamaño.",
        "Define `new-lst` como `(cons transformed lst)`, añadiendo el elemento transformado al inicio de la lista, como preparar una lista temporal.",
        "Inicia un condicional `if` para verificar si `new-lst` está vacía con `(empty? new-lst)`, como preguntar si la lista temporal está completa.",
        "Si `new-lst` está vacía, retorna `acc`, la lista acumulada con los elementos procesados, como entregar el resultado final.",
        "Inicia otro bloque `let` para definir más variables intermedias, como continuar anotando pasos detallados.",
        "Define `first-el` como `(first new-lst)`, tomando el primer elemento de la lista temporal, como seleccionar el siguiente elemento a procesar.",
        "Define `rest-el` como `(rest new-lst)`, obteniendo el resto de la lista temporal, como avanzar a los elementos restantes.",
        "Define `len-rest` como `(length rest-el)`, contando los elementos restantes para verificar si hay más que procesar.",
        "Llama recursivamente a `cons-transformed-aux` con 0, `rest-el`, y un acumulador que incluye `first-el` usando `(cons first-el acc)`, como continuar construyendo la lista.",
        "Cierra el bloque `let` y el `if`, necesario para la sintaxis de Racket, como cerrar un paso en la receta.",
        "Cierra la definición de `cons-transformed-aux` con un paréntesis, como el punto final de la receta auxiliar.",
        "Define la función principal `cons-transformed` que toma `x` y `lst`, inicializando la recursión con un acumulador vacío, como preparar el inicio del proceso.",
        "Llama a `cons-transformed-aux` con `x`, `lst`, y `null`, como iniciar la receta con un acumulador vacío.",
        "Cierra la definición de `cons-transformed` con un paréntesis, necesario para la sintaxis de Racket.",
        "Llama a `cons-transformed` con 0 and `(1 2 3 4)`, retornando `(0 1 2 3 4)`, como completar la lista transformada."
      ],
      "explanations_ocaml": [
        "Define una función auxiliar recursiva `cons_transformed_aux` que toma `x`, `lst`, y `acc`. En OCaml, `let rec nombre params = cuerpo` habilita recursión, como una receta para transformar y añadir un elemento.",
        "Define `transformed` como `x * 2`, duplicando el elemento, como calcular el nuevo valor a añadir.",
        "Define `len` como `List.length lst`, contando los elementos de la lista original.",
        "Define `new_lst` como `transformed :: lst`, añadiendo el elemento transformado al inicio, como preparar una lista temporal.",
        "Inicia un condicional `if` para verificar si `new_lst` está vacía con `new_lst = []`, como preguntar si la lista temporal está completa.",
        "Si `new_lst` está vacía, retorna `List.rev acc`, invirtiendo el acumulador para obtener el orden correcto, como entregar el resultado final.",
        "Introduce la rama `else` para manejar el caso donde `new_lst` no está vacía, preparando la recursión.",
        "Define `first_el` como `List.hd new_lst`, tomando el primer elemento de la lista temporal.",
        "Define `rest_el` como `List.tl new_lst`, obteniendo el resto de la lista temporal.",
        "Define `len_rest` como `List.length rest_el`, contando los elementos restantes.",
        "Llama recursivamente a `cons_transformed_aux` con 0, `rest_el`, y un acumulador con `first_el` usando `first_el :: acc`, como continuar construyendo la lista.",
        "Define la función principal `cons_transformed` que inicializa la recursión con un acumulador vacío.",
        "Llama a `cons_transformed_aux` con `x`, `lst`, y `[]`, como iniciar la receta con un acumulador vacío.",
        "Usa `in` para conectar la definición de `cons_transformed` con la llamada, una regla estructural de OCaml.",
        "Llama a `cons_transformed` con 0 and `[1; 2; 3; 4]`, retornando `[0; 1; 2; 3; 4]`."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función auxiliar recursiva para añadir un elemento transformado, dando `(0 1 2 3 4)`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo` con `rec` explícito para recursión.",
        "Similitudes: Ambas calculan el elemento transformado multiplicando por 2. Diferencias: Racket usa `(* x 2)` con notación prefija, OCaml usa `x * 2` con notación infija, más matemática.",
        "Similitudes: Ambas calculan la longitud de la lista original para verificar su tamaño. Diferencias: Racket usa `(length lst)`, OCaml usa `List.length lst` con notación de módulo.",
        "Similitudes: Ambas añaden el elemento transformado al inicio de la lista. Diferencias: Racket usa `(cons transformed lst)` con notación prefija, OCaml usa `transformed :: lst` con notación infija.",
        "Similitudes: Ambas verifican si la lista temporal está vacía. Diferencias: Racket usa `(empty? new-lst)` con notación prefija, OCaml usa `new_lst = []` con notación infija.",
        "Similitudes: Ambas retornan el acumulador si la lista está vacía. Diferencias: Racket usa `acc` directamente, OCaml usa `List.rev acc` para corregir el orden debido a la construcción de la lista.",
        "Similitudes: Ambas manejan el caso no vacío para continuar la recursión. Diferencias: Racket usa un `let` anidado para definir variables, OCaml usa `else` explícitamente para estructurar la lógica.",
        "Similitudes: Ambas extraen el primer elemento de la lista temporal. Diferencias: Racket usa `(first new-lst)`, OCaml usa `List.hd new_lst` con notación de módulo.",
        "Similitudes: Ambas obtienen el resto de la lista temporal. Diferencias: Racket usa `(rest new-lst)`, OCaml usa `List.tl new_lst`.",
        "Similitudes: Ambas calculan la longitud del resto de la lista para verificar si hay más elementos. Diferencias: Racket usa `(length rest-el)`, OCaml usa `List.length rest_el`.",
        "Similitudes: Ambas llaman recursivamente a la función auxiliar con un acumulador actualizado. Diferencias: Racket usa `(cons-transformed-aux 0 rest-el (cons first-el acc))` con notación prefija, OCaml usa `cons_transformed_aux 0 rest_el (first_el :: acc)` con notación infija.",
        "Similitudes: Ambas definen una función principal que inicializa la recursión. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo` sin necesidad de `rec` en la función principal.",
        "Similitudes: Ambas inicializan la recursión con un acumulador vacío. Diferencias: Racket usa `null` como acumulador inicial, OCaml usa `[]`, reflejando diferencias en la sintaxis de listas vacías.",
        "Similitudes: Ambas son líneas estructurales necesarias para completar la definición. Diferencias: Racket cierra la función auxiliar y principal con `)`, OCaml usa `in` para conectar la definición principal con la llamada.",
        "Similitudes: Ambas llaman la función principal con 0 and una lista de 4 elementos, retornando `(0 1 2 3 4)`. Diferencias: Racket usa `(cons-transformed 0 '(1 2 3 4))` con comillas y paréntesis, OCaml usa `cons_transformed 0 [1; 2; 3; 4]` con corchetes y `;` para listas."
      ]
    }
  },
  "funciones-orden-superior": {
    "ejercicio-1": {
      "title": "Aplicar descuento a precios con map",
      "racket": {
        "lines": [
          "(define (apply-discount lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (map (lambda (x) (* x 0.85)) lst)",
          "  )",
          ")",
          "(apply-discount '(100 200 300))"
        ]
      },
      "ocaml": {
        "lines": [
          "let apply_discount lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.map (fun x -> x *. 0.85) lst",
          "in",
          "apply_discount [100; 200; 300]"
        ]
      },
      "explanations_racket": [
        "Define una función llamada `apply-discount` que toma una lista `lst` (como precios de productos). En Racket, `(define (nombre params) cuerpo)` es como nombrar una receta para procesar datos, asegurando que no modificamos los precios originales.",
        "Verifica si la lista está vacía con `(empty? lst)`. Es como revisar si el carrito de compras está vacío antes de aplicar descuentos.",
        "Si la lista está vacía, devuelve `()` (una lista vacía). Esto evita errores, como intentar descontar nada.",
        "Si la lista no está vacía, usa `map` para aplicar una función anónima `(lambda (x) (* x 0.85))` a cada precio, multiplicándolo por 0.85 (descuento del 15%). `map` es como un asistente que ajusta cada precio uno por uno, creando una nueva lista.",
        "Cierra la condición `if` y la función, siguiendo las reglas de Racket con paréntesis.",
        "Cierra la definición de la función, completando la 'receta'.",
        "Llama a `apply-discount` con la lista `(100 200 300)`, dando `(85.0 170.0 255.0)`, como mostrar los precios finales tras el descuento."
      ],
      "explanations_ocaml": [
        "Define una función `apply_discount` que toma una lista `lst`. En OCaml, `let nombre params = cuerpo` es como crear una instrucción para procesar datos, manteniendo los precios originales intactos.",
        "Verifica si la lista está vacía con `lst = []`. Es como comprobar si no hay productos en el carrito.",
        "Si la lista está vacía, devuelve `[]` (lista vacía). Esto previene problemas al procesar nada.",
        "Si la lista no está vacía, introduce la rama `else`, requerida en OCaml para completar la condición.",
        "Usa `List.map` para aplicar `(fun x -> x *. 0.85)` a cada elemento, multiplicando por 0.85 para el descuento. `List.map` es como un empleado que ajusta cada precio, creando una nueva lista.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `apply_discount` con `[100; 200; 300]`, dando `[85.0; 170.0; 255.0]`, mostrando los precios con descuento."
      ],
      "comparisons": [
        "Similitudes: Ambas funciones aplican un descuento usando `map`, creando una nueva lista sin cambiar la original. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal. OCaml infiere tipos (lista de enteros a flotantes).",
        "Similitudes: Ambas verifican si la lista está vacía para robustez. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija, más intuitiva para matemáticas.",
        "Similitudes: Ambas devuelven una lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`, reflejando notaciones de lista distintas.",
        "Similitudes: Ambas transforman la lista con una función anónima. Diferencias: Racket usa `(lambda (x) (* x 0.85))` prefija, OCaml usa `(fun x -> x *. 0.85)` infija con `*.` para flotantes. OCaml requiere `List.map` por su módulo `List`.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `else` explícito y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in` para separar definición y llamada.",
        "Similitudes: Ambas llaman la función con listas idénticas, dando `(85.0 170.0 255.0)`. Diferencias: Racket usa `'(100 200 300)` con comillas, OCaml usa `[100; 200; 300]` con punto y coma."
      ]
    },
    "ejercicio-2": {
      "title": "Filtrar productos con stock y precio específicos",
      "racket": {
        "lines": [
          "(define (filter-stock lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (filter (lambda (x) (and (> x 5) (< x 50))) lst)",
          "  )",
          ")",
          "(filter-stock '(10 60 30 40 70))"
        ]
      },
      "ocaml": {
        "lines": [
          "let filter_stock lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.filter (fun x -> x > 5 && x < 50) lst",
          "in",
          "filter_stock [10; 60; 30; 40; 70]"
        ]
      },
      "explanations_racket": [
        "Define una función `filter-stock` que toma una lista `lst` (como cantidades en un inventario). `(define (nombre params) cuerpo)` es como crear una regla para elegir productos.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si el almacén está vacío.",
        "Si está vacía, devuelve `()` (lista vacía), evitando errores.",
        "Usa `filter` para aplicar `(lambda (x) (and (> x 5) (< x 50)))`, seleccionando números entre 5 y 50. Es como un filtro que elige productos con stock adecuado y precio bajo.",
        "Cierra la condición `if` y la función con paréntesis.",
        "Cierra la definición de la función, completando la regla.",
        "Llama a `filter-stock` con `(10 60 30 40 70)`, dando `(10 30 40)`, como mostrar los productos seleccionados."
      ],
      "explanations_ocaml": [
        "Define una función `filter_stock` que toma una lista `lst`. `let nombre params = cuerpo` es como escribir una instrucción para seleccionar productos.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay productos.",
        "Si está vacía, devuelve `[]` (lista vacía), previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml para manejar el caso no vacío.",
        "Usa `List.filter` para aplicar `(fun x -> x > 5 && x < 50)`, seleccionando números entre 5 y 50. Es como un tamiz que elige productos específicos.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `filter_stock` con `[10; 60; 30; 40; 70]`, dando `[10; 30; 40]`, mostrando los productos seleccionados."
      ],
      "comparisons": [
        "Similitudes: Ambas filtran elementos usando `filter`, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican listas vacías. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`.",
        "Similitudes: Ambas usan `filter`/`List.filter` con un predicado compuesto. Diferencias: Racket usa `(and (> x 5) (< x 50))` prefija, OCaml usa `x > 5 && x < 50` infija. OCaml requiere `List.filter`.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `else` y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con listas idénticas, dando `(10 30 40)`. Diferencias: Racket usa `'(10 60 30 40 70)`, OCaml usa `[10; 60; 30; 40; 70]`."
      ]
    },
    "ejercicio-3": {
      "title": "Filtrar y elevar al cuadrado costos",
      "racket": {
        "lines": [
          "(define (process-costs lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (let ((filtered (filter (lambda (x) (> (abs x) 3)) lst)))",
          "        (map (lambda (x) (* (abs x) (abs x))) filtered)",
          "      )",
          "  )",
          ")",
          "(process-costs '(2 3 -4 5 -6))"
        ]
      },
      "ocaml": {
        "lines": [
          "let process_costs lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    let filtered = List.filter (fun x -> abs x > 3) lst in",
          "    List.map (fun x -> (abs x) * (abs x)) filtered",
          "in",
          "process_costs [2; 3; -4; 5; -6]"
        ]
      },
      "explanations_racket": [
        "Define una función `process-costs` que toma una lista `lst` (como costos). `(define (nombre params) cuerpo)` es como crear un proceso para analizar costos.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay costos registrados.",
        "Si está vacía, devuelve `()` (lista vacía), evitando errores.",
        "Usa `let` para almacenar el resultado de `filter` en `filtered`. `filter` aplica `(lambda (x) (> (abs x) 3))`, seleccionando valores cuyo valor absoluto es mayor a 3. Es como elegir costos significativos.",
        "Aplica `map` con `(lambda (x) (* (abs x) (abs x)))` a la lista filtrada, calculando el cuadrado de valores absolutos. Es como calcular el impacto al cuadrado de los costos seleccionados.",
        "Cierra la condición `let` y `if`, siguiendo la sintaxis de Racket.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `process-costs` con `(2 3 -4 5 -6)`, dando `(16 25 36)`, mostrando los costos procesados."
      ],
      "explanations_ocaml": [
        "Define una función `process_costs` que toma una lista `lst`. `let nombre params = cuerpo` es como escribir un procedimiento para costos.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay datos.",
        "Si está vacía, devuelve `[]` (lista vacía), previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml.",
        "Usa `let filtered = ...` para guardar el resultado de `List.filter` con `(fun x -> abs x > 3)`, seleccionando valores absolutos mayores a 3. Es como elegir costos relevantes.",
        "Aplica `List.map` con `(fun x -> (abs x) * (abs x))` a la lista filtrada, calculando cuadrados. Es como procesar los costos seleccionados.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `process_costs` con `[2; 3; -4; 5; -6]`, dando `[16; 25; 36]`, mostrando los resultados."
      ],
      "comparisons": [
        "Similitudes: Ambas filtran y transforman listas usando `filter` y `map`. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican listas vacías. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`.",
        "Similitudes: Ambas filtran con un predicado basado en valor absoluto. Diferencias: Racket usa `(let ((filtered ...)))` con paréntesis, OCaml usa `let filtered = ... in` más lineal.",
        "Similitudes: Ambas aplican `map` para calcular cuadrados. Diferencias: Racket usa `(lambda (x) (* (abs x) (abs x)))` prefija, OCaml usa `(fun x -> (abs x) * (abs x))` infija.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con listas idénticas, dando `(16 25 36)`. Diferencias: Racket usa `'(2 3 -4 5 -6)`, OCaml usa `[2; 3; -4; 5; -6]`."
      ]
    },
    "ejercicio-4": {
      "title": "Sumar transacciones mayores a un umbral",
      "racket": {
        "lines": [
          "(define (sum-transactions threshold lst)",
          "  (if (empty? lst)",
          "      0",
          "      (foldl + 0 (filter (lambda (x) (> x threshold)) lst))",
          "  )",
          ")",
          "(sum-transactions 100 '(100 -50 200 -30 150))"
        ]
      },
      "ocaml": {
        "lines": [
          "let sum_transactions threshold lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    List.fold_left (+) 0 (List.filter (fun x -> x > threshold) lst)",
          "in",
          "sum_transactions 100 [100; -50; 200; -30; 150]"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-transactions` que toma un `threshold` (umbral) y una lista `lst` (como transacciones). `(define (nombre params) cuerpo)` es como crear una calculadora de totales.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay transacciones.",
        "Si está vacía, devuelve `0`, evitando errores en el cálculo.",
        "Usa `foldl` para sumar (`+`) los elementos filtrados por `(filter (lambda (x) (> x threshold)) lst)`, seleccionando transacciones mayores al umbral. Es como sumar solo las transacciones grandes.",
        "Cierra la condición `if` y la función con paréntesis.",
        "Cierra la definición de la función.",
        "Llama a `sum-transactions` con umbral `100` y lista `(100 -50 200 -30 150)`, dando `350` (200 + 150)."
      ],
      "explanations_ocaml": [
        "Define una función `sum_transactions` que toma `threshold` y `lst`. `let nombre params = cuerpo` es como programar una calculadora de transacciones.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay datos.",
        "Si está vacía, devuelve `0`, previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml.",
        "Usa `List.fold_left (+) 0` para sumar los elementos filtrados por `List.filter (fun x -> x > threshold)`, seleccionando transacciones mayores al umbral. Es como calcular el total de transacciones relevantes.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `sum_transactions` con `100` y `[100; -50; 200; -30; 150]`, dando `350`."
      ],
      "comparisons": [
        "Similitudes: Ambas suman transacciones usando `filter` y `fold`, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas verifican listas vacías. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven `0` para listas vacías. Diferencias: Notación idéntica, pero Racket usa `'()` para listas vacías en otros contextos.",
        "Similitudes: Ambas usan `filter` y `fold` para procesar datos. Diferencias: Racket usa `(foldl + 0 ...)` prefija, OCaml usa `List.fold_left (+) 0` infija. OCaml requiere módulos `List`.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `else` y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con umbral y lista idéntica, dando `350`. Diferencias: Racket usa `'(100 -50 200 -30 150)`, OCaml usa `[100; -50; 200; -30; 150]`."
      ]
    },
    "ejercicio-5": {
      "title": "Procesar valores financieros con currying",
      "racket": {
        "lines": [
          "(define (make-financial-processor threshold)",
          "  (lambda (lst)",
          "    (if (empty? lst)",
          "        0",
          "        (foldl + 0",
          "               (filter (lambda (x) (> x threshold))",
          "                       (map abs lst))",
          "        )",
          "    )",
          "  )",
          ")",
          "((make-financial-processor 150) '(-200 300 -100 400))"
        ]
      },
      "ocaml": {
        "lines": [
          "let make_financial_processor threshold =",
          "  fun lst ->",
          "    if lst = [] then",
          "      0",
          "    else",
          "      List.fold_left (+) 0",
          "        (List.filter (fun x -> x > threshold)",
          "           (List.map abs lst))",
          "in",
          "make_financial_processor 150 [-200; 300; -100; 400]"
        ]
      },
      "explanations_racket": [
        "Define una función `make-financial-processor` que toma un `threshold` (umbral) y devuelve otra función. `(define (nombre params) cuerpo)` es como crear una máquina configurable para procesar finanzas, como ajustar un filtro de transacciones.",
        "Crea una función anónima `(lambda (lst) ...)` que procesará una lista. Es como ajustar la máquina para trabajar con datos específicos.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay transacciones para procesar.",
        "Si la lista está vacía, devuelve `0`, evitando errores en el cálculo.",
        "Usa `foldl` con `+` y valor inicial `0` para sumar los elementos filtrados, que son seleccionados por `filter` de los resultados de `map`. Es como sumar transacciones válidas después de ajustarlas.",
        "Aplica `filter` con `(lambda (x) (> x threshold))` para seleccionar valores mayores al umbral, como elegir transacciones significativas.",
        "Aplica `map` con `abs` para convertir cada valor a positivo, como corregir números negativos en un reporte financiero.",
        "Cierra la condición `if` y la función anónima con paréntesis, siguiendo la sintaxis de Racket.",
        "Cierra la definición de la función anónima.",
        "Cierra la definición de la función principal con paréntesis.",
        "Crea una función con umbral `150` y la aplica a la lista `(-200 300 -100 400)`, dando `700` (200 + 300 + 400), como calcular el total de transacciones válidas."
      ],
      "explanations_ocaml": [
        "Define una función `make_financial_processor` que toma `threshold` y devuelve otra función. `let nombre params = cuerpo` es como programar una calculadora ajustable para finanzas.",
        "Crea una función anónima con `fun lst ->`, que procesará una lista. Es como configurar la calculadora para una lista específica.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay datos financieros.",
        "Si la lista está vacía, devuelve `0`, previniendo errores.",
        "Introduce la rama `else`, requerida en OCaml para manejar el caso no vacío.",
        "Usa `List.fold_left` con `(+) 0` para sumar los elementos filtrados por `List.filter`, que selecciona valores mayores al umbral de los resultados de `List.map`. Es como procesar transacciones en pasos.",
        "Aplica `List.filter` con `(fun x -> x > threshold)` para elegir valores mayores al umbral.",
        "Aplica `List.map` con `abs` para convertir valores a positivos, como ajustar un reporte.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Crea una función con umbral `150` y la aplica a `[-200; 300; -100; 400]`, dando `700`, mostrando el total de transacciones válidas."
      ],
      "comparisons": [
        "Similitudes: Ambas usan currying para crear una función que devuelve otra, procesando listas con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas crean funciones anónimas para procesar listas. Diferencias: Racket usa `(lambda (lst) ...)`, OCaml usa `fun lst ->`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven `0` para listas vacías. Diferencias: Notación idéntica, pero contextos distintos.",
        "Similitudes: Ambas usan un pipeline de `map`, `filter`, y `fold` para procesar datos. Diferencias: Racket usa `(foldl + 0 ...)` prefija, OCaml usa `List.fold_left (+) 0` infija. OCaml requiere módulos `List`.",
        "Similitudes: Ambas filtran valores con un predicado. Diferencias: Racket usa `(lambda (x) (> x threshold))`, OCaml usa `(fun x -> x > threshold)`.",
        "Similitudes: Ambas aplican valor absoluto con `map`. Diferencias: Racket usa `(map abs lst)`, OCaml usa `List.map abs lst`.",
        "Similitudes: Ambas cierran la lógica anidada. Diferencias: Racket usa paréntesis, OCaml usa indentación y `in`.",
        "Similitudes: Ambas cierran la función anónima. Diferencias: Racket usa paréntesis, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas aplican la función con umbral `150` y lista idéntica, dando `700`. Diferencias: Racket usa `'(-200 300 -100 400)`, OCaml usa `[-200; 300; -100; 400]`."
      ]
    },
    "ejercicio-6": {
      "title": "Procesar ventas estructuradas con filter, map y fold",
      "racket": {
        "lines": [
          "(define (process-sales pred extractor lst)",
          "  (if (empty? lst)",
          "      0",
          "      (foldl + 0",
          "             (map extractor",
          "                  (filter pred lst))",
          "      )",
          "  )",
          ")",
          "(process-sales",
          "  (lambda (p) (and (string=? (cdr p) \"venta\") (> (car p) 0)))",
          "  car",
          "  '((200 . \"venta\") (-50 . \"devolucion\") (300 . \"venta\") (-20 . \"devolucion\")))"
        ]
      },
      "ocaml": {
        "lines": [
          "let process_sales pred extractor lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    List.fold_left (+) 0",
          "      (List.map extractor",
          "         (List.filter pred lst))",
          "in",
          "process_sales",
          "  (fun (m, t) -> t = \"venta\" && m > 0)",
          "  fst",
          "  [(200, \"venta\"); (-50, \"devolucion\"); (300, \"venta\"); (-20, \"devolucion\")]"
        ]
      },
      "explanations_racket": [
        "Define una función `process-sales` que toma un `pred` (regla de selección), un `extractor` (para obtener datos) y una lista `lst` de parejas (monto, tipo). `(define (nombre params) cuerpo)` es como crear un sistema para sumar ventas.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay registros de ventas.",
        "Si la lista está vacía, devuelve `0`, evitando errores en la suma.",
        "Usa `foldl` con `+` y valor inicial `0` para sumar los resultados de `map`, que aplica `extractor` a las parejas seleccionadas por `filter` con `pred`. Es como calcular el total de ventas válidas.",
        "Aplica `map` con `extractor` (como `car`) para extraer montos de las parejas filtradas, como tomar solo los valores numéricos.",
        "Aplica `filter` con `pred` para seleccionar parejas que cumplan la condición, como elegir solo ventas positivas.",
        "Cierra la condición `if` y el bloque de `foldl` con paréntesis.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `process-sales` con un predicado, `car` como extractora, y una lista de parejas, dando `500` (200 + 300).",
        "Define el predicado `(lambda (p) (and (string=? (cdr p) \"venta\") (> (car p) 0)))`, que verifica si la pareja tiene tipo \"venta\" y monto positivo. Es como una regla para identificar ventas válidas.",
        "Usa `car` como `extractor` para obtener el monto de cada pareja, como extraer el número de un registro.",
        "Pasa la lista de parejas `((200 . \"venta\") ...)` estructurada como pares en Racket, como un registro de transacciones."
      ],
      "explanations_ocaml": [
        "Define una función `process_sales` que toma `pred`, `extractor` y `lst` (parejas de monto y tipo). `let nombre params = cuerpo` es como programar un sistema para calcular ventas.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay registros.",
        "Si la lista está vacía, devuelve `0`, previniendo errores en la suma.",
        "Introduce la rama `else`, necesaria en OCaml para manejar el caso no vacío.",
        "Usa `List.fold_left` con `(+) 0` para sumar los resultados de `List.map`, que aplica `extractor` a las parejas filtradas por `List.filter` con `pred`. Es como sumar montos de ventas válidas.",
        "Aplica `List.map` con `extractor` (como `fst`) para extraer montos de las parejas filtradas.",
        "Aplica `List.filter` con `pred` para seleccionar parejas que cumplan la condición.",
        "Usa `in` para conectar la definición con la llamada, una regla de OCaml.",
        "Llama a `process_sales` con un predicado, `fst` como extractora, y la lista de parejas, dando `500`.",
        "Define el predicado `(fun (m, t) -> t = \"venta\" && m > 0)`, que verifica si la pareja tiene tipo \"venta\" y monto positivo.",
        "Usa `fst` como `extractor` para obtener el monto de cada pareja.",
        "Pasa la lista de parejas `[(200, \"venta\") ...]` estructurada como tuplas en OCaml."
      ],
      "comparisons": [
        "Similitudes: Ambas procesan parejas usando `filter`, `map` y `fold` para sumar montos, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven `0` para listas vacías. Diferencias: Notación idéntica, pero Racket usa `'()` en otros contextos.",
        "Similitudes: Ambas usan un pipeline de `filter`, `map` y `fold`. Diferencias: Racket usa `(foldl + 0 ...)` prefija, OCaml usa `List.fold_left (+) 0` infija. OCaml requiere módulos `List`.",
        "Similitudes: Ambas aplican `map` con una función extractora. Diferencias: Racket usa `(map extractor ...)`, OCaml usa `List.map extractor ...`.",
        "Similitudes: Ambas filtran con un predicado personalizado. Diferencias: Racket usa `(filter pred lst)`, OCaml usa `List.filter pred lst`.",
        "Similitudes: Ambas cierran la lógica anidada. Diferencias: Racket usa paréntesis, OCaml usa indentación y `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con predicado, extractora y lista idéntica, dando `500`. Diferencias: Racket usa `'(200 . \"venta\")` con notación de par, OCaml usa `(200, \"venta\")` con tuplas."
      ]
    },
    "ejercicio-7": {
      "title": "Procesar calificaciones anidadas con map, filter y fold",
      "racket": {
        "lines": [
          "(define (process-grades lst)",
          "  (if (empty? lst)",
          "      '()",
          "      (filter (lambda (avg) (> avg 80))",
          "              (map (lambda (sublst)",
          "                     (if (empty? sublst)",
          "                         0",
          "                         (let ((approved (filter (lambda (g) (> g 70)) sublst)))",
          "                           (if (empty? approved)",
          "                               0",
          "                               (/ (foldl + 0 approved) (length approved)))",
          "                         )",
          "                     )",
          "                   lst)",
          "              )",
          "      )",
          "  )",
          ")",
          "(process-grades '((70 80 90) (60 85 95) (50 60)))"
        ]
      },
      "ocaml": {
        "lines": [
          "let process_grades lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.filter (fun avg -> avg > 80)",
          "      (List.map (fun sublst ->",
          "                   if sublst = [] then",
          "                     0",
          "                   else",
          "                     let approved = List.filter (fun g -> g > 70) sublst in",
          "                     if approved = [] then",
          "                       0",
          "                     else",
          "                       (List.fold_left (+) 0 approved) / (List.length approved)",
          "                ) lst",
          "      )",
          "in",
          "process_grades [[70; 80; 90]; [60; 85; 95]; [50; 60]]"
        ]
      },
      "explanations_racket": [
        "Define una función `process-grades` que toma una lista `lst` de sublistas (calificaciones por estudiante). `(define (nombre params) cuerpo)` es como crear un sistema para evaluar estudiantes.",
        "Verifica si la lista está vacía con `(empty? lst)`, como revisar si no hay estudiantes registrados.",
        "Si la lista está vacía, devuelve `()` (lista vacía), evitando errores.",
        "Usa `filter` con `(lambda (avg) (> avg 80))` para seleccionar promedios mayores a 80, aplicados a los resultados de `map`. Es como elegir estudiantes destacados.",
        "Aplica `map` con `(lambda (sublst) ...)` a cada sublista para calcular el promedio de calificaciones aprobadas (>70).",
        "Verifica si la sublista está vacía con `(empty? sublst)`, como comprobar si un estudiante no tiene calificaciones.",
        "Si la sublista está vacía, devuelve `0` como promedio, previniendo errores.",
        "Usa `let` para almacenar las calificaciones aprobadas, filtradas con `(filter (lambda (g) (> g 70)) sublst)`, como seleccionar solo notas válidas.",
        "Verifica si no hay calificaciones aprobadas con `(empty? approved)`.",
        "Si no hay calificaciones aprobadas, devuelve `0` como promedio.",
        "Calcula el promedio dividiendo la suma de calificaciones aprobadas (`foldl + 0 approved`) por su cantidad (`length approved`). Es como promediar las notas válidas de un estudiante.",
        "Cierra la condición `if` y la función anónima de `map`.",
        "Cierra el bloque de `map` y `filter`.",
        "Cierra la condición `if` y la definición de la función.",
        "Cierra la definición de la función con paréntesis.",
        "Llama a `process-grades` con `((70 80 90) (60 85 95) (50 60))`, dando `(85 90)`, mostrando los promedios de estudiantes destacados."
      ],
      "explanations_ocaml": [
        "Define una función `process_grades` que toma una lista `lst` de sublistas. `let nombre params = cuerpo` es como programar un sistema escolar para evaluar calificaciones.",
        "Verifica si la lista está vacía con `lst = []`, como comprobar si no hay estudiantes.",
        "Si la lista está vacía, devuelve `[]` (lista vacía), previniendo errores.",
        "Introduce la rama `else`, necesaria en OCaml para manejar el caso no vacío.",
        "Usa `List.filter` con `(fun avg -> avg > 80)` para seleccionar promedios mayores a 80, aplicados a los resultados de `List.map`.",
        "Aplica `List.map` con `(fun sublst -> ...)` para calcular el promedio de calificaciones aprobadas por estudiante.",
        "Verifica si la sublista está vacía con `sublst = []`, como revisar si un estudiante no tiene notas.",
        "Si la sublista está vacía, devuelve `0` como promedio.",
        "Introduce `else` para manejar sublistas no vacías.",
        "Usa `let approved = ...` para guardar las calificaciones aprobadas, filtradas con `List.filter (fun g -> g > 70) sublst`.",
        "Verifica si no hay calificaciones aprobadas con `approved = []`.",
        "Si no hay aprobadas, devuelve `0` como promedio.",
        "Introduce `else` para calcular el promedio.",
        "Calcula el promedio con `(List.fold_left (+) 0 approved) / (List.length approved)`, sumando las calificaciones aprobadas y dividiendo por su cantidad.",
        "Cierra la función anónima de `List.map`.",
        "Cierra el bloque de `List.map` y `List.filter`.",
        "Usa `in` para conectar la definición con la llamada.",
        "Llama a `process_grades` con `[[70; 80; 90]; [60; 85; 95]; [50; 60]]`, dando `[85; 90]`, mostrando los promedios destacados."
      ],
      "comparisons": [
        "Similitudes: Ambas procesan listas anidadas usando `filter`, `map` y `fold` para calcular promedios, con pureza funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, OCaml usa `let nombre params = cuerpo` más lineal.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)`, OCaml usa `lst = []`.",
        "Similitudes: Ambas devuelven una lista vacía para casos extremos. Diferencias: Racket usa `'()`, OCaml usa `[]`.",
        "Similitudes: Ambas filtran promedios mayores a 80. Diferencias: Racket usa `(filter (lambda (avg) (> avg 80)))`, OCaml usa `List.filter (fun avg -> avg > 80)`.",
        "Similitudes: Ambas mapean sublistas para calcular promedios. Diferencias: Racket usa `(map (lambda (sublst) ...))`, OCaml usa `List.map (fun sublst -> ...)`.",
        "Similitudes: Ambas verifican si la sublista está vacía. Diferencias: Racket usa `(empty? sublst)`, OCaml usa `sublst = []`.",
        "Similitudes: Ambas devuelven `0` para sublistas vacías. Diferencias: Notación idéntica, pero contextos distintos.",
        "Similitudes: Ambas filtran calificaciones aprobadas. Diferencias: Racket usa `(let ((approved ...)))` con paréntesis, OCaml usa `let approved = ... in` más lineal.",
        "Similitudes: Ambas verifican si no hay calificaciones aprobadas. Diferencias: Racket usa `(empty? approved)`, OCaml usa `approved = []`.",
        "Similitudes: Ambas devuelven `0` si no hay calificaciones aprobadas. Diferencias: Notación idéntica.",
        "Similitudes: Ambas calculan promedios con suma y división. Diferencias: Racket usa `(foldl + 0 ...)/(length ...)`, OCaml usa `List.fold_left (+) 0 .../List.length ...`.",
        "Similitudes: Ambas cierran la lógica anidada de `map`. Diferencias: Racket usa paréntesis, OCaml usa indentación.",
        "Similitudes: Ambas cierran el bloque de `filter` y `map`. Diferencias: Racket usa paréntesis, OCaml usa paréntesis e indentación.",
        "Similitudes: Ambas cierran la lógica condicional. Diferencias: Racket usa paréntesis, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con listas anidadas idénticas, dando `(85 90)`. Diferencias: Racket usa `'((70 80 90) ...)`, OCaml usa `[[70; 80; 90]; ...]` con punto y coma."
      ]
    }
  },
  "tipos-datos-simples": {
    "ejercicio-1": {
      "title": "Suma de tuplas con validación",
      "racket": {
        "lines": [
          "(define (sum-tuple t)",
          "  (if (and (pair? t) (number? (car t)) (number? (cdr t)))",
          "      (+ (car t) (cdr t))",
          "      (error \"Input must be a pair of numbers\"))",
          ")",
          "(sum-tuple '(5 . 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let sum_tuple (a, b) =",
          "  if (is_int a && is_int b) || (is_float a && is_float b) then",
          "    a +. (float_of_int b)",
          "  else",
          "    failwith \"Input must be a pair of numbers\"",
          "in",
          "sum_tuple (5, 3)"
        ]
      },
      "explanations_racket": [
        "Imagina que tienes una caja con dos compartimentos (una 'tupla') donde guardas dos números, como 5 y 3, que representan horas trabajadas en dos días. Esta línea crea una función llamada `sum-tuple` que toma esa caja (`t`) y promete sumarlos. Es como escribir una receta para sumar las horas de trabajo.",
        "Aquí revisamos si la caja realmente tiene dos compartimentos (`pair? t`) y si cada compartimento contiene un número (`number? (car t))` para el primero y (`number? (cdr t))` para el segundo). Es como mirar dentro de la caja para asegurarte de que tienes dos números válidos antes de sumarlos, no letras ni objetos extraños.",
        "Si todo está correcto, sumamos los dos números con `+`. Es como tomar las horas (5 y 3) y calcular el total de horas trabajadas (8).",
        "Si algo falla (por ejemplo, la caja no tiene dos números), mostramos un mensaje de error, como cuando un recibo tiene datos incorrectos y el sistema te avisa.",
        "Cerramos la receta con un paréntesis, como ponerle el sello final a las instrucciones en Racket.",
        "Usamos la función con la caja `(5 . 3)`, que nos da 8. Es como usar la receta para sumar las horas de trabajo de dos días y obtener el total."
      ],
      "explanations_ocaml": [
        "Piensa en una caja con dos espacios (una 'tupla') que guarda dos números, como 5 y 3, para horas trabajadas. Esta línea crea una función `sum_tuple` que toma esos dos espacios (`a, b`) para sumarlos. Es como escribir una nota con instrucciones para sumar horas.",
        "Comprobamos si ambos espacios tienen números, ya sean enteros (`is_int`) o decimales (`is_float`). Es como revisar que en la caja solo haya números que podamos sumar, no palabras ni dibujos.",
        "Si son números, los sumamos con `+.`, convirtiendo el segundo a decimal si es necesario (`float_of_int b`). Es como sumar las horas de trabajo, asegurándote de que el formato sea correcto para la calculadora.",
        "Si algo no es un número, pasamos a esta línea, que es como un plan B en OCaml para manejar problemas.",
        "Si los datos son incorrectos, mostramos un mensaje de error con `failwith`. Es como cuando intentas sumar algo que no es un número y el sistema te dice 'esto no sirve'.",
        "Con `in`, conectamos las instrucciones con la acción final, como firmar la nota antes de usarla en OCaml.",
        "Usamos la función con `(5, 3)`, que da 8. Es como aplicar la nota para sumar las horas y obtener el total."
      ],
      "comparisons": [
        "Ambas funciones suman dos números en una tupla, como sumar horas de trabajo. Racket usa `(define (nombre params) cuerpo)` con muchos paréntesis, como escribir una receta detallada en una libreta con pasos claros. OCaml usa `let nombre params = cuerpo`, que es más como una nota directa en una hoja, sin tantos paréntesis.",
        "Ambas verifican que los datos sean números. Racket usa `(pair? t)` para checar la caja y `(number? ...)` para los números, como revisar cada compartimento con una lupa. OCaml usa `(is_int ...)` o `(is_float ...)` en una sola línea, como una revisión rápida con una lista de chequeo.",
        "Ambas suman si los datos son válidos. Racket usa `(+ (car t) (cdr t))`, poniendo el signo `+` primero, como escribir la operación al revés. OCaml usa `a +. (float_of_int b)`, más parecido a cómo escribimos sumas en la escuela, con un punto para decimales.",
        "Ambas manejan errores. Racket usa `(error ...)`, como un cartel grande que dice 'algo salió mal'. OCaml usa `else` y `failwith`, como una nota más pequeña pero igual de clara.",
        "Racket cierra con `)`, como cerrar un cuaderno. OCaml usa `in`, como pasar a la siguiente página para terminar el trabajo.",
        "Ambas usan la función con datos iguales y dan 8. Racket escribe la tupla como `(5 . 3)`, como una caja con un punto en el medio. OCaml usa `(5, 3)`, como una lista separada por una coma, más común en otros lenguajes."
      ]
    },
    "ejercicio-2": {
      "title": "Extracción segura del primer elemento de una tupla",
      "racket": {
        "lines": [
          "(define (first-of-tuple t)",
          "  (if (pair? t)",
          "      (car t)",
          "      (error \"Input must be a pair\"))",
          ")",
          "(first-of-tuple '(7 . 8))"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_of_tuple (a, _) =",
          "  a",
          "in",
          "first_of_tuple (7, 8)"
        ]
      },
      "explanations_racket": [
        "Imagina una caja con dos espacios, como una coordenada (7, 8) para un punto en un mapa. Esta línea crea una función `first-of-tuple` que toma esa caja (`t`) para sacar el primer número, como la posición horizontal en el mapa.",
        "Revisamos si la caja tiene dos espacios con `(pair? t)`. Es como mirar si el mapa tiene un punto con dos valores (x, y).",
        "Si es una caja válida, sacamos el primer número con `(car t)`. Es como tomar solo la posición x del punto (7).",
        "Si la caja no es válida, mostramos un mensaje de error, como cuando el mapa tiene un error y no puedes leer la coordenada.",
        "Cerramos la función con un paréntesis, como guardar la receta en un cajón.",
        "Usamos la función con `(7 . 8)`, que da 7, como obtener la posición horizontal del punto en el mapa."
      ],
      "explanations_ocaml": [
        "Piensa en una caja con dos espacios para una coordenada (7, 8). Esta línea crea una función `first_of_tuple` que toma esos espacios (`a, _`) para devolver el primero. El `_` es como decir 'no me importa el segundo valor', como ignorar la posición y en un mapa.",
        "Devolvemos `a`, el primer número, directamente. Es como mirar el mapa y anotar solo la posición x (7).",
        "Con `in`, preparamos la función para usarla, como abrir el mapa antes de leerlo.",
        "Usamos la función con `(7, 8)`, que da 7, como obtener la posición horizontal del punto."
      ],
      "comparisons": [
        "Ambas funciones sacan el primer número de una tupla, como leer la posición x en un mapa. Racket usa `(define (nombre params) cuerpo)` con paréntesis, como una receta detallada. OCaml usa `let nombre params = cuerpo`, más directo, como una nota rápida.",
        "Racket revisa si la entrada es una tupla con `(pair? t)`, como inspeccionar la caja con cuidado. OCaml no revisa explícitamente, confiando en que la tupla `(a, _)` siempre es válida, como asumir que el mapa está bien dibujado.",
        "Ambas devuelven el primer elemento. Racket usa `(car t)`, como abrir el primer compartimento de la caja. OCaml usa `a`, más simple, como leer directamente la primera parte del mapa.",
        "Racket maneja errores con `(error ...)`, como un aviso grande si el mapa está roto. OCaml no usa validación aquí, confiando en el sistema de tipos, como asumir que el mapa siempre es correcto.",
        "Racket cierra con `)`, como cerrar un libro. OCaml usa `in`, como pasar a la acción final.",
        "Ambas dan 7 con entradas similares. Racket usa `(7 . 8)`, como una caja con un punto. OCaml usa `(7, 8)`, como una coordenada escrita con coma."
      ]
    },
    "ejercicio-3": {
      "title": "Extracción de edad de un registro personalizado",
      "racket": {
        "lines": [
          "(struct person (name age))",
          "(define (get-age p)",
          "  (if (and (person? p) (number? (person-age p)) (> (person-age p) 0))",
          "      (person-age p)",
          "      (error \"Invalid person or age\"))",
          ")",
          "(get-age (person \"Ana\" 20))"
        ]
      },
      "ocaml": {
        "lines": [
          "type person = { name: string; age: int }",
          "let get_age p =",
          "  if p.age > 0 then",
          "    p.age",
          "  else",
          "    failwith \"Age must be positive\"",
          "in",
          "get_age { name = \"Ana\"; age = 20 }"
        ]
      },
      "explanations_racket": [
        "Imagina una ficha de empleado con dos casillas: nombre y edad. Esta línea crea una plantilla llamada `person` para guardar esos datos, como un formulario estándar para empleados.",
        "Creamos una función `get-age` que toma una ficha (`p`) para sacar la edad, como buscar la edad en un archivo de empleados.",
        "Revisamos si la ficha es válida con `(person? p)`, si la edad es un número con `(number? (person-age p))` y si es mayor a 0 con `(> (person-age p) 0)`. Es como verificar que el formulario esté completo y la edad sea lógica.",
        "Si todo está bien, sacamos la edad con `(person-age p)`, como leer la casilla de edad en la ficha (20 para Ana).",
        "Si algo falla, mostramos un error, como cuando la ficha tiene datos incorrectos o falta la edad.",
        "Cerramos la función con un paréntesis, como archivar el formulario.",
        "Usamos la función con una ficha para Ana con edad 20, dando 20, como encontrar su edad en el archivo."
      ],
      "explanations_ocaml": [
        "Piensa en una ficha de empleado con casillas para nombre y edad. Esta línea define una plantilla `person` para guardar esos datos, como un formulario digital.",
        "Creamos una función `get_age` que toma una ficha (`p`) para obtener la edad, como buscar en un archivo digital.",
        "Comprobamos si la edad es mayor a 0 con `p.age > 0`, como asegurarnos de que la edad en la ficha sea válida.",
        "Si es válida, devolvemos la edad con `p.age`, como leer la casilla de edad (20).",
        "Si la edad no es válida, mostramos un error con `failwith`, como un mensaje en el sistema que dice 'edad incorrecta'.",
        "Con `in`, preparamos la función para usarla, como abrir el archivo digital.",
        "Usamos la función con una ficha `{ name = \"Ana\"; age = 20 }`, dando 20, como obtener la edad de Ana."
      ],
      "comparisons": [
        "Ambas crean una plantilla para datos de personas y sacan la edad. Racket usa `(struct person (name age))` con paréntesis, como un formulario físico detallado. OCaml usa `type person = { name: string; age: int }`, como un formulario digital más claro.",
        "Ambas funciones toman una ficha para obtener la edad. Racket usa `(define (nombre params) cuerpo)`, como escribir un procedimiento largo. OCaml usa `let nombre params = cuerpo`, más directo, como una instrucción corta.",
        "Ambas verifican la validez de la edad. Racket usa tres chequeos (`person?`, `number?`, `> 0`), como revisar cada casilla del formulario con cuidado. OCaml solo revisa `p.age > 0`, como una verificación rápida en el sistema.",
        "Ambas devuelven la edad si es válida. Racket usa `(person-age p)`, como buscar en una casilla específica. OCaml usa `p.age`, más simple, como leer directamente del formulario.",
        "Ambas manejan errores. Racket usa `(error ...)`, como un aviso grande en el formulario. OCaml usa `else` y `failwith`, como una alerta más compacta.",
        "Racket cierra con `)`, como guardar el formulario. OCaml usa `in`, como cerrar el archivo digital.",
        "Ambas dan 20 con una ficha para Ana. Racket usa `(person \"Ana\" 20)`, como llenar un formulario físico. OCaml usa `{ name = \"Ana\"; age = 20 }`, como un formulario digital con etiquetas."
      ]
    },
    "ejercicio-4": {
      "title": "Cálculo del volumen de una caja con tupla triple",
      "racket": {
        "lines": [
          "(define (product-triple t)",
          "  (if (and (list? t) (= (length t) 3)",
          "           (andmap number? t) (andmap positive? t))",
          "      (* (car t) (cadr t) (caddr t))",
          "      (error \"Input must be a list of three positive numbers\"))",
          ")",
          "(product-triple '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let product_triple (a, b, c) =",
          "  if a > 0 && b > 0 && c > 0 then",
          "    a * b * c",
          "  else",
          "    failwith \"Dimensions must be positive\"",
          "in",
          "product_triple (2, 3, 4)"
        ]
      },
      "explanations_racket": [
        "Imagina que mides una caja con largo, ancho y alto (2, 3, 4). Esta línea crea una función `product-triple` que toma una lista (`t`) con esas medidas para calcular el volumen, como una calculadora para cajas.",
        "Revisamos si la lista tiene exactamente tres medidas con `(list? t)` y `(= (length t) 3)`, y si todas son números positivos con `(andmap number? t)` y `(andmap positive? t)`. Es como medir la caja y asegurarte de que los valores son correctos.",
        "Si todo está bien, multiplicamos las tres medidas con `(car t)`, `(cadr t)` y `(caddr t)`, como calcular largo × ancho × alto para obtener el volumen (24).",
        "Si algo falla (como medidas negativas o no tres números), mostramos un error, como cuando las medidas de una caja no tienen sentido.",
        "Cerramos la función con un paréntesis, como guardar la calculadora.",
        "Usamos la función con `(2 3 4)`, que da 24, como calcular el espacio dentro de la caja."
      ],
      "explanations_ocaml": [
        "Piensa en una caja con largo, ancho y alto (2, 3, 4). Esta línea crea una función `product_triple` que toma una tupla (`a, b, c`) para calcular el volumen, como una calculadora para cajas.",
        "Comprobamos si todas las medidas son positivas con `a > 0 && b > 0 && c > 0`, como verificar que las medidas de la caja sean válidas para un cálculo real.",
        "Si son válidas, multiplicamos `a * b * c`, como calcular el volumen de la caja (24).",
        "Si alguna medida no es válida, mostramos un error con `failwith`, como un mensaje que dice 'las medidas no sirven'.",
        "Con `in`, preparamos la función para usarla, como encender la calculadora.",
        "Usamos la función con `(2, 3, 4)`, que da 24, como obtener el volumen de la caja."
      ],
      "comparisons": [
        "Ambas calculan el volumen de una caja con tres medidas. Racket usa `(define (nombre params) cuerpo)` y trata las medidas como una lista, como anotar medidas en una hoja. OCaml usa `let nombre params = cuerpo` con una tupla directa, como escribir las medidas en un formulario.",
        "Ambas verifican las medidas. Racket usa `(list? t)` y `(andmap ...)` para checar que son tres números positivos, como medir la caja con una regla precisa. OCaml usa `a > 0 && ...`, más directo, como una revisión rápida de las medidas.",
        "Ambas multiplican las medidas. Racket usa `(* (car t) (cadr t) (caddr t))`, como escribir la multiplicación al revés. OCaml usa `a * b * c`, como una multiplicación normal en la escuela.",
        "Ambas manejan errores. Racket usa `(error ...)`, como un cartel de 'medidas inválidas'. OCaml usa `else` y `failwith`, como una alerta más simple.",
        "Racket cierra con `)`, como guardar la hoja de cálculos. OCaml usa `in`, como terminar el formulario.",
        "Ambas dan 24 con medidas similares. Racket usa `(2 3 4)` como lista, como una lista de medidas. OCaml usa `(2, 3, 4)` como tupla, como un formulario con comas."
      ]
    },
    "ejercicio-5": {
      "title": "Comparación robusta de tuplas",
      "racket": {
        "lines": [
          "(define (equal-tuples? t1 t2)",
          "  (if (and (pair? t1) (pair? t2)",
          "           (number? (car t1)) (number? (cdr t1))",
          "           (number? (car t2)) (number? (cdr t2)))",
          "      (and (= (car t1) (car t2)) (= (cdr t1) (cdr t2)))",
          "      (error \"Inputs must be pairs of numbers\"))",
          ")",
          "(equal-tuples? '(1 . 2) '(1 . 2))"
        ]
      },
      "ocaml": {
        "lines": [
          "let equal_tuples (a1, b1) (a2, b2) =",
          "  if (is_int a1 && is_int b1 && is_int a2 && is_int b2) ||",
          "     (is_float a1 && is_float b1 && is_float a2 && is_float b2) then",
          "    a1 = a2 && b1 = b2",
          "  else",
          "    failwith \"Inputs must be pairs of numbers\"",
          "in",
          "equal_tuples (1, 2) (1, 2)"
        ]
      },
      "explanations_racket": [
        "Imagina que comparas dos etiquetas de productos, cada una con dos números, como precio y peso (1, 2). Esta línea crea una función `equal-tuples?` que toma dos etiquetas (`t1`, `t2`) para ver si son iguales, como comparar dos productos.",
        "Revisamos si ambas etiquetas tienen dos números con `(pair? t1)` y `(pair? t2)`, como verificar que ambas etiquetas tienen precio y peso.",
        "Comprobamos si el primer número (`car t1`) y el segundo (`cdr t1`) de la primera etiqueta son números, como revisar que el precio y peso sean valores numéricos.",
        "Hacemos lo mismo para la segunda etiqueta (`t2`), asegurándonos de que también tenga números válidos.",
        "Si todo está correcto, comparamos los primeros números (`car t1` con `car t2`) y los segundos (`cdr t1` con `cdr t2`) para ver si son iguales. Es como confirmar que el precio y peso de ambos productos coinciden.",
        "Si algo falla, mostramos un error, como cuando las etiquetas tienen datos incorrectos.",
        "Cerramos la función con un paréntesis, como guardar la comparación.",
        "Usamos la función con `(1 . 2)` y `(1 . 2)`, que da `true`, como confirmar que dos productos tienen las mismas características."
      ],
      "explanations_ocaml": [
        "Piensa en comparar dos etiquetas de productos con precio y peso (1, 2). Esta línea crea una función `equal_tuples` que toma dos etiquetas (`a1, b1`) y (`a2, b2`) para ver si son iguales, como comparar dos productos en una tienda.",
        "Revisamos si todos los valores son números enteros (`is_int`) o decimales (`is_float`), como verificar que las etiquetas tengan precio y peso numéricos.",
        "Continuamos la revisión permitiendo decimales con `||`, como aceptar que los precios puedan ser con centavos.",
        "Si son números válidos, comparamos `a1 = a2` y `b1 = b2`, como confirmar que el precio y peso de ambos productos son idénticos.",
        "Si algo no es un número, mostramos un error con `failwith`, como un mensaje que dice 'etiqueta inválida'.",
        "Con `in`, preparamos la función para usarla, como abrir las etiquetas para compararlas.",
        "Usamos la función con `(1, 2)` y `(1, 2)`, que da `true`, como confirmar que los productos son iguales."
      ],
      "comparisons": [
        "Ambas comparan dos etiquetas con números, como productos en una tienda. Racket usa `(define (nombre params) cuerpo)` con paréntesis, como un checklist detallado. OCaml usa `let nombre params = cuerpo`, como una comparación directa en una hoja.",
        "Ambas verifican si las entradas son válidas. Racket usa `(pair? ...)` y `(number? ...)` en varias líneas, como revisar cada parte de la etiqueta con lupa. OCaml usa `(is_int ...)` o `(is_float ...)` en una línea, como una revisión rápida.",
        "Racket sigue revisando los primeros elementos, como checar el precio de cada producto por separado. OCaml combina la validación en una sola condición, más compacta.",
        "Racket revisa los segundos elementos, completando la validación. OCaml ya incluyó todo en la línea anterior, como una revisión más eficiente.",
        "Ambas comparan los números. Racket usa `(= (car t1) (car t2))`, como comparar precios al revés. OCaml usa `a1 = a2 && b1 = b2`, como una comparación normal.",
        "Ambas manejan errores. Racket usa `(error ...)`, como un aviso grande. OCaml usa `else` y `failwith`, como una alerta más breve.",
        "Racket cierra con `)`, como cerrar el checklist. OCaml usa `in`, como terminar la comparación.",
        "Ambas dan `true` con entradas iguales. Racket usa `(1 . 2)`, como una etiqueta con un punto. OCaml usa `(1, 2)`, como una etiqueta con coma."
      ]
    },
    "ejercicio-6": {
      "title": "Extracción avanzada de nombre de un registro",
      "racket": {
        "lines": [
          "(struct person (name age city))",
          "(define (get-name p)",
          "  (if (and (person? p) (string? (person-name p)) (not (string=? (person-name p) \"\")))",
          "      (person-name p)",
          "      (error \"Invalid person or empty name\"))",
          ")",
          "(get-name (person \"Bob\" 25 \"Paris\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "type person = { name: string; age: int; city: string }",
          "let get_name p =",
          "  if p.name <> \"\" then",
          "    p.name",
          "  else",
          "    failwith \"Name must not be empty\"",
          "in",
          "get_name { name = \"Bob\"; age = 25; city = \"Paris\" }"
        ]
      },
      "explanations_racket": [
        "Imagina una tarjeta de identificación con tres casillas: nombre, edad y ciudad. Esta línea crea una plantilla `person` para guardar esos datos, como un formulario para un censo.",
        "Creamos una función `get-name` que toma una tarjeta (`p`) para sacar el nombre, como buscar el nombre en una base de datos de censo.",
        "Revisamos si la tarjeta es válida con `(person? p)`, si el nombre es una palabra con `(string? (person-name p))` y si no está vacío con `(not (string=? (person-name p) \"\"))`. Es como verificar que la tarjeta tiene un nombre real.",
        "Si todo está correcto, devolvemos el nombre con `(person-name p)`, como leer 'Bob' de la tarjeta.",
        "Si algo falla, mostramos un error, como cuando la tarjeta está en blanco o no es válida.",
        "Cerramos la función con un paréntesis, como archivar la tarjeta.",
        "Usamos la función con una tarjeta para Bob, edad 25, de París, dando 'Bob', como encontrar su nombre en el censo."
      ],
      "explanations_ocaml": [
        "Piensa en una tarjeta digital con nombre, edad y ciudad. Esta línea define una plantilla `person` para esos datos, como un formulario en una computadora.",
        "Creamos una función `get_name` que toma una tarjeta (`p`) para obtener el nombre, como buscar en una base de datos digital.",
        "Comprobamos si el nombre no está vacío con `p.name <> \"\"`, como asegurarnos de que la casilla del nombre tiene algo escrito.",
        "Si es válido, devolvemos `p.name`, como leer 'Bob' del formulario.",
        "Si el nombre está vacío, mostramos un error con `failwith`, como un mensaje que dice 'falta el nombre'.",
        "Con `in`, preparamos la función para usarla, como abrir la base de datos.",
        "Usamos la función con una tarjeta `{ name = \"Bob\"; age = 25; city = \"Paris\" }`, dando 'Bob', como obtener el nombre del censo."
      ],
      "comparisons": [
        "Ambas crean una plantilla para datos de personas y sacan el nombre. Racket usa `(struct person (name age city))` con paréntesis, como un formulario en papel. OCaml usa `type person = { name: string; age: int; city: string }`, como un formulario digital con etiquetas claras.",
        "Ambas funciones toman una tarjeta para obtener el nombre. Racket usa `(define (nombre params) cuerpo)`, como un procedimiento largo. OCaml usa `let nombre params = cuerpo`, como una instrucción breve.",
        "Ambas verifican el nombre. Racket usa tres chequeos (`person?`, `string?`, `not (string=?)`), como revisar cada parte de la tarjeta con cuidado. OCaml solo revisa `p.name <> \"\"`, como una verificación rápida en la computadora.",
        "Ambas devuelven el nombre si es válido. Racket usa `(person-name p)`, como buscar en una casilla específica. OCaml usa `p.name`, como leer directamente del formulario.",
        "Ambas manejan errores. Racket usa `(error ...)`, como un aviso grande en la tarjeta. OCaml usa `else` y `failwith`, como una alerta digital más simple.",
        "Racket cierra con `)`, como guardar el formulario. OCaml usa `in`, como cerrar la base de datos.",
        "Ambas dan 'Bob' con una tarjeta similar. Racket usa `(person \"Bob\" 25 \"Paris\")`, como llenar un formulario físico. OCaml usa `{ name = \"Bob\"; age = 25; city = \"Paris\" }`, como un formulario digital con nombres de casillas."
      ]
    },
    "ejercicio-7": {
      "title": "Construcción y procesamiento de registros anidados",
      "racket": {
        "lines": [
          "(struct student (name age grades))",
          "(define (student-info name age grades)",
          "  (if (and (string? name) (not (string=? name \"\"))",
          "           (number? age) (> age 0)",
          "           (list? grades) (not (empty? grades)) (andmap positive? grades))",
          "      (let ((s (student name age grades)))",
          "        (cons (student-name s)",
          "              (/ (foldl + 0 grades) (length grades))))",
          "      (error \"Invalid input: name, age, or grades\"))",
          ")",
          "(student-info \"Carlos\" 22 '(90 85))"
        ]
      },
      "ocaml": {
        "lines": [
          "type student = { name: string; age: int; grades: int list }",
          "let student_info name age grades =",
          "  if name <> \"\" && age > 0 && grades <> [] &&",
          "     List.for_all (fun x -> x > 0) grades then",
          "    let s = { name; age; grades } in",
          "    (s.name, (List.fold_left (+) 0 grades) / (List.length grades))",
          "  else",
          "    failwith \"Invalid input: name, age, or grades\"",
          "in",
          "student_info \"Carlos\" 22 [90; 85]"
        ]
      },
      "explanations_racket": [
        "Imagina un expediente escolar con casillas para nombre, edad y una lista de notas. Esta línea crea una plantilla `student` para esos datos, como un formulario para estudiantes.",
        "Creamos una función `student-info` que toma nombre, edad y notas para hacer un expediente y devolver el nombre con el promedio de notas, como un resumen escolar.",
        "Revisamos si el nombre es una palabra no vacía con `(string? name)` y `(not (string=? name \"\"))`, como verificar que el expediente tenga un nombre real.",
        "Comprobamos si la edad es un número positivo con `(number? age)` y `(> age 0)`, como asegurarnos de que la edad sea válida para un estudiante.",
        "Verificamos si las notas son una lista no vacía con `(list? grades)` y `(not (empty? grades))`, y si todas son positivas con `(andmap positive? grades)`. Es como revisar que el estudiante tenga notas válidas.",
        "Si todo está correcto, creamos un expediente con `(student name age grades)` y lo guardamos en `s`, como llenar el formulario escolar.",
        "Devolvemos una caja con el nombre (`student-name s`) y el promedio, calculado sumando las notas con `(foldl + 0 grades)` y dividiendo por la cantidad con `(length grades)`. Es como escribir el nombre y el promedio en un reporte.",
        "Si algo falla, mostramos un error, como cuando el expediente tiene datos incorrectos.",
        "Cerramos la función con un paréntesis, como archivar el expediente.",
        "Usamos la función con 'Carlos', 22 y notas (90, 85), dando `(Carlos 87)`, como un reporte con el nombre y el promedio."
      ],
      "explanations_ocaml": [
        "Piensa en un expediente digital con nombre, edad y una lista de notas. Esta línea define una plantilla `student` para esos datos, como un formulario en una computadora.",
        "Creamos una función `student_info` que toma nombre, edad y notas para hacer un expediente y devolver el nombre con el promedio, como un resumen escolar digital.",
        "Revisamos si el nombre no está vacío con `name <> \"\"`, si la edad es positiva con `age > 0`, y si las notas no están vacías con `grades <> []`.",
        "Comprobamos si todas las notas son positivas con `List.for_all (fun x -> x > 0) grades`, como verificar que todas las notas sean válidas.",
        "Si todo es válido, creamos un expediente con `{ name; age; grades }` y lo guardamos en `s`, como llenar un formulario digital.",
        "Devolvemos una tupla con el nombre `s.name` y el promedio, calculado sumando con `List.fold_left (+) 0 grades` y dividiendo por `List.length grades`. Es como generar un reporte digital.",
        "Si algo falla, mostramos un error con `failwith`, como un mensaje que dice 'datos incorrectos'.",
        "Con `in`, preparamos la función para usarla, como abrir el expediente digital.",
        "Usamos la función con 'Carlos', 22 y `[90; 85]`, dando `(Carlos, 87)`, como un reporte con el nombre y promedio."
      ],
      "comparisons": [
        "Ambas crean un expediente para estudiantes y devuelven nombre y promedio. Racket usa `(struct student (name age grades))` con paréntesis, como un formulario en papel. OCaml usa `type student = { name: string; age: int; grades: int list }`, como un formulario digital claro.",
        "Ambas funciones toman nombre, edad y notas. Racket usa `(define (nombre params) cuerpo)`, como un procedimiento largo. OCaml usa `let nombre params = cuerpo`, como una instrucción más corta.",
        "Ambas verifican el nombre. Racket usa `(string? name)` y `(not (string=? ...))`, como revisar cada casilla del formulario. OCaml usa `name <> \"\"`, como una verificación rápida.",
        "Ambas revisan la edad. Racket usa `(number? age)` y `(> age 0)`, como checar la edad con cuidado. OCaml usa `age > 0`, más directo.",
        "Ambas verifican las notas. Racket usa `(list? grades)` y `(andmap positive? grades)`, como revisar cada nota con lupa. OCaml usa `grades <> []` y `List.for_all`, como una revisión eficiente.",
        "Ambas crean un expediente. Racket usa `(let ((s ...)))`, como llenar un formulario físico. OCaml usa `let s = ... in`, como un formulario digital.",
        "Ambas devuelven nombre y promedio. Racket usa `(cons (student-name s) ...)` y `(foldl + 0 ...)`, como armar un reporte con pasos detallados. OCaml usa `(s.name, ...)` con `List.fold_left`, más directo.",
        "Ambas manejan errores. Racket usa `(error ...)`, como un aviso grande. OCaml usa `else` y `failwith`, como una alerta más simple.",
        "Racket cierra con `)`, como guardar el formulario. OCaml usa `in`, como cerrar el expediente digital.",
        "Ambas dan `(Carlos 87)` con datos similares. Racket usa `'()` para listas y `(cons ...)` para tuplas, como un reporte en papel. OCaml usa `[]` y `(,)`, como un reporte digital."
      ]
    }
  },
  "cadenas-y-caracteres": {
    "ejercicio-1": {
      "title": "Longitud de una cadena",
      "racket": {
        "lines": [
          "(define (string-length str)",
          "  (string-length str)",
          ")",
          "(string-length \"admin\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let string_length str =",
          "  String.length str",
          "in",
          "string_length \"admin\""
        ]
      },
      "explanations_racket": [
        "Define una función `string-length` que toma un parámetro `str` para calcular la longitud de una cadena. La sintaxis `(define (nombre params) cuerpo)` es estándar en Racket, promoviendo abstracción funcional, como crear una herramienta reusable para contar caracteres, similar a medir la longitud de una cinta.",
        "Usa `string-length` (función primitiva de Racket) para retornar la longitud de `str`. La expresión es pura, siempre da el mismo resultado para la misma cadena, alineándose con el paradigma funcional, como contar las letras en un nombre sin cambiarlo.",
        "Cierra la definición de la función con un paréntesis, una convención estructural de Racket necesaria para completar la sintaxis.",
        "Llama a `string-length` con \"admin\", evaluando la longitud como 5, mostrando cómo usar la función para validar un usuario, como comprobar si un nombre de usuario tiene la longitud correcta."
      ],
      "explanations_ocaml": [
        "Define una función `string_length` con un parámetro `str` para calcular la longitud, usando `let nombre params = cuerpo`. En OCaml, las funciones son puras e inmutables, ideales para abstracción, como una herramienta para medir el tamaño de un texto, similar a contar palabras en una frase.",
        "Usa `String.length` (función del módulo `String`) para retornar la longitud de `str`. La expresión es pura, garantizando consistencia, como medir un mensaje sin alterarlo.",
        "Usa `in` para introducir el contexto de la llamada, una característica estructural de OCaml que separa la definición de su uso, sin lógica propia.",
        "Llama a `string_length` con \"admin\", dando 5, demostrando la función en un contexto práctico, como validar la longitud de una contraseña."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular la longitud de una cadena, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere que `str` es cadena, Racket es dinámico.",
        "Similitudes: Ambas usan una función primitiva para calcular longitud, manteniendo pureza. Diferencias: Racket usa `string-length` prefija, OCaml usa `String.length` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"admin\", dando 5. Diferencias: Racket usa `(string-length \"admin\")`, OCaml usa `string_length \"admin\"`, más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Concatenar cadenas",
      "racket": {
        "lines": [
          "(define (concat-strings s1 s2)",
          "  (string-append s1 \" \" s2)",
          ")",
          "(concat-strings \"hola\" \"mundo\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let concat_strings s1 s2 =",
          "  s1 ^ \" \" ^ s2",
          "in",
          "concat_strings \"hola\" \"mundo\""
        ]
      },
      "explanations_racket": [
        "Define una función `concat-strings` que toma dos parámetros, `s1` y `s2`, para unir cadenas. La sintaxis `(define (nombre params) cuerpo)` es funcional, como crear un mensaje combinando palabras.",
        "Usa `string-append` para unir `s1`, un espacio, y `s2`, en notación prefija. La expresión es pura, como formar \"hola mundo\" sin alterar las palabras originales.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `concat-strings` con \"hola\" y \"mundo\", dando \"hola mundo\", mostrando cómo generar un saludo completo."
      ],
      "explanations_ocaml": [
        "Define una función `concat_strings` con dos parámetros para unir cadenas, usando `let nombre params = cuerpo`. Es funcional, como combinar textos en un documento.",
        "Usa el operador `^` para unir `s1`, un espacio, y `s2`, en notación infija. La expresión es pura, como formar un mensaje sin cambiar las partes.",
        "Usa `in` para introducir la llamada, una característica de OCaml.",
        "Llama a `concat_strings` con \"hola\" y \"mundo\", dando \"hola mundo\", demostrando la unión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para unir cadenas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas unen cadenas con un espacio, manteniendo pureza. Diferencias: Racket usa `string-append` prefija, OCaml usa `^` infijo, más conciso.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"hola\" y \"mundo\", dando \"hola mundo\". Diferencias: Racket usa `(concat-strings \"hola\" \"mundo\")`, OCaml usa `concat_strings \"hola\" \"mundo\"`."
      ]
    },
    "ejercicio-3": {
      "title": "Obtener primer carácter de cadena",
      "racket": {
        "lines": [
          "(define (first-char str)",
          "  (string-ref str 0)",
          ")",
          "(first-char \"gato\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_char str =",
          "  if str = \"\" then",
          "    None",
          "  else",
          "    Some (String.get str 0)",
          "in",
          "first_char \"gato\""
        ]
      },
      "explanations_racket": [
        "Define una función `first-char` para obtener el primer carácter de una cadena `str`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como extraer la inicial de una palabra para un monograma.",
        "Usa `string-ref` para acceder al carácter en posición 0 de `str`, en notación prefija. La expresión es pura, como leer la primera letra sin cambiar la palabra.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `first-char` con \"gato\", retornando #\\g, mostrando la extracción."
      ],
      "explanations_ocaml": [
        "Define una función `first_char` para obtener el primer carácter, usando `let nombre params = cuerpo`. Es funcional, como seleccionar la inicial de un nombre.",
        "Inicia un condicional `if` con `str = \"\"`, verificando si la cadena está vacía, una expresión pura para el caso base.",
        "Si la cadena está vacía, retorna `None`, usando el tipo `option` para indicar ausencia, como no hay inicial si no hay nombre.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar cadenas no vacías.",
        "Retorna `Some (String.get str 0)`, envolviendo el primer carácter en `Some`, como confirmar que hay una inicial disponible.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `first_char` con \"gato\", dando `Some 'g'`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para obtener el primer carácter, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml maneja vacía con `option`.",
        "Similitudes: Ambas acceden al primer carácter con pureza. Diferencias: Racket usa `string-ref` prefija, OCaml usa `String.get` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket no maneja vacío, OCaml usa `if` para vacía, aumentando líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"gato\", dando 'g'. Diferencias: Racket retorna #\\g, OCaml Some 'g'."
      ]
    },
    "ejercicio-4": {
      "title": "Convertir cadena a mayúsculas",
      "racket": {
        "lines": [
          "(define (to-upper str)",
          "  (string-upcase str)",
          ")",
          "(to-upper \"welcome\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let to_upper str =",
          "  String.uppercase_ascii str",
          "in",
          "to_upper \"welcome\""
        ]
      },
      "explanations_racket": [
        "Define una función `to-upper` para convertir una cadena a mayúsculas. La sintaxis `(define (nombre params) cuerpo)` es funcional, como transformar un cartel a letras grandes.",
        "Usa `string-upcase` para retornar la cadena en mayúsculas, en notación prefija. La expresión es pura, como gritar un mensaje sin cambiar el original.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `to-upper` con \"welcome\", retornando \"WELCOME\", mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `to_upper` para convertir a mayúsculas, usando `let nombre params = cuerpo`. Es funcional, como hacer un letrero en letras grandes.",
        "Usa `String.uppercase_ascii` para retornar la cadena en mayúsculas, en notación infija. La expresión es pura, específica para ASCII.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `to_upper` con \"welcome\", retornando \"WELCOME\", demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para convertir cadenas a mayúsculas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función primitiva para mayúsculas, manteniendo pureza. Diferencias: Racket usa `string-upcase` prefija, OCaml usa `String.uppercase_ascii` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"welcome\", dando \"WELCOME\". Diferencias: Racket usa `(to-upper \"welcome\")`, OCaml usa `to_upper \"welcome\"`."
      ]
    },
    "ejercicio-5": {
      "title": "Verificar si una cadena está vacía",
      "racket": {
        "lines": [
          "(define (empty-string? str)",
          "  (string=? str \"\")",
          ")",
          "(empty-string? \"\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let empty_string str =",
          "  str = \"\"",
          "in",
          "empty_string \"\""
        ]
      },
      "explanations_racket": [
        "Define una función `empty-string?` para verificar si una cadena `str` está vacía. La sintaxis `(define (nombre params) cuerpo)` es funcional, como comprobar si un formulario tiene texto.",
        "Usa `string=?` para comparar `str` con \"\", retornando #t si es vacía. La expresión es pura, como validar un campo vacío.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `empty-string?` con \"\", dando #t, mostrando la verificación."
      ],
      "explanations_ocaml": [
        "Define una función `empty_string` para verificar si una cadena está vacía, usando `let nombre params = cuerpo`. Es funcional, como validar un campo en un formulario.",
        "Compara `str` con \"\" usando `=`, retornando `true` si es vacía. La expresión es pura, como confirmar un texto vacío.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `empty_string` con \"\", dando `true`, demostrando la verificación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si una cadena está vacía, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas comparan con cadena vacía, con pureza. Diferencias: Racket usa `string=?` prefija, OCaml usa `=` infija, más concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"\", dando verdadero. Diferencias: Racket usa `(empty-string? \"\")`, OCaml usa `empty_string \"\"`."
      ]
    },
    "ejercicio-6": {
      "title": "Extraer subcadena",
      "racket": {
        "lines": [
          "(define (substring-from str start len)",
          "  (substring str start (+ start len))",
          ")",
          "(substring-from \"python\" 1 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let substring_from str start len =",
          "  String.sub str start len",
          "in",
          "substring_from \"python\" 1 3"
        ]
      },
      "explanations_racket": [
        "Define una función `substring-from` para extraer una subcadena desde `start` con longitud `len`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como cortar un trozo de una cuerda.",
        "Usa `substring` para retornar el segmento de `str` desde `start` hasta `start + len`. La expresión es pura, como extraer 'yth' de \"python\" sin alterar la cadena original.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `substring-from` con \"python\", 1, 3, dando \"yth\", mostrando la extracción."
      ],
      "explanations_ocaml": [
        "Define una función `substring_from` para extraer una subcadena, usando `let nombre params = cuerpo`. Es funcional, como recortar un fragmento de un texto.",
        "Usa `String.sub` para retornar el segmento de `str` desde `start` con `len`. La expresión es pura, como obtener 'yth' de \"python\" sin cambiar la cadena.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `substring_from` con \"python\", 1, 3, dando \"yth\", demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para extraer una subcadena, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función primitiva para subcadena, con pureza. Diferencias: Racket usa `substring` prefija con `(+ start len)`, OCaml usa `String.sub` infija, más modular y concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"python\", 1, 3, dando \"yth\". Diferencias: Racket usa `(substring-from \"python\" 1 3)`, OCaml usa `substring_from \"python\" 1 3`."
      ]
    },
    "ejercicio-7": {
      "title": "Contar vocales en una cadena",
      "racket": {
        "lines": [
          "(define (count-vowels str)",
          "  (length",
          "    (filter (lambda (c)",
          "              (member c '(#\\a #\\e #\\i #\\o #\\u)))",
          "            (string->list str)))",
          ")",
          "(count-vowels \"hello\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let count_vowels str =",
          "  String.fold_left",
          "    (fun acc c ->",
          "       if List.mem c ['a'; 'e'; 'i'; 'o'; 'u'] then",
          "         acc + 1",
          "       else",
          "         acc",
          "    ) 0 str",
          "in",
          "count_vowels \"hello\""
        ]
      },
      "explanations_racket": [
        "Define una función `count-vowels` para contar vocales en una cadena `str`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un juego que cuenta vocales para puntuar palabras.",
        "Usa `length` para contar elementos en la lista filtrada, una expresión pura para obtener el total de vocales.",
        "Usa `filter` con `lambda` para seleccionar caracteres vocales. `lambda` es una función anónima, como un juez que decide si una letra es vocal.",
        "Verifica si `c` está en la lista de vocales con `member`, en notación prefija. Es pura, como identificar vocales en \"hello\".",
        "Convierte `str` a lista de caracteres con `string->list`, preparando la cadena para filtrado, como descomponer una palabra en letras.",
        "Cierra los bloques de `filter` y `length`, necesario para la sintaxis de Racket.",
        "Llama a `count-vowels` con \"hello\", contando 2 vocales (e, o), mostrando el procesamiento."
      ],
      "explanations_ocaml": [
        "Define una función `count_vowels` para contar vocales en una cadena, usando `let nombre params = cuerpo`. Es funcional, como un juego que puntúa palabras por vocales.",
        "Usa `String.fold_left` para acumular un conteo, reduciendo la cadena a un número. `fold_left` es una función de alto orden pura, como un contador que suma por cada vocal.",
        "Usa `fun` para definir una función anónima que toma acumulador `acc` y carácter `c`. `fun` es como una regla para cada letra.",
        "Inicia un condicional `if` para verificar si `c` es vocal usando `List.mem`, en notación infija, una expresión pura.",
        "Si `c` es vocal, suma 1 a `acc`, incrementando el conteo, como puntuar una letra vocal.",
        "Introduce `else` para caracteres no vocales, retornando `acc` sin cambio, necesaria en OCaml.",
        "Retorna `acc` si no es vocal, completando la función anónima.",
        "Inicializa el acumulador en 0 y aplica a `str`, reduciendo la cadena.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `count_vowels` con \"hello\", contando 2 vocales (e, o), demostrando el procesamiento."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para contar vocales, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa `String.fold_left`, Racket usa `filter` + `length`.",
        "Similitudes: Ambas usan alto orden para procesar la cadena, con pureza. Diferencias: Racket usa `length` para contar filtrados, OCaml usa `fold_left` para acumular, más eficiente para conteo.",
        "Similitudes: Ambas usan función anónima para verificar vocales. Diferencias: Racket usa `lambda` prefija, OCaml usa `fun` infija con ->.",
        "Similitudes: Ambas verifican si el carácter es vocal. Diferencias: Racket usa `member` prefija, OCaml usa `List.mem` infija, más modular.",
        "Similitudes: Ambas usan listas de vocales. Diferencias: Racket usa caracteres `#\\a`, OCaml usa `'a'`, con `List.mem`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra bloques, OCaml cierra `else`.",
        "Similitudes: Ambas convierten cadena a procesable. Diferencias: Racket usa `string->list` prefija, OCaml usa `fold_left` directo sobre cadena.",
        "Similitudes: Ambas llaman la función con \"hello\", dando 2. Diferencias: Racket usa `(count-vowels \"hello\")`, OCaml usa `count_vowels \"hello\"`."
      ]
    }
  },
  "composicion-de-funciones": {
    "ejercicio-1": {
      "title": "Componer conversión a minúsculas y añadir prefijo",
      "racket": {
        "lines": [
          "(define (a-minusculas s)",
          "  (string-downcase s))",
          "",
          "(define (añadir-prefijo s)",
          "  (string-append \"elixir-\" s))",
          "",
          "(define (compuesta-uno s)",
          "  (añadir-prefijo (a-minusculas s)))",
          "",
          "(compuesta-uno \"Magia\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let a_minusculas s =",
          "  String.lowercase_ascii s",
          ";;",
          "",
          "let añadir_prefijo s =",
          "  \"elixir-\" ^ s",
          ";;",
          "",
          "let compuesta_uno s =",
          "  añadir_prefijo (a_minusculas s)",
          ";;",
          "",
          "compuesta_uno \"Magia\""
        ]
      },
      "explanations_racket": [
        "Imagina que estás empezando a aprender a cocinar y cada línea de código es un paso en una receta. Esta primera línea '(define (a-minusculas s)' es como el título de la receta. La palabra 'define' le dice a la computadora 'estoy creando una nueva instrucción o receta llamada a-minusculas'. Los paréntesis agrupan todo, como un sobre que contiene el nombre de la receta y lo que necesita. 'a-minusculas' es el nombre que le das a esta receta, y 's' es el ingrediente principal que necesita, que es una cadena de texto – piensa en 's' como una palabra o frase, como \"Magia\", que es una secuencia de letras. Esta receta va a hacer algo con 's', específicamente convertir todas las letras a minúsculas, como si estuvieras ajustando el tamaño de las letras para que sean pequeñas y uniformes, útil porque en programación a veces quieres ignorar si algo está en mayúsculas o minúsculas para tratar todo igual.",
        "Ahora viene el corazón de la receta: '(string-downcase s))'. 'string-downcase' es una herramienta o función prehecha que Racket tiene, como un electrodoméstico en tu cocina que toma una cadena (string) y la convierte a minúsculas (downcase). Le pasas 's' como ingrediente, y produce una nueva cadena con todo en minúsculas. Por ejemplo, si 's' es \"Magia\", se convierte en \"magia\". Los paréntesis cierran la instrucción, y el doble paréntesis al final cierra la definición completa de la receta. Esto es importante porque en Racket todo se anida con paréntesis, como capas de una cebolla, para que la computadora sepa dónde empieza y termina cada parte. Sin esto, la receta no estaría completa y la computadora se confundiría.",
        "Esta es una línea en blanco, que no hace nada en el código, pero es super útil para los humanos que leen el código. Es como dejar un espacio entre párrafos en un libro o entre recetas en un cuaderno, para que no se vea todo apretado y sea más fácil encontrar dónde empieza la siguiente receta. En programación, esto se llama 'legibilidad', y ayuda a que tú o alguien más entienda el código más rápido sin perderse.",
        "Aquí empezamos una nueva receta con '(define (añadir-prefijo s)'. De nuevo 'define' crea la receta, 'añadir-prefijo' es el nombre, y 's' es el ingrediente (cadena). Esta receta va a agregar algo al principio de 's', como poner una etiqueta o un prefijo. Piensa en ello como decorar un pastel añadiendo algo en la parte superior. Es útil para modificar cadenas de manera sistemática, como en nuestro ejemplo de alquimia donde agregamos 'elixir-' para 'activar' la poción.",
        "'(string-append \"elixir-\" s))' es el cuerpo. 'string-append' es otra herramienta mágica que une cadenas, como pegar dos papeles. Toma \"elixir-\" (una cadena fija, con comillas para indicar que es texto literal) y lo une con 's'. Por ejemplo, si 's' es \"magia\", resulta \"elixir-magia\". Los paréntesis agrupan los ingredientes, y el doble cierre finaliza la receta. Esto asegura que la computadora sepa exactamente qué unir y en qué orden, evitando errores.",
        "Otra línea en blanco para separar esta receta de la siguiente, manteniendo el código ordenado como un libro bien editado, lo que facilita la revisión o modificación más tarde.",
        "Ahora '(define (compuesta-uno s)' crea la receta principal que combina las anteriores. 'compuesta-uno' significa que es una función que compone o une otras funciones, como un chef que mezcla recetas simples para crear un plato complejo. 's' es el ingrediente inicial.",
        "'(añadir-prefijo (a-minusculas s)))' es donde sucede la composición. Primero ejecuta 'a-minusculas s' para convertir a minúsculas, luego pasa ese resultado directamente a 'añadir-prefijo'. Es como un flujo: tomas 's', lo procesas en el primer paso, y el output va al segundo. Los paréntesis anidados muestran el orden, como pasos secuenciales en una cadena. Esto es el corazón de la composición de funciones, donde creas procesos más poderosos uniendo piezas simples.",
        "Línea en blanco para separar la definición de la llamada final, ayudando a distinguir la creación de la receta de su uso.",
        "Finalmente, '(compuesta-uno \"Magia\")' es como cocinar la receta: llamas a 'compuesta-uno' con el ingrediente \"Magia\". La computadora ejecuta el flujo – minúsculas a \"magia\", prefijo a \"elixir-magia\" – y muestra el resultado. Esto es para probar y ver si todo funciona, como probar un bocado de tu plato para asegurarte de que sabe bien."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let a_minusculas s =' es como declarar 'deja que a_minusculas sea una receta que toma s'. 'let' es el comando para definir, similar a asignar un valor, pero para funciones. 's' es la cadena de texto, como una secuencia de letras. Esto es el comienzo de la receta para convertir a minúsculas, útil para estandarizar texto y evitar diferencias entre mayúsculas y minúsculas.",
        "'String.lowercase_ascii s' es el cuerpo. 'String' es una biblioteca de herramientas para cadenas, 'lowercase_ascii' es la herramienta específica que toma 's' y la convierte a minúsculas para caracteres ASCII (letras básicas del inglés). Piensa en ello como un sello que estampa las letras en pequeño. No hay paréntesis extra porque OCaml es más lineal.",
        "';;' es un separador que cierra la definición, como un punto final que dice 'esta receta termina aquí'. Es necesario para que la computadora sepa que pasas a la siguiente parte, evitando que mezcle recetas.",
        "Línea en blanco para organizar, como un salto de línea en un texto para respirar.",
        " 'let añadir_prefijo s =' define la siguiente receta para agregar prefijo a 's'.",
        "'\"elixir-\" ^ s' une \"elixir-\" con 's' usando '^', que es como un pegamento para cadenas. Resulta una nueva cadena, como combinar palabras en una frase.",
        "';;' cierra esta definición.",
        "Línea en blanco.",
        " 'let compuesta_uno s =' define la receta compuesta.",
        " 'añadir_prefijo (a_minusculas s)' encadena las recetas: primero minúsculas, luego prefijo.",
        "';;' cierra.",
        "Línea en blanco.",
        " 'compuesta_uno \"Magia\"' ejecuta la receta con \"Magia\", produciendo \"elixir-magia\"."
      ],
      "comparisons": [
        "Similitudes: Ambas definen funciones para minúsculas usando un comando de creación (define/let), haciendo código reutilizable. Diferencias: Racket envuelve en paréntesis para estructura, como un marco, mientras OCaml usa '=' para asignación, más como una ecuación matemática simple. Racket es prefijo (nombre primero), OCaml infijo, haciendo Racket más anidado pero claro en jerarquía, OCaml más directo pero menos visual en anidamiento.",
        "Similitudes: Ambas transforman la cadena a minúsculas. Diferencias: Racket 'string-downcase s' es prefija, envolviendo en paréntesis, como llamar a una función con argumentos; OCaml 'String.lowercase_ascii s' usa módulo 'String.' para acceder, como abrir una caja de herramientas, sin paréntesis extra, más conciso pero requiere recordar el módulo.",
        "Similitudes: Separadores ayudan a legibilidad. Diferencias: Racket usa blank pura, OCaml ';;' como cierre explícito, haciendo OCaml más marcado en finales, útil para evitar errores en secuencias largas.",
        "Similitudes: Definiciones para prefijo. Diferencias: Racket 'define' con paréntesis, OCaml 'let' con '=', Racket más estructurado, OCaml más fluido.",
        "Similitudes: Unen cadenas. Diferencias: Racket 'string-append' prefija, OCaml '^' infijo, como + en matemáticas, OCaml más intuitivo para operaciones simples, Racket más explícito para claridad.",
        "Similitudes: Blanks organizan. Diferencias: Igual, pero en OCaml después de ';;', combinando cierre y separación.",
        "Similitudes: Definiciones compuestas. Diferencias: Racket 'define' anidado, OCaml 'let' lineal.",
        "Similitudes: Encadenan funciones. Diferencias: Racket paréntesis muestran flujo, OCaml ( ) agrupan, Racket más visual en anidamiento, OCaml más compacto.",
        "Similitudes: Blanks. Diferencias: Ninguna.",
        "Similitudes: Llamadas para probar. Diferencias: Racket paréntesis, OCaml directo, Racket más consistente con sintaxis, OCaml más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Componer reversión de cadena y filtrado de consonantes",
      "racket": {
        "lines": [
          "(define (revertir s)",
          "  (list->string (reverse (string->list s))))",
          "",
          "(define (filtrar-consonantes s)",
          "  (list->string",
          "   (filter (lambda (c)",
          "             (not (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))))",
          "           (string->list s))))",
          "",
          "(define (compuesta-dos s)",
          "  (filtrar-consonantes (revertir s)))",
          "",
          "(compuesta-dos \"anigam\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let revertir s =",
          "  let len = String.length s in",
          "  String.init len (fun i -> s.[len - 1 - i])",
          ";;",
          "",
          "let filtrar_consonantes s =",
          "  let buf = Buffer.create (String.length s) in",
          "  String.iter (fun c ->",
          "    if not (List.mem (Char.lowercase_ascii c) ['a'; 'e'; 'i'; 'o'; 'u']) then",
          "      Buffer.add_char buf c",
          "  ) s;",
          "  Buffer.contents buf",
          ";;",
          "",
          "let compuesta_dos s =",
          "  filtrar_consonantes (revertir s)",
          ";;",
          "",
          "compuesta_dos \"anigam\""
        ]
      },
      "explanations_racket": [
        "Piensa en el código como una receta para cocinar un plato. La línea '(define (revertir s)' es como el título de la receta, donde 'define' le dice a la computadora que estás creando una nueva instrucción llamada 'revertir'. Los paréntesis agrupan el nombre de la función y su ingrediente, 's', que es una cadena de texto, como una palabra o frase (por ejemplo, \"anigam\"). Esta receta va a tomar esa palabra y darle la vuelta, como si escribieras una palabra al revés en un espejo. En programación, invertir una cadena es útil para cosas como procesar datos al revés o crear efectos de texto.",
        "El cuerpo de la receta es '(list->string (reverse (string->list s))))'. Esto parece complicado, pero es como seguir pasos para armar un rompecabezas. Primero, 'string->list s' toma la cadena 's' y la descompone en una lista de letras individuales, como separar las cuentas de un collar. Por ejemplo, \"anigam\" se convierte en una lista '(#\\a #\\n #\\i #\\g #\\a #\\m)'. Luego, 'reverse' toma esa lista y la invierte, como girar una pila de cartas, dando '(#\\m #\\a #\\g #\\i #\\n #\\a)'. Finalmente, 'list->string' junta las letras de nuevo en una cadena, resultando en \"magina\". Los paréntesis anidan cada paso, como capas de una caja, para que la computadora sepa el orden exacto. Esto asegura que la inversión sea clara y precisa, como seguir una coreografía paso a paso.",
        "Esta es una línea en blanco, que no hace nada en el código. Es como dejar un espacio entre recetas en un cuaderno para que sea más fácil leer y no te confundas con tantas instrucciones juntas. En programación, estas líneas vacías hacen el código más legible, especialmente cuando tienes muchas funciones, como separar capítulos en un libro.",
        "Aquí comienza otra receta con '(define (filtrar-consonantes s)'. 'define' crea una nueva función llamada 'filtrar-consonantes', que también toma una cadena 's'. Esta receta va a quitar todas las vocales (a, e, i, o, u) de la cadena, dejando solo las consonantes, como limpiar un texto para quedarte solo con ciertas letras.",
        "La línea '(list->string' es el inicio del cuerpo, que prepara la conversión final de una lista de letras a una cadena. Es como decir 'al final, vamos a juntar todo en una palabra', pero el trabajo principal viene después. Este comando espera el resultado de los pasos siguientes para convertirlos en una cadena.",
        "La línea '(filter (lambda (c)' inicia el proceso de filtrado. 'filter' es una herramienta que revisa cada elemento de una lista y decide si lo incluye o no, como pasar cosas por un colador. 'lambda (c)' crea una mini-receta temporal que se aplica a cada letra 'c' de la lista. Es como un ayudante que revisa cada letra una por una para decidir si se queda o no.",
        "El núcleo del filtro es '(not (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))))'. Esto parece complejo, pero es como una prueba lógica. Primero, 'char-downcase c' convierte la letra 'c' a minúscula, para no preocuparnos por si es mayúscula o minúscula (por ejemplo, 'A' o 'a' se tratan igual). Luego, 'member' verifica si esa letra minúscula está en la lista de vocales '(#\\a #\\e #\\i #\\o #\\u)'. Si está (como 'a'), 'member' devuelve verdadero; 'not' lo invierte a falso, diciendo 'no incluyas esta letra'. Si no está (como 'm'), 'member' es falso, 'not' lo hace verdadero, diciendo 'sí incluye esta letra'. Esto asegura que solo las consonantes pasen el filtro.",
        "La línea '(string->list s))))' convierte la cadena 's' en una lista de letras para que 'filter' pueda trabajar con ellas. Es como desarmar la palabra en pedazos para revisar cada uno. Los paréntesis finales cierran todas las capas de 'filter' y 'list->string', completando la receta. Por ejemplo, para \"magina\", filtra las vocales y queda \"mgn\".",
        "Otra línea en blanco para separar, manteniendo el código organizado como un libro bien estructurado, lo que ayuda a no perderse entre tantas líneas.",
        "La línea '(define (compuesta-dos s)' crea la receta principal que combina las dos anteriores. 'compuesta-dos' significa que es una función que une (compone) otras funciones, tomando 's' como ingrediente inicial.",
        "El cuerpo '(filtrar-consonantes (revertir s)))' encadena las recetas: primero aplica 'revertir' a 's', luego pasa el resultado a 'filtrar-consonantes'. Es como una línea de producción donde primero das la vuelta a la palabra y luego quitas las vocales. Los paréntesis muestran que el resultado de 'revertir s' va directo a 'filtrar-consonantes', asegurando un flujo claro.",
        "Línea en blanco para separar la definición de la prueba final, ayudando a distinguir la creación de la receta de su uso real.",
        "Finalmente, '(compuesta-dos \"anigam\")' es como probar la receta con un ingrediente específico, \"anigam\". La computadora ejecuta el flujo: primero revierte a \"magina\", luego filtra las vocales, dando \"mgn\". Esto es para verificar que la receta funciona, como probar un pastel para ver si salió bien."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let revertir s =' es como escribir el título de una receta que dice 'deja que revertir sea una función que toma s'. 'let' es el comando para definir, como asignar un nombre a una instrucción. 's' es una cadena de texto, como una palabra. Esta receta va a invertir 's', como escribirla al revés, útil para procesar datos de forma inversa.",
        "La línea 'let len = String.length s in' crea una variable 'len' que guarda la longitud de 's', como medir cuántas letras tiene la palabra con una regla. Por ejemplo, para \"anigam\", 'len' es 6. Esto ayuda a la computadora a saber cuántos caracteres procesar, como contar los pasos antes de empezar.",
        "El cuerpo 'String.init len (fun i -> s.[len - 1 - i])' crea una nueva cadena de longitud 'len'. 'String.init' es como una máquina que genera una cadena letra por letra, usando una mini-receta 'fun i' que toma cada índice 'i' (de 0 a len-1) y selecciona la letra en la posición invertida 'len - 1 - i'. Por ejemplo, para i=0, toma la última letra; para i=1, la penúltima, etc. Esto construye \"magina\" para \"anigam\". Es como copiar un texto al revés, letra por letra, de una manera muy controlada.",
        "';;' es como un punto final que le dice a la computadora 'esta receta termina aquí'. Se usa al final de cada definición en OCaml para separar una instrucción de la siguiente, como cerrar un capítulo. Sin ';;', la computadora podría pensar que la receta sigue y se confundiría, causando errores. No programa un juego de carreras, pero es crucial para que el código esté bien organizado y funcione correctamente.",
        "Línea en blanco para separar, como un espacio entre páginas, haciendo el código más fácil de leer y entender, especialmente si tienes muchas recetas juntas.",
        "'let filtrar_consonantes s =' define una nueva receta para quitar vocales de 's', dejando solo consonantes, como limpiar un texto para extraer solo ciertas letras.",
        "'let buf = Buffer.create (String.length s) in' crea un 'buf', un contenedor temporal para construir la nueva cadena, como un tazón donde mezclas ingredientes. 'Buffer.create' reserva espacio basado en la longitud de 's', para que sea eficiente, como preparar un recipiente del tamaño justo para la mezcla.",
        "'String.iter (fun c ->' comienza un bucle que revisa cada letra 'c' de 's'. 'String.iter' es como una cinta transportadora que pasa cada letra por una prueba, y 'fun c' es una mini-receta que decide qué hacer con cada letra, como un inspector en la línea de producción.",
        "'if not (List.mem (Char.lowercase_ascii c) ['a'; 'e'; 'i'; 'o'; 'u']) then' es la prueba. Primero, 'Char.lowercase_ascii c' convierte 'c' a minúscula, para tratar 'A' y 'a' igual. Luego, 'List.mem' busca si esa letra está en la lista de vocales ['a'; 'e'; 'i'; 'o'; 'u']. 'not' invierte el resultado: si es vocal, 'not' da falso (no incluir); si no es vocal, da verdadero (incluir). Es como un filtro que dice 'pasa solo si no es vocal'.",
        "'Buffer.add_char buf c' añade la letra 'c' al contenedor 'buf' si pasa la prueba, como agregar un ingrediente aprobado al tazón.",
        "') s;' cierra el bucle, aplicando 'String.iter' a 's', asegurando que todas las letras sean revisadas. Es como decir 'termina de procesar toda la palabra'.",
        "'Buffer.contents buf' toma todo lo acumulado en 'buf' y lo convierte en una cadena final, como sacar la mezcla del tazón para servirla. Por ejemplo, para \"magina\", da \"mgn\".",
        "';;' cierra la definición, indicando que la receta está completa, evitando que se mezcle con la siguiente.",
        "Línea en blanco para organizar, como un respiro entre recetas.",
        "'let compuesta_dos s =' define la receta principal que combina las anteriores, tomando 's' como entrada.",
        "'filtrar_consonantes (revertir s)' encadena las funciones: primero invierte 's', luego filtra las vocales del resultado. Es como una fábrica donde el producto pasa por dos máquinas seguidas.",
        "';;' cierra la definición, asegurando que la computadora sepa que esta receta terminó.",
        "Línea en blanco para separar la definición de la prueba.",
        "'compuesta_dos \"anigam\"' prueba la receta con \"anigam\", ejecutando el flujo (invierte a \"magina\", filtra a \"mgn\") y mostrando el resultado, como probar un plato para confirmar que está bien cocinado."
      ],
      "comparisons": [
        "Similitudes: Tanto Racket como OCaml definen funciones para invertir una cadena, creando una receta reutilizable que toma una palabra y la da vuelta. Ambas producen el mismo resultado, como dos chefs haciendo el mismo plato. Diferencias: Racket usa un enfoque basado en listas, desarmando la cadena en letras con 'string->list', invirtiendo con 'reverse', y juntando con 'list->string', como desmontar y remontar un juguete. OCaml calcula la longitud y genera una nueva cadena con 'String.init', accediendo a letras en orden inverso, como copiar un texto al revés manualmente. Racket es más simple porque usa funciones prehechas, pero menos eficiente para cadenas largas; OCaml es más manual pero optimizado para memoria y velocidad.",
        "Similitudes: Ambas manejan la longitud o estructura de la cadena para invertirla, asegurando que todas las letras se procesen. Diferencias: Racket convierte la cadena en una lista, usando 'string->list' y 'reverse', lo que es como trabajar con piezas sueltas. OCaml usa 'String.length' para contar letras y 'String.init' con una fórmula 'len - 1 - i' para acceder a posiciones, como calcular pasos en una línea. Racket es más intuitivo para principiantes porque abstrae el cálculo, mientras OCaml requiere entender índices, lo que puede ser confuso al inicio pero da más control.",
        "Similitudes: Ambas completan la inversión con un paso final para devolver la cadena. Diferencias: Racket usa 'list->string' para juntar la lista invertida, cerrando con paréntesis ')', como cerrar una caja. OCaml no necesita un cierre explícito en el cuerpo, pero usa 'in' para conectar la variable 'len' con la acción, manteniendo el flujo claro. Racket es más visual con paréntesis, OCaml más implícito pero depende de 'in' para contexto.",
        "Similitudes: Ambas usan separadores para organizar el código, como dividir un cuaderno en secciones. Diferencias: Racket usa solo una línea en blanco, como un espacio simple. OCaml usa ';;' al final de cada definición, como un punto final fuerte que dice 'esta instrucción terminó, pasa a la siguiente'. ';;' se usa en OCaml para separar definiciones en un archivo o intérprete, asegurando que la computadora no mezcle funciones. No sirve para programar un juego de carreras directamente, pero es esencial para que el código sea claro y funcione sin errores. Racket no necesita ';;' porque los paréntesis ya marcan los límites.",
        "Similitudes: Ambas usan líneas en blanco para mejorar la legibilidad, como espacios en un libro. Diferencias: No hay diferencias significativas aquí; ambas hacen lo mismo, pero en OCaml las líneas vacías suelen ir después de ';;', combinando separación visual con el cierre explícito de la definición.",
        "Similitudes: Ambas definen funciones para filtrar consonantes, eliminando vocales de la cadena. Diferencias: Racket usa 'filter' para trabajar con una lista de letras, como seleccionar objetos de una caja uno por uno. OCaml usa un 'Buffer' y 'String.iter' para construir la cadena letra por letra, como llenar un frasco gota a gota. Racket es más conceptual, pensando en listas, mientras OCaml es más práctico, usando un contenedor eficiente para grandes cadenas, pero requiere entender buffers.",
        "Similitudes: Ambas preparan una estructura para construir el resultado final. Diferencias: Racket usa 'list->string' para convertir la lista filtrada en una cadena, como ensamblar piezas al final. OCaml crea un 'Buffer' con 'Buffer.create', como preparar un tazón para recoger letras, más eficiente para cadenas largas pero menos intuitivo para principiantes que no saben qué es un buffer.",
        "Similitudes: Ambas iteran sobre letras para decidir cuáles incluir. Diferencias: Racket usa 'filter' con 'lambda', que decide si cada letra pasa o no, como un guardia que aprueba o rechaza. OCaml usa 'String.iter' con 'fun', que recorre letras y las añade a un buffer si cumplen, como un trabajador que coloca piezas en una caja. Racket es más declarativo (dice qué quiere), OCaml más imperativo (dice cómo hacerlo paso a paso).",
        "Similitudes: Ambas verifican si una letra no es vocal. Diferencias: Racket usa 'not (member (char-downcase c) ...)', buscando en una lista de vocales y negando el resultado, como una lista de verificación negativa. OCaml usa 'not (List.mem (Char.lowercase_ascii c) ...)', similar pero con un módulo 'List' y 'Char', más estructurado pero requiere saber de módulos. Ambos logran lo mismo, pero Racket es más directo, OCaml más modular.",
        "Similitudes: Ambas deciden incluir letras no vocales. Diferencias: Racket retorna '#t' o '#f' para que 'filter' decida, como marcar una casilla. OCaml usa 'Buffer.add_char' para añadir directamente al contenedor si la condición es verdadera, como colocar un objeto en una caja. Racket es más abstracto, OCaml más explícito en la acción.",
        "Similitudes: Ambas cierran el proceso de iteración. Diferencias: Racket cierra 'filter' con paréntesis ')', como cerrar una puerta después de revisar todo. OCaml cierra 'String.iter' con ') s;', aplicando el bucle a 's', como decir 'termina de procesar esta palabra'. Racket usa paréntesis para estructura, OCaml usa ') s;' para indicar el final del bucle. Ninguno programa un juego de carreras, pero son esenciales para que el filtro funcione correctamente.",
        "Similitudes: Ambas retornan la cadena final. Diferencias: Racket usa 'list->string' para convertir la lista filtrada, como ensamblar un rompecabezas. OCaml usa 'Buffer.contents' para extraer la cadena del buffer, como vaciar el tazón. Racket es más intuitivo para listas, OCaml más eficiente para cadenas grandes.",
        "Similitudes: Ambas cierran definiciones con un marcador claro. Diferencias: Racket usa ')', los paréntesis finales de la definición, como cerrar un sobre. OCaml usa ';;', un doble punto y coma que marca el fin de la receta, usado en OCaml para separar funciones en un archivo o intérprete, asegurando que no se mezclen. ';;' no sirve para juegos de carreras, pero es clave para que el código sea claro y no cause errores por definiciones mal separadas.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna significativa; ambas usan blanks para legibilidad, como espacios en un texto.",
        "Similitudes: Ambas definen la función compuesta para encadenar acciones. Diferencias: Racket usa 'define' con paréntesis anidados, mostrando el flujo como capas. OCaml usa 'let' con una expresión más lineal, menos anidada visualmente, más fácil de seguir para principiantes pero menos explícita en jerarquía.",
        "Similitudes: Ambas encadenan revertir y filtrar para procesar la cadena. Diferencias: Racket usa paréntesis para anidar '(filtrar-consonantes (revertir s))', como pasos en una escalera. OCaml usa 'filtrar_consonantes (revertir s)', con menos paréntesis, más directo pero depende de paréntesis internos para claridad. Racket es más visual en orden, OCaml más compacto.",
        "Similitudes: Ambas cierran la definición compuesta con un marcador. Diferencias: Racket usa ')', cerrando la estructura anidada, como cerrar un libro. OCaml usa ';;', indicando fin de la definición, usado en cada 'let' para separar, esencial para evitar que la computadora mezcle funciones. No programa juegos, pero organiza el código para que funcione sin errores.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna; ambas organizan visualmente.",
        "Similitudes: Ambas prueban la función con \"anigam\", dando \"mgn\". Diferencias: Racket usa paréntesis '(compuesta-dos \"anigam\")', consistente con su estilo anidado, como una llamada completa. OCaml usa 'compuesta_dos \"anigam\"' sin paréntesis extra, más simple, como decir un comando directo. Ambos logran lo mismo, pero Racket es más estructurado, OCaml más minimalista."
      ]
    },
    "ejercicio-3": {
      "title": "Componer multiplicación, filtrado y suma de lista",
      "racket": {
        "lines": [
          "(define (multiplicar-por-dos lst)",
          "  (map (lambda (x) (* x 2)) lst))",
          "",
          "(define (filtrar-mayores-cinco lst)",
          "  (filter (lambda (x) (> x 5)) lst))",
          "",
          "(define (sumar-lista lst)",
          "  (foldl + 0 lst))",
          "",
          "(define (compuesta-tres lst)",
          "  (sumar-lista (filtrar-mayores-cinco (multiplicar-por-dos lst))))",
          "",
          "(compuesta-tres '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let multiplicar_por_dos lst =",
          "  List.map (fun x -> x * 2) lst",
          ";;",
          "",
          "let filtrar_mayores_cinco lst =",
          "  List.filter (fun x -> x > 5) lst",
          ";;",
          "",
          "let sumar_lista lst =",
          "  List.fold_left (+) 0 lst",
          ";;",
          "",
          "let compuesta_tres lst =",
          "  sumar_lista (filtrar_mayores_cinco (multiplicar_por_dos lst))",
          ";;",
          "",
          "compuesta_tres [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Imagina que estás armando un proceso como si fuera una línea de producción en una fábrica. La línea '(define (multiplicar-por-dos lst)' es como ponerle un nombre a una máquina llamada 'multiplicar-por-dos'. La palabra 'define' le dice a la computadora que estás creando una nueva instrucción o función. Dentro de los paréntesis, 'lst' es el ingrediente, que en este caso es una lista de números, como '(2 3 4)', que es como una caja con los números 2, 3 y 4. Esta máquina va a tomar cada número y multiplicarlo por 2, como si estuvieras doblando la cantidad de cada ingrediente en una receta. En programación, esto es útil para transformar datos, como ajustar valores en un cálculo.",
        "El cuerpo de la función es '(map (lambda (x) (* x 2)) lst))'. Aquí, 'map' es una herramienta que toma cada número de la lista 'lst' y aplica una mini-instrucción a cada uno. La mini-instrucción es '(lambda (x) (* x 2))', donde 'lambda' crea una receta temporal que dice 'toma un número x y multiplícalo por 2'. Por ejemplo, para la lista '(2 3 4)', 'map' aplica la multiplicación a cada número, dando '(4 6 8)'. Los paréntesis anidan todo, como cajas dentro de cajas, para que la computadora sepa exactamente qué hacer y en qué orden. Es como pasar cada número por una máquina que lo duplica, uno por uno.",
        "Esta es una línea en blanco, que no hace nada en el código, pero es como dejar un espacio entre pasos en una receta para que sea más fácil de leer. En programación, estas líneas vacías hacen el código más claro, como separar párrafos en un cuaderno, para que no te pierdas entre tantas instrucciones.",
        "La línea '(define (filtrar-mayores-cinco lst)' crea otra máquina llamada 'filtrar-mayores-cinco', que también toma una lista 'lst'. Esta máquina va a revisar cada número y solo dejar pasar los que son mayores que 5, como si estuvieras seleccionando frutas que pesan más de un cierto peso en un mercado.",
        "El cuerpo '(filter (lambda (x) (> x 5)) lst))' usa 'filter', una herramienta que actúa como un colador: revisa cada número 'x' en 'lst' y decide si lo incluye según una condición. La condición es '(lambda (x) (> x 5))', una mini-instrucción que dice 'si x es mayor que 5, inclúyelo; si no, déjalo fuera'. Por ejemplo, para '(4 6 8)', solo pasan 6 y 8, dando '(6 8)'. Los paréntesis cierran cada parte, asegurando que la computadora siga el orden correcto, como instrucciones claras en una lista de tareas.",
        "Otra línea en blanco para separar, manteniendo el código organizado, como dividir secciones en un libro para que sea fácil de seguir.",
        "La línea '(define (sumar-lista lst)' define una máquina 'sumar-lista' que toma 'lst' y suma todos sus números, como calcular el total de una lista de precios en una tienda.",
        "El cuerpo '(foldl + 0 lst))' usa 'foldl', una herramienta que combina todos los elementos de 'lst' usando el operador '+' (suma), empezando con 0 como base. Es como sumar números uno por uno de izquierda a derecha. Para '(6 8)', calcula 0 + 6 = 6, luego 6 + 8 = 14. Los paréntesis cierran la instrucción, y 'foldl' asegura que el proceso sea sistemático, como usar una calculadora paso a paso.",
        "Línea en blanco para separar la definición de la siguiente parte, ayudando a mantener el código claro y ordenado.",
        "La línea '(define (compuesta-tres lst)' crea la máquina principal 'compuesta-tres', que combina las tres anteriores. 'compuesta' significa que une varias funciones en un solo proceso, como una receta que usa varias técnicas para hacer un plato final.",
        "El cuerpo '(sumar-lista (filtrar-mayores-cinco (multiplicar-por-dos lst))))' encadena las máquinas: primero aplica 'multiplicar-por-dos' a 'lst', luego pasa el resultado a 'filtrar-mayores-cinco', y finalmente ese resultado a 'sumar-lista'. Es como una línea de producción donde el material pasa por tres estaciones: duplicar, filtrar, sumar. Los paréntesis anidados muestran el orden, como pasos en una coreografía, asegurando que cada máquina reciba el output de la anterior.",
        "Línea en blanco para separar la definición de la prueba, como un espacio entre la receta y el momento de probarla.",
        "Finalmente, '(compuesta-tres '(2 3 4))' es como encender la máquina con la lista '(2 3 4)'. Primero multiplica (4 6 8), luego filtra (6 8), y suma 14. Esto prueba que todo funciona, como probar un plato para ver si el sabor es correcto. En programación, estas pruebas ayudan a confirmar que el código hace lo que esperas."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let multiplicar_por_dos lst =' es como escribir el título de una receta que dice 'deja que multiplicar_por_dos sea una función que toma lst'. 'let' es el comando para definir una instrucción, como asignar un nombre a un proceso. 'lst' es una lista de números, como [2; 3; 4], que es como una fila de cajas con números. Esta receta va a duplicar cada número, como aumentar el tamaño de cada ingrediente en una mezcla.",
        "El cuerpo 'List.map (fun x -> x * 2) lst' usa 'List.map', una herramienta de la biblioteca 'List' que toma cada número de 'lst' y aplica una mini-instrucción. La mini-instrucción es '(fun x -> x * 2)', donde 'fun' crea una receta temporal que dice 'toma x y devuelve x * 2'. El '->' es como decir 'esto se convierte en'. Para [2; 3; 4], produce [4; 6; 8]. No hay paréntesis extras porque OCaml es más lineal, como escribir una lista de pasos sin envolverla en capas adicionales.",
        "';;' es un separador que cierra la definición, como un punto final que dice 'esta receta está completa'. Se usa en OCaml al final de cada 'let' para separar funciones, evitando que la computadora mezcle instrucciones. Sin ';;', el código podría interpretarse mal, causando errores. No programa un juego de carreras, pero es esencial para que el código sea claro y funcione correctamente, como un sello que asegura que cada instrucción está bien cerrada.",
        "Línea en blanco para organizar, como un espacio entre páginas en un libro, haciendo el código más fácil de leer, especialmente cuando hay varias funciones.",
        "'let filtrar_mayores_cinco lst =' define otra receta para filtrar números mayores que 5 de 'lst'. Es como seleccionar solo los objetos más grandes de una caja.",
        "'List.filter (fun x -> x > 5) lst' usa 'List.filter', una herramienta que revisa cada número 'x' en 'lst' y lo incluye si cumple la condición '(fun x -> x > 5)', que dice 'devuelve verdadero si x es mayor que 5'. Para [4; 6; 8], da [6; 8]. El '->' indica el resultado de la condición, y 'List' es la biblioteca que proporciona la herramienta. Es como pasar objetos por un filtro que solo deja los grandes.",
        "';;' cierra la definición, asegurando que la computadora sepa que esta receta terminó y puede pasar a la siguiente sin confusión.",
        "Línea en blanco para separar, manteniendo el código ordenado como un cuaderno bien organizado.",
        "'let sumar_lista lst =' define una receta para sumar todos los números de 'lst', como calcular el total de una lista de gastos.",
        "'List.fold_left (+) 0 lst' usa 'List.fold_left', una herramienta que combina los números de 'lst' usando el operador '(+)' (suma), empezando con 0. Para [6; 8], calcula 0 + 6 = 6, luego 6 + 8 = 14. El '(+)' es una forma de usar la suma como una instrucción, y el 0 es el punto de partida, como empezar una cuenta desde cero.",
        "';;' cierra, indicando el fin de la receta, esencial para separar instrucciones en OCaml y evitar errores.",
        "Línea en blanco para claridad, como un espacio entre pasos en una guía.",
        "'let compuesta_tres lst =' define la receta principal que combina las tres funciones, tomando 'lst' como entrada.",
        "'sumar_lista (filtrar_mayores_cinco (multiplicar_por_dos lst))' encadena las funciones: primero multiplica, luego filtra, luego suma. Es como una fábrica donde el material pasa por tres máquinas en orden. Los paréntesis muestran el flujo, asegurando que cada función reciba el resultado de la anterior.",
        "';;' cierra la definición, marcando el fin para que la computadora no mezcle esta receta con otras.",
        "Línea en blanco para separar la definición de la prueba final.",
        "'compuesta_tres [2; 3; 4]' prueba la receta con la lista [2; 3; 4], ejecutando el flujo: multiplica a [4; 6; 8], filtra a [6; 8], suma 14. Es como probar un producto final para confirmar que la máquina funciona bien."
      ],
      "comparisons": [
        "Similitudes: Tanto Racket como OCaml crean funciones para multiplicar cada número de una lista por 2, usando una herramienta (map) que aplica una transformación a cada elemento. Ambas producen el mismo resultado, como dos cocineros haciendo la misma receta. Diferencias: Racket usa 'define' con 'map' y 'lambda', envolviendo todo en paréntesis, como un paquete estructurado. OCaml usa 'let' con 'List.map' y 'fun', accediendo a una biblioteca 'List' y usando '->' para indicar el resultado. Racket es más anidado y visual en estructura, mientras OCaml es más lineal y requiere nombrar el módulo 'List', lo que puede ser menos intuitivo para principiantes pero organiza las herramientas en categorías.",
        "Similitudes: Ambas aplican la multiplicación por 2 a cada elemento de la lista, transformando la lista completa. Diferencias: Racket usa '(lambda (x) (* x 2))', donde 'lambda' define la mini-instrucción y '(* x 2)' pone el operador primero (estilo prefijo). OCaml usa '(fun x -> x * 2)', donde 'fun' crea la instrucción y '->' indica 'devuelve', con 'x * 2' en estilo infijo, como en matemáticas. OCaml es más parecido a una ecuación, pero requiere aprender '->', mientras Racket es más consistente con su estilo de paréntesis.",
        "Similitudes: Ambas usan separadores para organizar el código, como dividir un libro en capítulos. Diferencias: Racket usa solo una línea en blanco, como un espacio simple. OCaml usa ';;' al final de cada definición, como un doble punto y coma que dice 'esta instrucción está completa'. ';;' se usa en OCaml para separar funciones en un archivo o intérprete, asegurando que la computadora no mezcle recetas. No sirve para programar un juego de carreras, pero es crucial para evitar errores al ejecutar el código, como un sello que cierra cada instrucción. Racket no necesita ';;' porque los paréntesis ya marcan los límites de cada función.",
        "Similitudes: Ambas usan líneas en blanco para mejorar la legibilidad, como espacios en un texto. Diferencias: No hay diferencias significativas; ambas separan visualmente, pero en OCaml las líneas vacías suelen ir después de ';;', combinando el cierre explícito con la separación visual.",
        "Similitudes: Ambas definen funciones para filtrar números mayores que 5, usando una herramienta que selecciona elementos según una condición. Diferencias: Racket usa 'define' con 'filter' y 'lambda', estructurando todo en paréntesis. OCaml usa 'let' con 'List.filter' y 'fun', accediendo al módulo 'List'. Racket es más intuitivo para principiantes porque no requiere módulos, mientras OCaml organiza herramientas en 'List', pero puede confundir si no sabes qué es un módulo.",
        "Similitudes: Ambas verifican si un número es mayor que 5 para incluirlo. Diferencias: Racket usa '(> x 5)', con el operador prefijo dentro de paréntesis, como una instrucción clara. OCaml usa 'x > 5', en estilo infijo como en matemáticas, más familiar pero menos consistente con el resto del lenguaje. OCaml es más legible para condiciones simples, Racket más uniforme en sintaxis.",
        "Similitudes: Ambas cierran las definiciones de filtrado con un marcador. Diferencias: Racket usa ')', los paréntesis finales que cierran la estructura anidada, como cerrar un sobre. OCaml usa ';;', un doble punto y coma que marca el fin de la receta, usado en cada 'let' para separar funciones. ';;' es esencial en OCaml para que el intérprete sepa dónde termina cada instrucción, evitando errores. No programa juegos, pero organiza el código para que funcione correctamente. Racket usa paréntesis para lo mismo, sin necesitar un separador extra.",
        "Similitudes: Líneas en blanco separan visualmente. Diferencias: Ninguna; ambas usan blanks para claridad, como espacios en un cuaderno.",
        "Similitudes: Ambas definen funciones para sumar listas, usando una herramienta que acumula valores. Diferencias: Racket usa 'define' con 'foldl' y el operador '+', estructurado en paréntesis. OCaml usa 'let' con 'List.fold_left' y '(+)', accediendo al módulo 'List'. Racket es más directo al usar '+', mientras OCaml requiere '(+)' como una función explícita, lo que puede ser confuso al inicio pero es parte de su estilo modular.",
        "Similitudes: Ambas acumulan la suma empezando desde 0. Diferencias: Racket usa '+' dentro de 'foldl', como un operador estándar. OCaml usa '(+)' como una función, lo que es menos intuitivo pero necesario para que 'fold_left' lo use. Racket es más simple en sintaxis, OCaml más explícito en el uso de operadores como funciones.",
        "Similitudes: Ambas cierran las definiciones de suma con un marcador. Diferencias: Racket usa ')', cerrando la estructura anidada. OCaml usa ';;', marcando el fin de la receta, usado en cada 'let' para separar. ';;' asegura que las funciones no se mezclen, esencial para evitar errores, pero no tiene relación con juegos de carreras; es solo una regla de OCaml para organización.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna; ambas organizan visualmente.",
        "Similitudes: Ambas definen la función compuesta para encadenar las tres operaciones. Diferencias: Racket usa 'define' con paréntesis anidados, mostrando el flujo como capas de una cebolla. OCaml usa 'let' con una expresión más lineal, menos anidada visualmente, más fácil de seguir para principiantes pero menos explícita en jerarquía.",
        "Similitudes: Ambas encadenan multiplicar, filtrar y sumar en el mismo orden. Diferencias: Racket usa paréntesis anidados '(sumar-lista (filtrar-mayores-cinco (multiplicar-por-dos lst)))', como pasos en una escalera. OCaml usa 'sumar_lista (filtrar_mayores_cinco (multiplicar_por_dos lst))', con menos paréntesis, más directo pero depende de paréntesis internos para claridad. Racket es más visual en el flujo, OCaml más compacto.",
        "Similitudes: Ambas cierran la definición compuesta con un marcador. Diferencias: Racket usa ')', cerrando la estructura anidada, como cerrar un libro. OCaml usa ';;', indicando el fin de la definición, usado en cada 'let' para separar funciones. ';;' es crucial para que OCaml entienda dónde termina cada instrucción, evitando errores, pero no programa juegos; es solo una regla de sintaxis para claridad.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna; ambas usan blanks para legibilidad.",
        "Similitudes: Ambas prueban la función con una lista equivalente, dando 14. Diferencias: Racket usa '(2 3 4)' con paréntesis y espacios, consistente con su estilo. OCaml usa '[2; 3; 4]' con corchetes y punto y coma, más compacto pero requiere aprender la sintaxis de listas. Ambas logran lo mismo, pero Racket es más uniforme con paréntesis, OCaml más variado en notación."
      ]
    },
    "ejercicio-4": {
      "title": "Componer reversión, mayúsculas, filtrado anidado y longitud",
      "racket": {
        "lines": [
          "(define (revertir s)",
          "  (list->string (reverse (string->list s))))",
          "",
          "(define (a-mayusculas s)",
          "  (string-upcase s))",
          "",
          "(define (filtrar-alfabeticos-no-vocales s)",
          "  (list->string",
          "   (filter (lambda (c)",
          "             (if (char-alphabetic? c)",
          "                 (if (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))",
          "                     #f",
          "                     #t)",
          "                 #f))",
          "           (string->list s))))",
          "",
          "(define (contar-longitud s)",
          "  (string-length s))",
          "",
          "(define (compuesta-cuatro s)",
          "  (contar-longitud (filtrar-alfabeticos-no-vocales (a-mayusculas (revertir s)))))",
          "",
          "(compuesta-cuatro \"txet1\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let revertir s =",
          "  let len = String.length s in",
          "  String.init len (fun i -> s.[len - 1 - i])",
          ";;",
          "",
          "let a_mayusculas s =",
          "  String.uppercase_ascii s",
          ";;",
          "",
          "let filtrar_alfabeticos_no_vocales s =",
          "  let buf = Buffer.create (String.length s) in",
          "  String.iter (fun c ->",
          "    if Char.is_alpha c then",
          "      if not (List.mem (Char.lowercase_ascii c) ['a'; 'e'; 'i'; 'o'; 'u']) then",
          "        Buffer.add_char buf c",
          "  ) s;",
          "  Buffer.contents buf",
          ";;",
          "",
          "let contar_longitud s =",
          "  String.length s",
          ";;",
          "",
          "let compuesta_cuatro s =",
          "  contar_longitud (filtrar_alfabeticos_no_vocales (a_mayusculas (revertir s)))",
          ";;",
          "",
          "compuesta_cuatro \"txet1\""
        ]
      },
      "explanations_racket": [
        "Imagina que estás armando un proceso como si fuera una serie de pasos en una fábrica de palabras. La línea '(define (revertir s)' es como nombrar una máquina llamada 'revertir'. La palabra 'define' le dice a la computadora que estás creando una nueva instrucción. Dentro de los paréntesis, 's' es el ingrediente, una cadena de texto como \"txet1\", que es una secuencia de letras o caracteres. Esta máquina va a tomar la cadena y darle la vuelta, como escribir una palabra al revés en un espejo. Esto es útil en programación para cosas como procesar texto al revés o crear efectos especiales con cadenas.",
        "El cuerpo es '(list->string (reverse (string->list s))))'. Esto parece complicado, pero es como seguir una receta paso a paso. Primero, 'string->list s' convierte la cadena 's' en una lista de caracteres, como desarmar una palabra en letras sueltas. Por ejemplo, \"txet1\" se convierte en '(#\\t #\\x #\\e #\\t #\\1)'. Luego, 'reverse' invierte esa lista, como girar una pila de cartas, dando '(#\\1 #\\t #\\e #\\x #\\t)'. Finalmente, 'list->string' junta las letras de nuevo en una cadena, resultando en \"1tetx\". Los paréntesis anidan cada paso, como cajas dentro de cajas, para que la computadora sepa el orden exacto. Esto asegura que la inversión sea clara, como seguir una guía detallada.",
        "Línea en blanco, que no hace nada en el código. Es como dejar un espacio entre pasos en un cuaderno de recetas para que sea más fácil leer y no te confundas con tantas instrucciones juntas. En programación, estas líneas vacías hacen el código más legible, como separar capítulos en un libro.",
        "La línea '(define (a-mayusculas s)' crea otra máquina llamada 'a-mayusculas', que toma una cadena 's'. Esta máquina convierte todas las letras de 's' a mayúsculas, como cambiar una palabra escrita en pequeño a letras grandes, útil para estandarizar texto o resaltar algo.",
        "El cuerpo '(string-upcase s))' usa 'string-upcase', una herramienta que toma 's' y convierte sus letras a mayúsculas. Por ejemplo, \"1tetx\" se convierte en \"1TETX\". Los paréntesis cierran la instrucción, asegurando que la computadora sepa qué transformar. Es como usar una prensa para estampar letras en mayúscula, dejando números o símbolos intactos.",
        "Otra línea en blanco para separar, manteniendo el código organizado, como dividir secciones en una guía para no perderse.",
        "La línea '(define (filtrar-alfabeticos-no-vocales s)' define una máquina más compleja que filtra la cadena 's' para quedarse solo con letras que no sean vocales (a, e, i, o, u), ignorando números o símbolos. Es como limpiar una mezcla para quedarte solo con ciertos ingredientes.",
        "El cuerpo comienza con '(list->string', que prepara la conversión final de una lista de letras a una cadena, como decir 'al final, juntaremos todo en una palabra'. El trabajo principal viene en las líneas siguientes.",
        "La línea '(filter (lambda (c)' inicia un proceso de filtrado. 'filter' es como un colador que revisa cada letra 'c' de una lista y decide si la incluye. 'lambda (c)' crea una mini-instrucción temporal que se aplica a cada letra, como un inspector que revisa cada carácter uno por uno.",
        "La línea '(if (char-alphabetic? c)' comienza una prueba. 'char-alphabetic?' verifica si 'c' es una letra (no un número ni símbolo). Si es letra, pasa a la siguiente condición; si no, se decide qué hacer. Es como preguntar '¿es esto una letra?' antes de seguir.",
        "La línea '(if (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))' verifica si la letra en minúscula (usando 'char-downcase c' para tratar 'A' y 'a' igual) está en la lista de vocales. 'member' busca en '(#\\a #\\e #\\i #\\o #\\u)'. Si está, significa que es una vocal.",
        "'#f' significa 'falso', indicando que no se incluye la letra si es vocal. Es como decir 'descarta esto' si es a, e, i, o, u.",
        "'#t' significa 'verdadero', indicando que se incluye la letra si no es vocal. Es como decir 'guarda esta consonante'.",
        "'#f)' cierra el primer 'if', diciendo que si 'c' no es letra (como '1'), no se incluye. Esto asegura que solo letras consonantes pasen el filtro.",
        "La línea '(string->list s))))' convierte 's' en una lista de letras para que 'filter' pueda trabajar, como desarmar la palabra en pedazos. Los paréntesis cierran todas las capas, completando la receta. Para \"1TETX\", filtra a \"TX\", porque '1' no es letra, 'E' es vocal, y 'T', 'X' son consonantes.",
        "Línea en blanco para separar, como un espacio en un libro para claridad.",
        "La línea '(define (contar-longitud s)' crea una máquina que cuenta cuántas letras tiene 's', como medir una cuerda para saber su longitud.",
        "El cuerpo '(string-length s))' usa 'string-length', una herramienta que devuelve el número de caracteres en 's'. Para \"TX\", da 2. Los paréntesis cierran la instrucción, asegurando claridad.",
        "Línea en blanco para organizar.",
        "La línea '(define (compuesta-cuatro s)' define la máquina principal que combina todas las anteriores, tomando 's' como entrada.",
        "El cuerpo '(contar-longitud (filtrar-alfabeticos-no-vocales (a-mayusculas (revertir s)))))' encadena las funciones: primero invierte, luego convierte a mayúsculas, filtra consonantes, y cuenta la longitud. Es como una línea de producción con cuatro estaciones. Los paréntesis anidados muestran el flujo, como pasos en una danza.",
        "Línea en blanco para separar la definición de la prueba.",
        "Finalmente, '(compuesta-cuatro \"txet1\")' prueba la máquina con \"txet1\". Invierte a \"1tetx\", mayúsculas a \"1TETX\", filtra a \"TX\", cuenta 2. Esto verifica que todo funciona, como probar un producto final."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let revertir s =' es como escribir el título de una receta que dice 'deja que revertir sea una función que toma s'. 'let' es el comando para definir una instrucción, como asignar un nombre a un proceso. 's' es una cadena, como \"txet1\". Esta receta invierte la cadena, útil para procesar texto al revés.",
        "La línea 'let len = String.length s in' crea una variable 'len' con la longitud de 's', como contar las letras con una regla. Para \"txet1\", 'len' es 5. Esto ayuda a la computadora a saber cuántos caracteres procesar.",
        "'String.init len (fun i -> s.[len - 1 - i])' crea una nueva cadena de longitud 'len'. 'String.init' genera la cadena letra por letra, usando 'fun i' para tomar cada índice 'i' (0 a len-1) y seleccionar la letra en la posición invertida 'len - 1 - i'. Para \"txet1\", da \"1tetx\". Es como copiar al revés, controlando cada paso.",
        "';;' cierra la definición, como un punto final que dice 'esta receta termina aquí'. Se usa en OCaml al final de cada 'let' para separar funciones, evitando que la computadora mezcle instrucciones. Sin ';;', el código podría fallar. No programa un juego de carreras, pero es crucial para que el código sea claro y funcione, como un sello que asegura cada instrucción.",
        "Línea en blanco para organizar, como un espacio entre páginas, haciendo el código más legible.",
        "'let a_mayusculas s =' define una receta para convertir 's' a mayúsculas, como cambiar letras pequeñas a grandes.",
        "'String.uppercase_ascii s' usa 'String.uppercase_ascii', una herramienta que convierte letras a mayúsculas en formato ASCII. Para \"1tetx\", da \"1TETX\". No hay paréntesis extras, porque OCaml es más lineal.",
        "';;' cierra, marcando el fin de la receta, esencial para separar en OCaml.",
        "Línea en blanco para claridad.",
        "'let filtrar_alfabeticos_no_vocales s =' define una receta para filtrar letras no vocales, ignorando números o símbolos.",
        "'let buf = Buffer.create (String.length s) in' crea un 'buf', un contenedor temporal para construir la cadena, como un tazón para mezclar. 'Buffer.create' reserva espacio según la longitud de 's', para eficiencia.",
        "'String.iter (fun c ->' inicia un bucle que revisa cada letra 'c' de 's'. 'String.iter' pasa cada letra por una prueba, y 'fun c' es una mini-instrucción para cada carácter.",
        "'if Char.is_alpha c then' verifica si 'c' es una letra, usando 'Char.is_alpha'. Si es letra, sigue; si no (como '1'), no hace nada.",
        "'if not (List.mem (Char.lowercase_ascii c) ['a'; 'e'; 'i'; 'o'; 'u']) then' verifica si la letra en minúscula (con 'Char.lowercase_ascii') no está en la lista de vocales. 'List.mem' busca; 'not' invierte el resultado. Si no es vocal, pasa la prueba.",
        "'Buffer.add_char buf c' añade 'c' al contenedor si pasa las pruebas, como agregar un ingrediente aprobado.",
        "') s;' cierra el bucle, aplicando 'String.iter' a 's', procesando toda la cadena.",
        "'Buffer.contents buf' convierte el contenido de 'buf' en una cadena. Para \"1TETX\", da \"TX\".",
        "';;' cierra, indicando el fin de la receta.",
        "Línea en blanco para organizar.",
        "'let contar_longitud s =' define una receta para contar caracteres en 's'.",
        "'String.length s' devuelve la longitud. Para \"TX\", da 2.",
        "';;' cierra, separando la receta.",
        "Línea en blanco para claridad.",
        "'let compuesta_cuatro s =' define la receta principal que combina todas.",
        "'contar_longitud (filtrar_alfabeticos_no_vocales (a_mayusculas (revertir s)))' encadena: invierte, mayúsculas, filtra, cuenta.",
        "';;' cierra, asegurando separación.",
        "Línea en blanco para separar.",
        "'compuesta_cuatro \"txet1\"' prueba con \"txet1\", dando 2 (invierte a \"1tetx\", mayúsculas a \"1TETX\", filtra a \"TX\", cuenta 2)."
      ],
      "comparisons": [
        "Similitudes: Ambas definen funciones para invertir cadenas, produciendo el mismo resultado. Diferencias: Racket usa listas con 'string->list', 'reverse', 'list->string', como desarmar y rearmar un rompecabezas. OCaml usa 'String.length' y 'String.init' con índices, como copiar al revés manualmente. Racket es más simple para principiantes, OCaml más eficiente pero requiere entender índices.",
        "Similitudes: Ambas manejan la longitud o estructura de la cadena. Diferencias: Racket convierte a lista, OCaml usa 'let len' para almacenar longitud y calcula posiciones. Racket abstrae más, OCaml es más manual pero controlado.",
        "Similitudes: Completan la inversión. Diferencias: Racket cierra con ')', OCaml usa 'in' para conectar 'len'. Racket es visual con paréntesis, OCaml implícito pero estructurado con 'in'.",
        "Similitudes: Separadores organizan. Diferencias: Racket usa línea en blanco. OCaml usa ';;', un doble punto y coma que cierra definiciones, usado en cada 'let' para separar funciones, evitando errores. No programa juegos de carreras, pero es esencial para que OCaml entienda dónde termina cada instrucción, como un sello de cierre.",
        "Similitudes: Líneas en blanco mejoran legibilidad. Diferencias: Ninguna; ambas separan visualmente, OCaml tras ';;'.",
        "Similitudes: Ambas convierten a mayúsculas. Diferencias: Racket usa 'define' con 'string-upcase', OCaml 'let' con 'String.uppercase_ascii'. Racket más directo, OCaml requiere módulo 'String'.",
        "Similitudes: Aplican mayúsculas. Diferencias: Racket envuelve en paréntesis, OCaml es lineal. OCaml más simple en sintaxis, Racket más estructurado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml ';;', que separa funciones en OCaml, esencial para evitar mezclas, no para juegos sino para claridad.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Filtran letras no vocales. Diferencias: Racket usa 'filter' con listas, OCaml usa 'Buffer' con 'String.iter'. Racket más conceptual, OCaml más eficiente pero complejo con buffers.",
        "Similitudes: Preparan resultado. Diferencias: Racket 'list->string', OCaml 'Buffer.create'. Racket simple con listas, OCaml eficiente con buffers.",
        "Similitudes: Iteran caracteres. Diferencias: Racket 'filter lambda', OCaml 'String.iter fun'. Racket declarativo, OCaml imperativo.",
        "Similitudes: Verifican letras. Diferencias: Racket 'char-alphabetic?', OCaml 'Char.is_alpha'. OCaml usa módulo, Racket más directo.",
        "Similitudes: Filtran no vocales. Diferencias: Racket 'member char-downcase', OCaml 'List.mem Char.lowercase_ascii'. Ambos similares, pero OCaml modular.",
        "Similitudes: Incluyen consonantes. Diferencias: Racket '#t', OCaml 'Buffer.add_char'. Racket abstracto, OCaml explícito.",
        "Similitudes: Cierran iteración. Diferencias: Racket ')', OCaml ') s;'. OCaml aplica bucle explícitamente.",
        "Similitudes: Retornan cadena. Diferencias: Racket 'list->string', OCaml 'Buffer.contents'. Racket lista, OCaml buffer.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', esencial para separar en OCaml, no para juegos sino para orden.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Cuentan longitud. Diferencias: Racket 'define string-length', OCaml 'let String.length'. OCaml usa módulo, Racket directo.",
        "Similitudes: Aplican longitud. Diferencias: Racket paréntesis, OCaml lineal. OCaml más simple, Racket estructurado.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', para separar funciones, esencial para OCaml.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket 'define' anidado, OCaml 'let' lineal. Racket visual, OCaml compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket paréntesis anidados, OCaml menos paréntesis. Racket claro en flujo, OCaml minimalista.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', para separación en OCaml, no juegos sino claridad.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Prueban con \"txet1\", dando 2. Diferencias: Racket paréntesis, OCaml directo. Racket uniforme, OCaml minimalista."
      ]
    },
    "ejercicio-5": {
      "title": "Componer filtrado, mapeo, suma condicional y ajuste final",
      "racket": {
        "lines": [
          "(define (filtrar-mayor-tres lst)",
          "  (filter (lambda (p) (> (cdr p) 3)) lst))",
          "",
          "(define (mapear-mk-duplicar lst)",
          "  (map (lambda (p)",
          "         (cons (string-append \"mk-\" (car p))",
          "               (* (cdr p) 2)))",
          "       lst))",
          "",
          "(define (fold-suma-cond-anidada lst)",
          "  (foldl (lambda (p acc)",
          "           (let ([val (cdr p)])",
          "             (if (even? val)",
          "                 (if (> val 4)",
          "                     (+ acc (* val 2))",
          "                     (+ acc val))",
          "                 (+ acc val))))",
          "         0 lst))",
          "",
          "(define (ajustar-si-mayor-diez n)",
          "  (if (> n 10)",
          "      (- n 5)",
          "      n))",
          "",
          "(define (compuesta-cinco lst)",
          "  (ajustar-si-mayor-diez (fold-suma-cond-anidada (mapear-mk-duplicar (filtrar-mayor-tres lst)))))",
          "",
          "(compuesta-cinco '((\"gear\" . 4) (\"bolt\" . 2)))"
        ]
      },
      "ocaml": {
        "lines": [
          "let filtrar_mayor_tres lst =",
          "  List.filter (fun (_, v) -> v > 3) lst",
          ";;",
          "",
          "let mapear_mk_duplicar lst =",
          "  List.map (fun (n, v) -> (\"mk-\" ^ n, v * 2)) lst",
          ";;",
          "",
          "let fold_suma_cond_anidada lst =",
          "  List.fold_left (fun acc (_, val_) ->",
          "    if val_ mod 2 = 0 then",
          "      if val_ > 4 then",
          "        acc + (val_ * 2)",
          "      else",
          "        acc + val_",
          "    else",
          "      acc + val_",
          "  ) 0 lst",
          ";;",
          "",
          "let ajustar_si_mayor_diez n =",
          "  if n > 10 then n - 5 else n",
          ";;",
          "",
          "let compuesta_cinco lst =",
          "  ajustar_si_mayor_diez (fold_suma_cond_anidada (mapear_mk_duplicar (filtrar_mayor_tres lst)))",
          ";;",
          "",
          "compuesta_cinco [(\"gear\", 4); (\"bolt\", 2)]"
        ]
      },
      "explanations_racket": [
        "Piensa en el código como una fábrica que procesa una lista de pares, como etiquetas con nombres y valores (por ejemplo, '(\"gear\" . 4)'). La línea '(define (filtrar-mayor-tres lst)' es como nombrar una máquina llamada 'filtrar-mayor-tres'. 'define' le dice a la computadora que estás creando una nueva instrucción. 'lst' es una lista de pares, como '((\"gear\" . 4) (\"bolt\" . 2))', donde cada par tiene un nombre (una cadena) y un número. Esta máquina filtra los pares donde el número es mayor que 3, como seleccionar productos con un peso superior a cierto límite.",
        "'(filter (lambda (p) (> (cdr p) 3)) lst))' usa 'filter', una herramienta que revisa cada par 'p' en 'lst' y lo incluye si cumple una condición. La condición es '(lambda (p) (> (cdr p) 3))', una mini-instrucción que toma un par 'p', usa 'cdr' para obtener su número (por ejemplo, 4 en '(\"gear\" . 4)'), y verifica si es mayor que 3 con '>' (estilo prefijo). Para '((\"gear\" . 4) (\"bolt\" . 2))', solo pasa '(\"gear\" . 4)'. Los paréntesis anidan todo, como pasos claros en una lista, asegurando que la computadora siga el orden correcto.",
        "Línea en blanco, como un espacio en un cuaderno para separar recetas, haciendo el código más legible, como dividir capítulos en un libro.",
        "'(define (mapear-mk-duplicar lst)' crea una máquina que transforma cada par en 'lst', añadiendo \"mk-\" al nombre y duplicando el número, como etiquetar y ajustar productos en una línea de ensamblaje.",
        "'(map (lambda (p)' inicia el proceso con 'map', que aplica una mini-instrucción a cada par 'p'. 'lambda (p)' crea esa instrucción temporal, como un trabajador que procesa cada par.",
        "'(cons (string-append \"mk-\" (car p))' crea un nuevo par. 'car p' obtiene el nombre (por ejemplo, \"gear\"), 'string-append' añade \"mk-\" (dando \"mk-gear\"), y 'cons' construye el nuevo par combinando el nombre modificado con el número que sigue.",
        "'(* (cdr p) 2)))' toma el número con 'cdr' y lo multiplica por 2. Para '(\"gear\" . 4)', da '(\"mk-gear\" . 8)'. Los paréntesis cierran la mini-instrucción y 'map'.",
        "'lst))' aplica 'map' a toda la lista, como procesar todos los productos. Para '((\"gear\" . 4))', da '((\"mk-gear\" . 8))'.",
        "Línea en blanco para separar, manteniendo el código claro.",
        "'(define (fold-suma-cond-anidada lst)' crea una máquina que suma los números de los pares con reglas especiales, como calcular un total con condiciones en una tienda.",
        "'(foldl (lambda (p acc)' usa 'foldl' para acumular un resultado, tomando cada par 'p' y un acumulador 'acc' (inicialmente 0). 'lambda' define cómo combinarlos.",
        "'(let ([val (cdr p)])' asigna el número del par (con 'cdr') a 'val', como guardar el valor en una caja para usarlo varias veces sin repetir 'cdr'.",
        "'(if (even? val)' verifica si 'val' es par (como 4, divisible por 2), usando 'even?'. Es como preguntar '¿es este número divisible por 2?' antes de decidir cómo sumarlo.",
        "'(if (> val 4)' es una segunda condición si 'val' es par, verificando si es mayor que 4, como un filtro adicional.",
        "'(+ acc (* val 2))' suma al acumulador 'acc' el doble de 'val' si es par y mayor que 4. Para 'val' = 8, suma 16.",
        "'(+ acc val))' suma 'val' directamente si es par pero no mayor que 4. Para 'val' = 4, suma 4.",
        "'(+ acc val))))' suma 'val' si no es par, como un caso por defecto. Los paréntesis cierran todas las condiciones y 'lambda'.",
        "'0 lst))' inicia 'foldl' con 0, procesando 'lst'. Para '((\"mk-gear\" . 8))', suma 16 (8 es par, mayor que 4, así que 8 * 2).",
        "Línea en blanco para claridad.",
        "'(define (ajustar-si-mayor-diez n)' crea una máquina que ajusta un número 'n', como aplicar un descuento final si el total es alto.",
        "'(if (> n 10)' verifica si 'n' es mayor que 10, como comprobar si un precio necesita ajuste.",
        "'(- n 5)' resta 5 si 'n' > 10, como un descuento. Para 16, da 11.",
        "'n))' devuelve 'n' sin cambios si no es mayor que 10. Los paréntesis cierran la condición y la función.",
        "Línea en blanco para separar.",
        "'(define (compuesta-cinco lst)' define la máquina principal que combina todas las anteriores, tomando 'lst' como entrada.",
        "'(ajustar-si-mayor-diez (fold-suma-cond-anidada (mapear-mk-duplicar (filtrar-mayor-tres lst)))))' encadena: filtra, mapea, suma con condiciones, ajusta. Los paréntesis anidan el flujo, como pasos en una coreografía.",
        "Línea en blanco para separar la definición de la prueba.",
        "'(compuesta-cinco '((\"gear\" . 4) (\"bolt\" . 2)))' prueba con '((\"gear\" . 4) (\"bolt\" . 2))'. Filtra a '((\"gear\" . 4))', mapea a '((\"mk-gear\" . 8))', suma a 16, ajusta a 11. Es como probar un producto final."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let filtrar_mayor_tres lst =' es como nombrar una receta 'filtrar_mayor_tres' que toma 'lst', una lista de pares como '[(\"gear\", 4); (\"bolt\", 2)]'. 'let' define la instrucción, y la receta filtra pares donde el número es mayor que 3, como seleccionar productos pesados.",
        "'List.filter (fun (_, v) -> v > 3) lst' usa 'List.filter' para revisar cada par. '(fun (_, v) -> v > 3)' es una mini-instrucción que ignora el nombre con '_' y toma el número 'v', verificando si es mayor que 3 con '->' indicando el resultado (verdadero/falso). Para '[(\"gear\", 4); (\"bolt\", 2)]', da '[(\"gear\", 4)]'. No hay paréntesis extras, porque OCaml es lineal.",
        "';;' cierra la definición, como un punto final que dice 'esta receta termina'. Se usa en cada 'let' en OCaml para separar funciones, evitando que la computadora mezcle instrucciones. Sin ';;', el código podría fallar. No programa un juego de carreras, pero es crucial para que el código sea claro, como un sello que asegura cada paso.",
        "Línea en blanco para organizar, como un espacio en un libro.",
        "'let mapear_mk_duplicar lst =' define una receta que transforma pares, añadiendo \"mk-\" al nombre y duplicando el número.",
        "'List.map (fun (n, v) -> (\"mk-\" ^ n, v * 2)) lst' usa 'List.map' para aplicar una transformación a cada par. '(fun (n, v) -> (\"mk-\" ^ n, v * 2))' toma el nombre 'n' y número 'v', devolviendo un nuevo par con \"mk-\" añadido ('^' une cadenas) y 'v' multiplicado por 2. Para '[(\"gear\", 4)]', da '[(\"mk-gear\", 8)]'.",
        "';;' cierra, separando la receta.",
        "Línea en blanco para claridad.",
        "'let fold_suma_cond_anidada lst =' define una receta que suma números con condiciones, como calcular un total con reglas.",
        "'List.fold_left (fun acc (_, val_) ->' usa 'List.fold_left' para acumular, con 'acc' como acumulador y '(_, val_)' ignorando el nombre del par, tomando el número 'val_'.",
        "'if val_ mod 2 = 0 then' verifica si 'val_' es par (resto 0 al dividir por 2, con 'mod'). Es como preguntar '¿es divisible por 2?'",
        "'if val_ > 4 then' verifica si el par es mayor que 4, como un filtro adicional.",
        "'acc + (val_ * 2)' suma el doble de 'val_' si es par y mayor que 4. Para 'val_' = 8, suma 16.",
        "'else acc + val_' suma 'val_' si es par pero no mayor que 4.",
        "'else acc + val_' suma 'val_' si no es par, como caso por defecto.",
        "') 0 lst' inicia con 0, procesando 'lst'. Para '[(\"mk-gear\", 8)]', suma 16.",
        "';;' cierra, marcando el fin.",
        "Línea en blanco para organizar.",
        "'let ajustar_si_mayor_diez n =' define una receta que ajusta 'n' si es mayor que 10.",
        "'if n > 10 then n - 5 else n' resta 5 si 'n' > 10, sino devuelve 'n'. Para 16, da 11.",
        "';;' cierra, separando la receta.",
        "Línea en blanco para claridad.",
        "'let compuesta_cinco lst =' define la receta principal que combina todas.",
        "'ajustar_si_mayor_diez (fold_suma_cond_anidada (mapear_mk_duplicar (filtrar_mayor_tres lst)))' encadena: filtra, mapea, suma, ajusta.",
        "';;' cierra, asegurando separación.",
        "Línea en blanco para separar.",
        "'compuesta_cinco [(\"gear\", 4); (\"bolt\", 2)]' prueba, dando 11 (filtra '[(\"gear\", 4)]', mapea '[(\"mk-gear\", 8)]', suma 16, ajusta 11)."
      ],
      "comparisons": [
        "Similitudes: Ambas filtran pares con números mayores que 3, usando una herramienta (filter) para seleccionar elementos. Diferencias: Racket usa 'define' con 'filter' y 'lambda', estructurando con paréntesis. OCaml usa 'let' con 'List.filter' y 'fun', accediendo al módulo 'List'. Racket es más intuitivo sin módulos, OCaml organiza herramientas pero requiere saber de 'List'.",
        "Similitudes: Verifican números > 3. Diferencias: Racket usa '(> (cdr p) 3)' con 'cdr' para el número, prefijo. OCaml usa '(_, v) -> v > 3', ignorando el nombre con '_', infijo. OCaml es más matemático, Racket más estructurado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', cerrando paréntesis. OCaml usa ';;', separando funciones, esencial para evitar errores, no para juegos sino para claridad en OCaml.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna; ambas separan visualmente.",
        "Similitudes: Transforman pares con mapeo. Diferencias: Racket usa 'define map lambda', OCaml 'let List.map fun'. Racket anidado, OCaml con módulo 'List'.",
        "Similitudes: Modifican nombre y número. Diferencias: Racket usa 'cons string-append car cdr', OCaml '(\"mk-\" ^ n, v * 2)'. Racket más explícito, OCaml compacto con '^'.",
        "Similitudes: Completan mapeo. Diferencias: Racket cierra con ')', OCaml no necesita cierre extra en el cuerpo.",
        "Similitudes: Aplican mapeo a lista. Diferencias: Racket 'lst))', OCaml 'lst'. Racket más anidado, OCaml lineal.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Suman con condiciones. Diferencias: Racket usa 'define foldl lambda let', OCaml 'let List.fold_left fun'. Racket más estructurado, OCaml modular.",
        "Similitudes: Acumuladores. Diferencias: Racket 'lambda (p acc)', OCaml 'fun acc (_, val_)'. OCaml ignora nombre explícitamente.",
        "Similitudes: Usan variables locales. Diferencias: Racket 'let [val (cdr p)]', OCaml usa 'val_' directamente. Racket explícito, OCaml implícito.",
        "Similitudes: Verifican paridad. Diferencias: Racket 'even?', OCaml 'mod 2 = 0'. OCaml más matemático, Racket más directo.",
        "Similitudes: Condición > 4. Diferencias: Racket '(> val 4)', OCaml 'val_ > 4'. OCaml infijo, Racket prefijo.",
        "Similitudes: Suman doble si par y > 4. Diferencias: Racket '(+ acc (* val 2))', OCaml 'acc + (val_ * 2)'. OCaml más legible, Racket estructurado.",
        "Similitudes: Suman si par no > 4. Diferencias: Racket '(+ acc val)', OCaml 'acc + val_'. Similar, pero OCaml infijo.",
        "Similitudes: Suman si no par. Diferencias: Racket '(+ acc val)', OCaml 'acc + val_'. Misma lógica, distinta sintaxis.",
        "Similitudes: Inician con 0. Diferencias: Racket '0 lst))', OCaml ') 0 lst'. Racket más anidado, OCaml lineal.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', esencial para separar en OCaml, no para juegos sino para orden.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Ajustan si > 10. Diferencias: Racket 'define if', OCaml 'let if'. Racket anidado, OCaml lineal.",
        "Similitudes: Condición > 10, resta 5. Diferencias: Racket '(- n 5)', OCaml 'n - 5'. OCaml infijo, Racket prefijo.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', para separación en OCaml.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket 'define' anidado, OCaml 'let' lineal. Racket visual, OCaml compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket paréntesis anidados, OCaml menos paréntesis. Racket claro en flujo, OCaml minimalista.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', esencial para OCaml.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Prueban con lista equivalente, dando 11. Diferencias: Racket '(\"gear\" . 4)', OCaml '(\"gear\", 4)'. Racket usa '.', OCaml ',' y ';'. Racket uniforme, OCaml variado."
      ]
    },
    "ejercicio-6": {
      "title": "Componer filtrado de suma par, mapeo a regiones, conteo de 'este' y clasificación final",
      "racket": {
        "lines": [
          "(define (filtrar-suma-par lst)",
          "  (filter (lambda (p) (even? (+ (car p) (cdr p)))) lst))",
          "",
          "(define (mapear-regiones lst)",
          "  (map (lambda (p)",
          "         (let ([x (car p)] [y (cdr p)])",
          "           (string-append (if (> x 0) \"este-\" \"oeste-\")",
          "                          (if (> y 0) \"norte\" \"sur\"))))",
          "       lst))",
          "",
          "(define (fold-contar-este lst)",
          "  (foldl (lambda (s acc)",
          "           (if (string-prefix? s \"este\")",
          "               (if (string-suffix? s \"norte\")",
          "                   (+ acc 2)",
          "                   (+ acc 1))",
          "               acc))",
          "         0 lst))",
          "",
          "(define (clasificar-total n)",
          "  (if (> n 5)",
          "      \"vasto\"",
          "      \"pequeño\"))",
          "",
          "(define (compuesta-seis lst)",
          "  (clasificar-total (fold-contar-este (mapear-regiones (filtrar-suma-par lst)))))",
          "",
          "(compuesta-seis '((1 . 1) (2 . 2) (3 . 3)))"
        ]
      },
      "ocaml": {
        "lines": [
          "let filtrar_suma_par lst =",
          "  List.filter (fun (x, y) -> (x + y) mod 2 = 0) lst",
          ";;",
          "",
          "let mapear_regiones lst =",
          "  List.map (fun (x, y) ->",
          "    (if x > 0 then \"este-\" else \"oeste-\") ^ (if y > 0 then \"norte\" else \"sur\")",
          "  ) lst",
          ";;",
          "",
          "let fold_contar_este lst =",
          "  List.fold_left (fun acc s ->",
          "    if String.starts_with ~prefix:\"este\" s then",
          "      if String.ends_with ~suffix:\"norte\" s then",
          "        acc + 2",
          "      else",
          "        acc + 1",
          "    else",
          "      acc",
          "  ) 0 lst",
          ";;",
          "",
          "let clasificar_total n =",
          "  if n > 5 then \"vasto\" else \"pequeño\"",
          ";;",
          "",
          "let compuesta_seis lst =",
          "  clasificar_total (fold_contar_este (mapear_regiones (filtrar_suma_par lst)))",
          ";;",
          "",
          "compuesta_seis [(1, 1); (2, 2); (3, 3)]"
        ]
      },
      "explanations_racket": [
        "Imagina que estás explorando un mapa de un mundo fantástico, y el código es como un conjunto de instrucciones para un cartógrafo que organiza territorios. La línea '(define (filtrar-suma-par lst)' es como nombrar una máquina llamada 'filtrar-suma-par'. La palabra 'define' le dice a la computadora que estás creando una nueva instrucción. 'lst' es una lista de pares de coordenadas, como '((1 . 1) (2 . 2) (3 . 3))', donde cada par es como una marca en el mapa con coordenadas x y y. Esta máquina filtra los pares cuya suma x+y es par, como elegir solo ciertos puntos del mapa que cumplen una regla especial. En programación, filtrar es útil para seleccionar datos específicos, como elegir ubicaciones relevantes.",
        "'(filter (lambda (p) (even? (+ (car p) (cdr p)))) lst))' usa 'filter', una herramienta que actúa como un colador para elegir pares 'p' de 'lst' según una condición. La condición es '(lambda (p) (even? (+ (car p) (cdr p))))', una mini-instrucción que toma un par 'p', usa 'car p' para obtener x (como 1 en '(1 . 1)') y 'cdr p' para y (como 1), suma con '+', y verifica con 'even?' si el resultado es par (divisible por 2). Para '((1 . 1) (2 . 2) (3 . 3))', suma 1+1=2, 2+2=4, 3+3=6 (todos pares), así que todos pasan, dando la misma lista. Los paréntesis anidan los pasos, como una lista de tareas clara, asegurando que la computadora siga el orden.",
        "Línea en blanco, como un espacio en un cuaderno para separar instrucciones, haciendo el código más legible, como dividir secciones en un mapa.",
        "'(define (mapear-regiones lst)' crea una máquina que convierte cada par de coordenadas en una región, como nombrar áreas en un mapa (este-norte, oeste-sur, etc.).",
        "'(map (lambda (p)' usa 'map', una herramienta que aplica una transformación a cada par 'p' en 'lst'. 'lambda (p)' crea una mini-instrucción para procesar cada par, como un cartógrafo etiquetando cada punto.",
        "'(let ([x (car p)] [y (cdr p)])' guarda x y y del par 'p' (usando 'car' y 'cdr') en variables, como anotar las coordenadas en una libreta para usarlas fácilmente sin repetir cálculos.",
        "'(string-append (if (> x 0) \"este-\" \"oeste-\")' une una cadena según x. 'if (> x 0)' verifica si x es positivo; si sí, usa \"este-\", si no, \"oeste-\". Es como decidir si un punto está al este o al oeste del centro del mapa.",
        "'(if (> y 0) \"norte\" \"sur\"))))' añade otra cadena según y. Si y es positivo, usa \"norte\", si no, \"sur\", completando la región (por ejemplo, \"este-norte\"). 'string-append' une ambas partes, como escribir el nombre completo de una región.",
        "'lst))' aplica 'map' a toda la lista. Para '((1 . 1))', da '(\"este-norte\")'.",
        "Línea en blanco para organizar, como un espacio en un libro de mapas.",
        "'(define (fold-contar-este lst)' crea una máquina que cuenta regiones que empiezan con \"este\", con reglas especiales, como contar áreas importantes en el mapa.",
        "'(foldl (lambda (s acc)' usa 'foldl' para acumular un conteo, tomando cada cadena 's' (como \"este-norte\") y un acumulador 'acc' (inicialmente 0). 'lambda' define cómo actualizar 'acc'.",
        "'(if (string-prefix? s \"este\")' verifica si 's' empieza con \"este\", usando 'string-prefix?'. Es como preguntar '¿es esta región del este?'",
        "'(if (string-suffix? s \"norte\")' verifica si 's' termina con \"norte\", usando 'string-suffix?'. Es un filtro adicional, como preguntar '¿y está al norte?'",
        "'(+ acc 2)' suma 2 a 'acc' si la región es \"este-norte\", como dar más peso a ciertas áreas.",
        "'(+ acc 1))' suma 1 si es \"este\" pero no \"norte\" (como \"este-sur\").",
        "'acc))' deja 'acc' sin cambios si no es \"este\", como ignorar otras regiones.",
        "'0 lst))' inicia con 0, procesando 'lst'. Para '(\"este-norte\")', suma 2.",
        "Línea en blanco para claridad.",
        "'(define (clasificar-total n)' crea una máquina que clasifica el conteo 'n' como \"vasto\" o \"pequeño\", como decidir si el mapa cubre un área grande.",
        "'(if (> n 5)' verifica si 'n' es mayor que 5, como comprobar si el conteo es significativo.",
        "'\"vasto\"' devuelve \"vasto\" si 'n' > 5, como decir 'este mapa es grande'.",
        "'\"pequeño\"))' devuelve \"pequeño\" si no, como decir 'es un mapa pequeño'. Los paréntesis cierran la función.",
        "Línea en blanco para separar.",
        "'(define (compuesta-seis lst)' define la máquina principal que combina todas las anteriores, tomando 'lst' como entrada.",
        "'(clasificar-total (fold-contar-este (mapear-regiones (filtrar-suma-par lst)))))' encadena: filtra sumas pares, mapea a regiones, cuenta \"este\", clasifica. Los paréntesis muestran el flujo, como pasos en una danza.",
        "Línea en blanco para separar la definición de la prueba.",
        "'(compuesta-seis '((1 . 1) (2 . 2) (3 . 3)))' prueba con '((1 . 1) (2 . 2) (3 . 3))'. Filtra (todos par), mapea a '(\"este-norte\" \"este-norte\" \"este-norte\")', cuenta 6 (3 * 2), clasifica como \"vasto\". Es como dibujar el mapa final."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let filtrar_suma_par lst =' es como nombrar una receta 'filtrar_suma_par' que toma 'lst', una lista de pares como '[(1, 1); (2, 2); (3, 3)]'. 'let' define la instrucción, y la receta filtra pares donde x+y es par, como seleccionar puntos especiales en un mapa.",
        "'List.filter (fun (x, y) -> (x + y) mod 2 = 0) lst' usa 'List.filter' para revisar cada par '(x, y)'. La mini-instrucción '(fun (x, y) -> (x + y) mod 2 = 0)' suma x+y y usa 'mod 2 = 0' para verificar si es par (resto 0 al dividir por 2). Para '[(1, 1); (2, 2); (3, 3)]', todas las sumas son pares (2, 4, 6), dando la misma lista. '->' indica el resultado (verdadero/falso).",
        "';;' cierra la definición, como un punto final que dice 'esta receta termina'. Se usa en cada 'let' en OCaml para separar funciones, evitando errores. No programa un juego de carreras, pero es crucial para que el código sea claro, como un sello que asegura cada instrucción.",
        "Línea en blanco para organizar, como un espacio en un libro de mapas.",
        "'let mapear_regiones lst =' define una receta que convierte pares en nombres de regiones.",
        "'List.map (fun (x, y) ->' usa 'List.map' para transformar cada par '(x, y)'. '(fun (x, y) ->' crea una mini-instrucción para cada par.",
        "'(if x > 0 then \"este-\" else \"oeste-\") ^ (if y > 0 then \"norte\" else \"sur\")' une dos partes: si x > 0, usa \"este-\", si no, \"oeste-\"; si y > 0, usa \"norte\", si no, \"sur\". '^' une las cadenas. Para '(1, 1)', da \"este-norte\".",
        "') lst' aplica 'map' a 'lst', dando '[\"este-norte\"; \"este-norte\"; \"este-norte\"]' para '[(1, 1); (2, 2); (3, 3)]'.",
        "';;' cierra, separando la receta.",
        "Línea en blanco para claridad.",
        "'let fold_contar_este lst =' define una receta que cuenta regiones \"este\", con reglas especiales.",
        "'List.fold_left (fun acc s ->' usa 'List.fold_left' para acumular, tomando 'acc' (inicialmente 0) y cada cadena 's'.",
        "'if String.starts_with ~prefix:\"este\" s then' verifica si 's' empieza con \"este\", usando 'String.starts_with'.",
        "'if String.ends_with ~suffix:\"norte\" s then' verifica si termina con \"norte\".",
        "'acc + 2' suma 2 si es \"este-norte\".",
        "'else acc + 1' suma 1 si es \"este\" pero no \"norte\".",
        "'else acc' deja 'acc' si no es \"este\".",
        "') 0 lst' inicia con 0, procesando 'lst'. Para '[\"este-norte\"; \"este-norte\"; \"este-norte\"]', suma 6 (3 * 2).",
        "';;' cierra, marcando el fin.",
        "Línea en blanco para organizar.",
        "'let clasificar_total n =' define una receta que clasifica 'n' como \"vasto\" o \"pequeño\".",
        "'if n > 5 then \"vasto\" else \"pequeño\"' devuelve \"vasto\" si 'n' > 5, sino \"pequeño\". Para 6, da \"vasto\".",
        "';;' cierra, separando.",
        "Línea en blanco para claridad.",
        "'let compuesta_seis lst =' define la receta principal.",
        "'clasificar_total (fold_contar_este (mapear_regiones (filtrar_suma_par lst)))' encadena las funciones.",
        "';;' cierra, esencial para OCaml.",
        "Línea en blanco para separar.",
        "'compuesta_seis [(1, 1); (2, 2); (3, 3)]' prueba, dando \"vasto\" (filtra todos, mapea a '[\"este-norte\"]', cuenta 6, clasifica \"vasto\")."
      ],
      "comparisons": [
        "Similitudes: Ambas filtran pares con suma par, usando una herramienta (filter) para seleccionar. Diferencias: Racket usa 'define' con 'filter' y 'lambda', estructurando con paréntesis. OCaml usa 'let' con 'List.filter' y 'fun', accediendo a 'List'. Racket es más intuitivo sin módulos, OCaml organiza herramientas pero requiere saber de 'List'.",
        "Similitudes: Verifican paridad de suma. Diferencias: Racket usa '(even? (+ (car p) (cdr p)))', prefijo con 'car' y 'cdr'. OCaml usa '(x + y) mod 2 = 0', infijo con 'mod'. OCaml más matemático, Racket más estructurado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', cerrando paréntesis. OCaml usa ';;', separando funciones, esencial para evitar errores, no para juegos sino para claridad en OCaml.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna; ambas separan visualmente.",
        "Similitudes: Mapean pares a regiones. Diferencias: Racket usa 'define map lambda let', OCaml 'let List.map fun'. Racket anidado, OCaml con módulo 'List'.",
        "Similitudes: Procesan coordenadas. Diferencias: Racket usa 'let [x (car p)] [y (cdr p)]', OCaml usa '(x, y)' directamente. OCaml más directo, Racket explícito.",
        "Similitudes: Construyen nombres de regiones. Diferencias: Racket usa 'string-append' con 'if', OCaml usa '^' con 'then/else'. OCaml más compacto, Racket más explícito.",
        "Similitudes: Completan mapeo. Diferencias: Racket cierra con ')', OCaml con ') lst'. Racket más anidado, OCaml lineal.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Cuentan regiones \"este\". Diferencias: Racket usa 'define foldl lambda', OCaml 'let List.fold_left fun'. Racket estructurado, OCaml modular.",
        "Similitudes: Acumuladores. Diferencias: Racket 'lambda (s acc)', OCaml 'fun acc s'. OCaml invierte orden, pero igual lógica.",
        "Similitudes: Verifican prefijo \"este\". Diferencias: Racket 'string-prefix?', OCaml 'String.starts_with ~prefix'. OCaml usa módulo, Racket directo.",
        "Similitudes: Verifican sufijo \"norte\". Diferencias: Racket 'string-suffix?', OCaml 'String.ends_with ~suffix'. Misma idea, distinta sintaxis.",
        "Similitudes: Suman 2 para \"este-norte\". Diferencias: Racket '(+ acc 2)', OCaml 'acc + 2'. OCaml infijo, Racket prefijo.",
        "Similitudes: Suman 1 para \"este\" no \"norte\". Diferencias: Racket '(+ acc 1)', OCaml 'acc + 1'. OCaml más matemático.",
        "Similitudes: Ignoran no \"este\". Diferencias: Racket 'acc', OCaml 'acc'. Ninguna significativa.",
        "Similitudes: Inician con 0. Diferencias: Racket '0 lst))', OCaml ') 0 lst'. Racket más anidado, OCaml lineal.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', esencial para separar en OCaml, no para juegos sino para orden.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Clasifican conteo. Diferencias: Racket 'define if', OCaml 'let if'. Racket anidado, OCaml lineal.",
        "Similitudes: Condición > 5. Diferencias: Racket '(> n 5)', OCaml 'n > 5'. OCaml infijo, Racket prefijo.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', para separación en OCaml.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket 'define' anidado, OCaml 'let' lineal. Racket visual, OCaml compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket paréntesis anidados, OCaml menos paréntesis. Racket claro en flujo, OCaml minimalista.",
        "Similitudes: Cierres. Diferencias: Racket ')', OCaml ';;', esencial para OCaml.",
        "Similitudes: Líneas en blanco. Diferencias: Ninguna.",
        "Similitudes: Prueban con lista equivalente, dando \"vasto\". Diferencias: Racket '(1 . 1)', OCaml '(1, 1)'. Racket usa '.', OCaml ',' y ';'. Racket uniforme, OCaml variado."
      ]
    },
    "ejercicio-7": {
      "title": "Componer filtrado de triples, aumento de potencia, cálculo de energía, ajuste impar y categorización de nivel",
      "racket": {
        "lines": [
          "(define (filtrar-potencia-tipo lst)",
          "  (filter (lambda (t)",
          "            (let ([pot (cadr t)] [tip (caddr t)])",
          "              (and (> pot 2)",
          "                   (or (string=? tip \"fuego\")",
          "                       (string=? tip \"agua\")))))",
          "          lst))",
          "",
          "(define (mapear-aumentar-potencia lst)",
          "  (map (lambda (t)",
          "         (let ([hec (car t)] [pot (cadr t)] [tip (caddr t)])",
          "           (list hec",
          "                 (if (string=? tip \"fuego\")",
          "                     (* pot 2)",
          "                     (* pot 3))",
          "                 tip)))",
          "       lst))",
          "",
          "(define (fold-energia-cond-mult lst)",
          "  (foldl (lambda (t acc)",
          "           (let ([pot (cadr t)])",
          "             (if (even? pot)",
          "                 (+ acc pot)",
          "                 (let ([mult (* pot 1.5)])",
          "                   (if (> mult 10)",
          "                       (+ acc (- mult 5))",
          "                       (+ acc mult))))))",
          "         0 lst))",
          "",
          "(define (ajustar-impar n)",
          "  (if (odd? n)",
          "      (+ n 1)",
          "      (- n 1)))",
          "",
          "(define (categorizar-nivel n)",
          "  (cond [(> n 20) \"epico\"]",
          "        [(> n 10) \"avanzado\"]",
          "        [else \"basico\"]))",
          "",
          "(define (compuesta-siete lst)",
          "  (categorizar-nivel (ajustar-impar (fold-energia-cond-mult (mapear-aumentar-potencia (filtrar-potencia-tipo lst)))))",
          "",
          "(compuesta-siete '((\"rayo\" 3 \"fuego\") (\"ola\" 1 \"agua\") (\"viento\" 4 \"aire\")))"
        ]
      },
      "ocaml": {
        "lines": [
          "let filtrar_potencia_tipo lst =",
          "  List.filter (fun (_, pot, tip) ->",
          "    pot > 2 && (tip = \"fuego\" || tip = \"agua\")",
          "  ) lst",
          ";;",
          "",
          "let mapear_aumentar_potencia lst =",
          "  List.map (fun (hec, pot, tip) ->",
          "    (hec, if tip = \"fuego\" then pot * 2 else pot * 3, tip)",
          "  ) lst",
          ";;",
          "",
          "let fold_energia_cond_mult lst =",
          "  List.fold_left (fun acc (_, pot, _) ->",
          "    if pot mod 2 = 0 then",
          "      acc + pot",
          "    else",
          "      let mult = int_of_float (float_of_int pot *. 1.5) in",
          "      if mult > 10 then",
          "        acc + (mult - 5)",
          "      else",
          "        acc + mult",
          "  ) 0 lst",
          ";;",
          "",
          "let ajustar_impar n =",
          "  if n mod 2 = 1 then n + 1 else n - 1",
          ";;",
          "",
          "let categorizar_nivel n =",
          "  if n > 20 then \"epico\"",
          "  else if n > 10 then \"avanzado\"",
          "  else \"basico\"",
          ";;",
          "",
          "let compuesta_siete lst =",
          "  categorizar_nivel (ajustar_impar (fold_energia_cond_mult (mapear_aumentar_potencia (filtrar_potencia_tipo lst))))",
          ";;",
          "",
          "compuesta_siete [(\"rayo\", 3, \"fuego\"); (\"ola\", 1, \"agua\"); (\"viento\", 4, \"aire\")]"
        ]
      },
      "explanations_racket": [
        "Imagina que estás en una academia de hechicería cuántica, y el código es un libro de hechizos. La línea '(define (filtrar-potencia-tipo lst)' es como nombrar un hechizo 'filtrar-potencia-tipo'. 'define' le dice a la computadora que creas una nueva instrucción. 'lst' es una lista de triples, como '((\"rayo\" 3 \"fuego\") (\"ola\" 1 \"agua\") (\"viento\" 4 \"aire\"))', donde cada triple tiene un hechizo (cadena), potencia (número) y tipo (cadena). Este hechizo filtra triples con potencia mayor a 2 y tipo 'fuego' o 'agua', como elegir hechizos poderosos para una batalla. En programación, filtrar selecciona datos específicos, útil para procesar solo lo relevante, como en bases de datos o juegos de rol.",
        "'(filter (lambda (t)' usa 'filter', una herramienta que actúa como un colador para elegir triples 't' de 'lst' según una condición. 'lambda (t)' crea una mini-instrucción para cada triple, como un mago revisando cada hechizo uno por uno.",
        "'(let ([pot (cadr t)] [tip (caddr t)])' guarda la potencia ('cadr t', segundo elemento) y el tipo ('caddr t', tercero) en variables 'pot' y 'tip'. Es como anotar en un pergamino el poder y elemento del hechizo para usarlos sin repetir cálculos. Esto ahorra tiempo y hace el código más claro.",
        "'(and (> pot 2)' verifica si 'pot' es mayor que 2, como preguntar '¿es este hechizo lo bastante poderoso?'. 'and' combina condiciones para que ambas se cumplan, como un filtro estricto en una selección mágica.",
        "'(or (string=? tip \"fuego\")' verifica si 'tip' es \"fuego\", usando 'string=?'. 'or' permite que pase si esta u otra condición se cumple, como aceptar hechizos de ciertos elementos mágicos.",
        "'(string=? tip \"agua\")))))' verifica si 'tip' es \"agua\", cerrando las condiciones con paréntesis. Para '((\"rayo\" 3 \"fuego\") (\"ola\" 1 \"agua\") (\"viento\" 4 \"aire\"))', solo pasa '(\"rayo\" 3 \"fuego\")' (potencia 3 > 2, tipo \"fuego\"). Esto se usa cuando necesitas limitar datos a criterios específicos, como en simulaciones o análisis.",
        "'lst))' aplica 'filter' a toda la lista, completando el hechizo. Los paréntesis cierran la instrucción, asegurando que la computadora siga el orden, como cerrar un libro de hechizos tras escribir un capítulo.",
        "Línea en blanco, como un espacio en un pergamino para separar hechizos, haciendo el código más legible, como dividir secciones en un libro. En programación, esto organiza el código para evitar confusión.",
        "'(define (mapear-aumentar-potencia lst)' crea un hechizo que transforma cada triple, aumentando la potencia según el tipo, como potenciar hechizos para una batalla épica. Es útil para modificar datos, como ajustar estadísticas en un juego.",
        "'(map (lambda (t)' usa 'map', que aplica una transformación a cada triple 't'. 'lambda (t)' crea una mini-instrucción, como un mago ajustando cada hechizo individualmente.",
        "'(let ([hec (car t)] [pot (cadr t)] [tip (caddr t)])' guarda hechizo ('car t'), potencia ('cadr t') y tipo ('caddr t') en variables, como anotar detalles en un pergamino para trabajar fácilmente sin repetir accesos a la estructura.",
        "'(list hec' inicia un nuevo triple con el mismo hechizo, como mantener el nombre del hechizo sin cambios.",
        "'(if (string=? tip \"fuego\")' verifica si el tipo es \"fuego\", como decidir cómo potenciar según el elemento mágico. Esto es útil para aplicar reglas condicionales en programación, como en sistemas de personalización.",
        "'(* pot 2)' duplica la potencia si es \"fuego\", como darle más fuerza a un hechizo ardiente. Por ejemplo, 3 se convierte en 6.",
        "'(* pot 3))' triplica la potencia si no es \"fuego\" (como \"agua\" o \"aire\" en otros casos), cerrando la condición. Esto permite transformaciones flexibles según el contexto.",
        "'tip)))' completa el triple con el mismo tipo, cerrando la lista. Para '(\"rayo\" 3 \"fuego\")', da '(\"rayo\" 6 \"fuego\")'. Los paréntesis aseguran que el triple se forme correctamente.",
        "'lst))' aplica 'map' a toda la lista, como procesar todos los hechizos seleccionados. Esto es común en programación para transformar datos, como en gráficos o cálculos.",
        "Línea en blanco para separar, manteniendo el código claro, como un espacio entre capítulos en un libro de hechizos.",
        "'(define (fold-energia-cond-mult lst)' crea un hechizo que calcula la energía total de los triples con reglas complejas, como medir el poder combinado de los hechizos. Es útil para acumular valores, como calcular puntajes o recursos en un sistema.",
        "'(foldl (lambda (t acc)' usa 'foldl' para acumular un total, tomando cada triple 't' y un acumulador 'acc' (inicialmente 0). 'lambda' define cómo combinarlos, como un mago sumando energías.",
        "'(let ([pot (cadr t)])' guarda la potencia en 'pot', como anotar el poder de un hechizo para usarlo varias veces sin repetir 'cadr'.",
        "'(if (even? pot)' verifica si 'pot' es par, usando 'even?', como preguntar '¿es este poder estable?' antes de decidir cómo sumarlo.",
        "'(+ acc pot)' suma 'pot' a 'acc' si es par, como añadir energía directa de un hechizo estable. Por ejemplo, para 6, suma 6.",
        "'(let ([mult (* pot 1.5)])' calcula 'pot * 1.5' si es impar, guardando en 'mult', como transformar energía inestable. Esto introduce cálculos condicionales complejos, útiles en simulaciones.",
        "'(if (> mult 10)' verifica si 'mult' es mayor que 10, como comprobar si la energía transformada es excesiva y necesita ajuste.",
        "'(+ acc (- mult 5))' suma 'mult - 5' a 'acc' si 'mult' > 10, como reducir energía alta para balancearla.",
        "'(+ acc mult))))))' suma 'mult' si no, cerrando todas las condiciones y el 'lambda'. Los paréntesis aseguran que cada paso esté claro, como una receta detallada.",
        "'0 lst))' inicia con 0, procesando toda la lista. Para '(\"rayo\" 6 \"fuego\")', suma 6 (par).",
        "Línea en blanco para organizar, como un espacio en un libro para claridad.",
        "'(define (ajustar-impar n)' crea un hechizo que ajusta el total 'n' según si es impar, como equilibrar la energía final de un ritual. Esto es útil para ajustes finales en cálculos, como en estadísticas.",
        "'(if (odd? n)' verifica si 'n' es impar, usando 'odd?', como preguntar '¿necesita este total un ajuste para estabilizarse?'",
        "'(+ n 1)' suma 1 si 'n' es impar, como estabilizar una energía inestable. Por ejemplo, 7 se convierte en 8.",
        "'(- n 1)))' resta 1 si 'n' es par, como ajustar una energía estable. Para 6, da 5. Los paréntesis cierran la condición y la función.",
        "Línea en blanco para separar, manteniendo el código claro.",
        "'(define (categorizar-nivel n)' crea un hechizo que clasifica el total 'n' en niveles (\"epico\", \"avanzado\", \"basico\"), como evaluar el poder de un mago tras un ritual. Es útil para categorizar resultados, como en sistemas de clasificación.",
        "'(cond [(> n 20) \"epico\"]' verifica si 'n' > 20, devolviendo \"epico\", como clasificar un hechizo legendario. 'cond' permite múltiples casos, ideal para decisiones complejas.",
        "'[(> n 10) \"avanzado\"]' verifica si 'n' > 10, devolviendo \"avanzado\", como un hechizo fuerte.",
        "'[else \"basico\"]))' devuelve \"basico\" si ninguna condición se cumple, como un hechizo simple. Los paréntesis cierran el 'cond'.",
        "Línea en blanco para organizar, como un espacio entre hechizos.",
        "'(define (compuesta-siete lst)' define el hechizo principal que combina todos los anteriores, tomando 'lst' como entrada, como un ritual completo que une varios pasos mágicos.",
        "'(categorizar-nivel (ajustar-impar (fold-energia-cond-mult (mapear-aumentar-potencia (filtrar-potencia-tipo lst)))))' encadena los hechizos: filtra, aumenta potencia, calcula energía, ajusta paridad, clasifica. Los paréntesis anidan el flujo, como pasos en una danza mágica, asegurando que cada hechizo reciba el resultado del anterior.",
        "Línea en blanco para separar la definición de la prueba, como un espacio antes de probar un ritual.",
        "'(compuesta-siete '((\"rayo\" 3 \"fuego\") (\"ola\" 1 \"agua\") (\"viento\" 4 \"aire\")))' prueba el hechizo con la lista dada. Filtra a '((\"rayo\" 3 \"fuego\")', aumenta a '((\"rayo\" 6 \"fuego\")', suma 6 (par), ajusta a 5 (par, resta 1), clasifica como \"basico\" (5 ≤ 10). Esto verifica que el ritual funciona, como probar un hechizo en una batalla."
      ],
      "explanations_ocaml": [
        "En OCaml, 'let filtrar_potencia_tipo lst =' es como nombrar un hechizo 'filtrar_potencia_tipo' que toma 'lst', una lista de triples como '[(\"rayo\", 3, \"fuego\"); (\"ola\", 1, \"agua\"); (\"viento\", 4, \"aire\")]'. 'let' define la instrucción, y el hechizo filtra triples con potencia > 2 y tipo \"fuego\" o \"agua\", como elegir hechizos poderosos para un ritual. En programación, esto es útil para seleccionar datos específicos, como en juegos o análisis de datos.",
        "'List.filter (fun (_, pot, tip) ->' usa 'List.filter' para revisar cada triple. '(fun (_, pot, tip) ->' descompone el triple, ignorando el hechizo con '_', tomando potencia 'pot' y tipo 'tip', como un mago revisando solo el poder y elemento de un hechizo.",
        "'pot > 2 && (tip = \"fuego\" || tip = \"agua\")' verifica si 'pot' > 2 y 'tip' es \"fuego\" o \"agua\", usando '&&' (y) y '||' (o). Para '[(\"rayo\", 3, \"fuego\"); (\"ola\", 1, \"agua\"); (\"viento\", 4, \"aire\")]', pasa '[(\"rayo\", 3, \"fuego\")]' (3 > 2, tipo \"fuego\"). Esto es útil para aplicar condiciones combinadas, como filtrar elementos en un inventario.",
        "') lst' aplica 'List.filter' a toda la lista, completando el hechizo, como terminar una selección mágica.",
        "';;' cierra la definición, como un punto final que dice 'este hechizo termina'. Se usa en cada 'let' en OCaml para separar funciones en un archivo o intérprete, evitando que la computadora mezcle instrucciones. Sin ';;', el código podría fallar. No programa un juego de carreras, pero es crucial para que el código sea claro, como un sello que asegura cada instrucción.",
        "Línea en blanco para organizar, como un espacio en un pergamino, haciendo el código más legible, como dividir capítulos.",
        "'let mapear_aumentar_potencia lst =' define un hechizo que transforma triples, aumentando la potencia según el tipo, como potenciar hechizos para una batalla.",
        "'List.map (fun (hec, pot, tip) ->' usa 'List.map' para transformar cada triple '(hec, pot, tip)', como un mago ajustando cada hechizo.",
        "'(hec, if tip = \"fuego\" then pot * 2 else pot * 3, tip)' crea un nuevo triple: mismo 'hec', potencia duplicada si \"fuego\" o triplicada si no, mismo 'tip'. Para '(\"rayo\", 3, \"fuego\")', da '(\"rayo\", 6, \"fuego\")'. Esto es útil para transformar datos, como en sistemas de personalización.",
        "') lst' aplica 'List.map' a toda la lista, como procesar todos los hechizos seleccionados.",
        "';;' cierra la definición, asegurando que la computadora sepa que este hechizo está completo, esencial para evitar errores en OCaml.",
        "Línea en blanco para claridad, como un espacio entre hechizos.",
        "'let fold_energia_cond_mult lst =' define un hechizo que calcula la energía total con reglas complejas, como medir el poder combinado de los hechizos.",
        "'List.fold_left (fun acc (_, pot, _) ->' usa 'List.fold_left' para acumular un total, tomando 'acc' (inicialmente 0) y cada triple, ignorando hechizo y tipo con '_'.",
        "'if pot mod 2 = 0 then' verifica si 'pot' es par, usando 'mod 2 = 0', como preguntar '¿es este poder estable?'",
        "'acc + pot' suma 'pot' a 'acc' si es par, como añadir energía directa. Para 6, suma 6.",
        "'else' indica qué hacer si 'pot' es impar, como manejar energía inestable.",
        "'let mult = int_of_float (float_of_int pot *. 1.5) in' calcula 'pot * 1.5', convirtiendo a float y de vuelta a entero para precisión, guardando en 'mult'. Esto es útil para cálculos precisos en programación, como en simulaciones científicas.",
        "'if mult > 10 then' verifica si 'mult' > 10, como comprobar si la energía transformada es excesiva.",
        "'acc + (mult - 5)' suma 'mult - 5' si 'mult' > 10, como ajustar energía alta.",
        "'else acc + mult' suma 'mult' si no, como usar la energía transformada sin ajuste.",
        "') 0 lst' inicia con 0, procesando toda la lista. Para '[(\"rayo\", 6, \"fuego\")]', suma 6 (par).",
        "';;' cierra la definición, asegurando separación en OCaml, como un sello que completa el hechizo.",
        "Línea en blanco para organizar, como un espacio en un libro.",
        "'let ajustar_impar n =' define un hechizo que ajusta 'n' según si es impar, como equilibrar la energía final.",
        "'if n mod 2 = 1 then n + 1 else n - 1' suma 1 si 'n' es impar (resto 1 al dividir por 2), resta 1 si es par. Para 6, da 5. Esto es útil para ajustes finales, como en cálculos de balance.",
        "';;' cierra, separando la definición, esencial para que OCaml procese correctamente cada hechizo.",
        "Línea en blanco para claridad.",
        "'let categorizar_nivel n =' define un hechizo que clasifica 'n' en niveles (\"epico\", \"avanzado\", \"basico\"), como evaluar el poder de un mago.",
        "'if n > 20 then \"epico\"' devuelve \"epico\" si 'n' > 20, como un hechizo legendario.",
        "'else if n > 10 then \"avanzado\"' devuelve \"avanzado\" si 'n' > 10, como un hechizo fuerte.",
        "'else \"basico\"' devuelve \"basico\" si no, como un hechizo simple. Para 5, da \"basico\".",
        "';;' cierra, asegurando que la definición esté completa, crucial para OCaml.",
        "Línea en blanco para separar, como un espacio entre hechizos.",
        "'let compuesta_siete lst =' define el hechizo principal que combina todos, como un ritual completo.",
        "'categorizar_nivel (ajustar_impar (fold_energia_cond_mult (mapear_aumentar_potencia (filtrar_potencia_tipo lst))))' encadena los hechizos: filtra, aumenta, calcula energía, ajusta, clasifica. Es como un ritual mágico con pasos encadenados.",
        "';;' cierra, asegurando separación en OCaml, como un sello final.",
        "Línea en blanco para organizar.",
        "'compuesta_siete [(\"rayo\", 3, \"fuego\"); (\"ola\", 1, \"agua\"); (\"viento\", 4, \"aire\")]' prueba el hechizo, dando \"basico\". Filtra '[(\"rayo\", 3, \"fuego\")]', aumenta '[(\"rayo\", 6, \"fuego\")]', suma 6, ajusta a 5, clasifica \"basico\". Esto verifica el ritual, como probar un hechizo en una batalla."
      ],
      "comparisons": [
        "Similitudes: Ambas definen funciones para filtrar triples con potencia > 2 y tipo \"fuego\" o \"agua\", usando una herramienta de filtrado. Diferencias: Racket usa 'define' con 'filter' y 'lambda', estructurando con paréntesis. OCaml usa 'let' con 'List.filter' y 'fun', accediendo al módulo 'List'. Racket es más intuitivo sin módulos, OCaml organiza herramientas pero requiere entender 'List'.",
        "Similitudes: Ambas procesan triples. Diferencias: Racket usa 'lambda (t)' con accesos posteriores, OCaml usa '(fun (_, pot, tip) ->' para descomponer directamente. OCaml es más conciso al acceder a elementos, Racket más explícito con 'cadr' y 'caddr'.",
        "Similitudes: Acceden a potencia y tipo. Diferencias: Racket usa 'let [pot (cadr t)] [tip (caddr t)]' para guardar valores, OCaml usa '(_, pot, tip)' directamente. Racket organiza variables explícitamente, OCaml es más directo pero menos estructurado visualmente.",
        "Similitudes: Verifican potencia > 2 y tipo. Diferencias: Racket usa 'and (> pot 2)' con 'string=?', OCaml usa 'pot > 2 && (tip = \"fuego\" || tip = \"agua\")'. OCaml usa operadores matemáticos ('&&', '||'), Racket usa palabras ('and', 'or'), siendo Racket más legible para principiantes.",
        "Similitudes: Completan condiciones de tipo. Diferencias: Racket usa '(or (string=? tip \"fuego\")', OCaml usa '(tip = \"fuego\" ||'. OCaml es más compacto, Racket más estructurado con paréntesis.",
        "Similitudes: Verifican tipo \"agua\". Diferencias: Racket usa '(string=? tip \"agua\")))))', cerrando múltiples paréntesis, OCaml usa 'tip = \"agua\")'. Racket anida más, OCaml es lineal.",
        "Similitudes: Completan filtrado. Diferencias: Racket usa 'lst))', cerrando con paréntesis, OCaml usa ') lst'. Racket más anidado, OCaml más simple sintácticamente.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna; ambas separan visualmente para claridad, como espacios en un libro.",
        "Similitudes: Definen funciones para transformar triples. Diferencias: Racket usa 'define' con 'map' y 'lambda', OCaml usa 'let' con 'List.map' y 'fun'. Racket es más visual con paréntesis, OCaml requiere módulo 'List' pero es más lineal.",
        "Similitudes: Procesan cada triple. Diferencias: Racket usa 'map (lambda (t)', OCaml usa 'List.map (fun (hec, pot, tip) ->'. OCaml descompone directamente, Racket usa 'lambda' genérico.",
        "Similitudes: Acceden a elementos del triple. Diferencias: Racket usa 'let [hec (car t)] [pot (cadr t)] [tip (caddr t)]', OCaml usa '(hec, pot, tip)'. OCaml más conciso, Racket más explícito.",
        "Similitudes: Inician nuevo triple. Diferencias: Racket usa '(list hec', OCaml usa '(hec,'. Racket usa 'list' explícitamente, OCaml usa tupla implícita.",
        "Similitudes: Verifican tipo \"fuego\". Diferencias: Racket usa '(if (string=? tip \"fuego\")', OCaml usa 'if tip = \"fuego\" then'. OCaml más matemático, Racket más estructurado.",
        "Similitudes: Duplican potencia para \"fuego\". Diferencias: Racket usa '(* pot 2)', OCaml usa 'pot * 2'. OCaml infijo, Racket prefijo, pero misma lógica.",
        "Similitudes: Triplican potencia si no es \"fuego\". Diferencias: Racket usa '(* pot 3))', OCaml usa 'else pot * 3'. OCaml más legible, Racket anidado.",
        "Similitudes: Completan triple con tipo. Diferencias: Racket usa 'tip)))', cerrando lista, OCaml usa 'tip)'. Racket más anidado, OCaml más simple.",
        "Similitudes: Completan mapeo. Diferencias: Racket usa 'lst))', OCaml usa ') lst'. Racket anida paréntesis, OCaml es lineal.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna; ambas organizan visualmente.",
        "Similitudes: Calculan energía con condiciones. Diferencias: Racket usa 'define' con 'foldl' y 'lambda', OCaml usa 'let' con 'List.fold_left' y 'fun'. Racket más estructurado, OCaml modular con 'List'.",
        "Similitudes: Acumuladores para triples. Diferencias: Racket usa 'lambda (t acc)', OCaml usa 'fun acc (_, pot, _) ->'. OCaml ignora elementos explícitamente, Racket usa triple genérico.",
        "Similitudes: Acceden a potencia. Diferencias: Racket usa 'let [pot (cadr t)]', OCaml usa '(_, pot, _)'. OCaml más directo, Racket más explícito.",
        "Similitudes: Verifican paridad. Diferencias: Racket usa 'even?', OCaml usa 'mod 2 = 0'. OCaml más matemático, Racket más legible para principiantes.",
        "Similitudes: Suman si par. Diferencias: Racket usa '(+ acc pot)', OCaml usa 'acc + pot'. OCaml infijo, Racket prefijo.",
        "Similitudes: Calculan *1.5 si impar. Diferencias: Racket usa 'let [mult (* pot 1.5)]', OCaml usa 'let mult = int_of_float (float_of_int pot *. 1.5) in'. OCaml maneja conversión float-entero para precisión, Racket más simple pero menos preciso.",
        "Similitudes: Verifican si > 10. Diferencias: Racket usa '(if (> mult 10)', OCaml usa 'if mult > 10 then'. OCaml infijo, Racket prefijo.",
        "Similitudes: Ajustan si > 10. Diferencias: Racket usa '(+ acc (- mult 5))', OCaml usa 'acc + (mult - 5)'. OCaml más legible, Racket más anidado.",
        "Similitudes: Suman sin ajustar. Diferencias: Racket usa '(+ acc mult)', OCaml usa 'acc + mult'. OCaml infijo, Racket prefijo.",
        "Similitudes: Inician con 0. Diferencias: Racket usa '0 lst))', OCaml usa ') 0 lst'. Racket más anidado, OCaml lineal.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Ajustan según paridad. Diferencias: Racket usa 'define' con 'if' y 'odd?', OCaml usa 'let' con 'mod 2 = 1'. Racket más explícito, OCaml más matemático.",
        "Similitudes: Suman/restan 1 según paridad. Diferencias: Racket usa '(+ n 1)' o '(- n 1)', OCaml usa 'n + 1' o 'n - 1'. OCaml infijo, Racket prefijo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', cerrando paréntesis, OCaml usa ';;', separando funciones, esencial para evitar errores en OCaml, no para juegos sino para claridad.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna.",
        "Similitudes: Clasifican nivel con condiciones. Diferencias: Racket usa 'define' con 'cond', OCaml usa 'let' con 'if/else if'. Racket más flexible para múltiples casos, OCaml más lineal y directo.",
        "Similitudes: Verifican > 20. Diferencias: Racket usa '[(> n 20) \"epico\"]', OCaml usa 'if n > 20 then \"epico\"'. OCaml infijo, Racket prefijo y estructurado.",
        "Similitudes: Verifican > 10. Diferencias: Racket usa '[(> n 10) \"avanzado\"]', OCaml usa 'else if n > 10 then \"avanzado\"'. OCaml más lineal, Racket usa 'cond' para claridad.",
        "Similitudes: Devuelven \"basico\" por defecto. Diferencias: Racket usa '[else \"basico\"]', OCaml usa 'else \"basico\"'. Racket anida en 'cond', OCaml usa 'else' simple.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;', esencial para separar funciones en OCaml, no para juegos sino para orden.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket usa 'define' con paréntesis anidados, OCaml usa 'let' con sintaxis lineal. Racket más visual en el flujo, OCaml más compacto.",
        "Similitudes: Encadenan funciones en orden. Diferencias: Racket usa múltiples paréntesis para mostrar el flujo, OCaml usa menos paréntesis, más minimalista. Racket es más explícito en la jerarquía, OCaml más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;', separando funciones, esencial para OCaml para evitar errores, no para juegos sino para claridad.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna.",
        "Similitudes: Prueban con listas equivalentes, dando \"basico\". Diferencias: Racket usa '(\"rayo\" 3 \"fuego\")' con espacios, OCaml usa '(\"rayo\", 3, \"fuego\")' con comas y punto y coma. Racket más uniforme con paréntesis, OCaml más variado en notación."
      ]
    }
  },
  "procesamiento-listas": {
    "ejercicio-1": {
      "title": "Filtrar nombres de criaturas míticas con longitud par para invocar aliados",
      "racket": {
        "lines": [
          "(define (filtrar-longitud-par lst)",
          "  (filter (lambda (s) (even? (string-length s))) lst))",
          "",
          "(filtrar-longitud-par '(\"dragon\" \"elfo\" \"goblin\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "let filtrar_longitud_par lst =",
          "  List.filter (fun s -> String.length s mod 2 = 0) lst",
          "in",
          "filtrar_longitud_par [\"dragon\"; \"elfo\"; \"goblin\"]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un guardián en un mundo de criaturas míticas, seleccionando aliados para una batalla épica. La línea '(define (filtrar-longitud-par lst)' crea un hechizo llamado 'filtrar-longitud-par' que toma una lista 'lst' de nombres de criaturas, como '(\"dragon\" \"elfo\" \"goblin\")'. 'define' le dice a la computadora que estás nombrando una nueva instrucción. Este hechizo filtra nombres con longitud par, como elegir solo ciertas criaturas por un criterio mágico. En programación, esto es útil para seleccionar datos específicos, como en un juego de rol donde eliges aliados según reglas, haciendo el código más relevante para escenarios fantásticos.",
        "'(filter (lambda (s) (even? (string-length s))) lst))' es el núcleo del hechizo. 'filter' actúa como un colador mágico que revisa cada nombre 's' en 'lst'. 'lambda (s)' crea una mini-instrucción que verifica si la longitud del nombre (con 'string-length s') es par (usando 'even?'). Si es par, el nombre pasa; si no, se descarta. Por ejemplo, \"dragon\" (6 letras, par) pasa, pero \"elfo\" (4 letras, par) y \"goblin\" (6 letras, par) también pasan, mientras que otros no lo harían. Esto se usa en juegos o bases de datos para filtrar elementos según propiedades, como nombres o estadísticas. Los paréntesis cierran el 'lambda', 'filter', y la función, como sellar un pergamino mágico.",
        "Línea en blanco, como un espacio en un libro de hechizos para separar ideas, haciendo el código más claro y organizado, como dividir capítulos en un relato mítico. En programación, esto mejora la legibilidad, evitando que el código sea un caos.",
        "'(filtrar-longitud-par '(\"dragon\" \"elfo\" \"goblin\"))' invoca el hechizo con la lista '(\"dragon\" \"elfo\" \"goblin\")'. Filtra los nombres, dejando '(\"elfo\" \"goblin\")' (\"dragon\" tiene 6 letras, \"elfo\" 4, \"goblin\" 6, todos pares). Esto prueba el hechizo, como un guardián comprobando qué criaturas puede invocar. En programación, evalúa si la función trabaja correctamente, útil en pruebas de juegos o sistemas interactivos."
      ],
      "explanations_ocaml": [
        "En el mismo mundo de criaturas míticas, 'let filtrar_longitud_par lst =' es como nombrar un hechizo 'filtrar_longitud_par' que toma una lista 'lst', como '[\"dragon\"; \"elfo\"; \"goblin\"]'. 'let' define la instrucción en OCaml, como inscribir un hechizo en un pergamino. El hechizo filtra nombres con longitud par, como elegir aliados para una misión. Esto es útil en programación para seleccionar datos específicos, como en un juego donde solo ciertas criaturas cumplen un criterio mágico, añadiendo un toque narrativo y didáctico.",
        "'List.filter (fun s -> String.length s mod 2 = 0) lst' es el corazón del hechizo. 'List.filter' revisa cada nombre 's' en 'lst', como un guardián examinando aliados. '(fun s ->' crea una mini-instrucción que calcula la longitud del nombre con 'String.length s' y verifica si es par con 'mod 2 = 0'. Si es par, el nombre pasa; si no, se descarta. Por ejemplo, \"dragon\" (6 letras, par), \"elfo\" (4 letras, par), y \"goblin\" (6 letras, par) pasan. Esto se usa en juegos o sistemas para filtrar datos, como nombres de personajes o ítems. La línea completa aplica el filtro a 'lst'.",
        "'in' conecta la definición del hechizo con su uso, como un sello que prepara el pergamino para ser leído. En OCaml, 'in' indica que la función definida se usará a continuación, asegurando que la computadora entienda el flujo. No programa un juego de carreras, pero es crucial para organizar el código, como un ritual que asegura claridad.",
        "'filtrar_longitud_par [\"dragon\"; \"elfo\"; \"goblin\"]' invoca el hechizo con la lista dada, dando '[\"elfo\"; \"goblin\"]' (todos tienen longitud par). Es como un guardián probando qué criaturas puede invocar. En programación, esto verifica que la función funcione, útil en pruebas de sistemas interactivos, como juegos de rol o bases de datos."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar nombres con longitud par. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con una sintaxis más lineal. Racket es más visual con su estructura de paréntesis, OCaml requiere entender 'List' como módulo, pero es más compacto.",
        "Similitudes: Ambas usan una función de filtrado ('filter'/'List.filter') con una condición de longitud par. Diferencias: Racket usa 'lambda (s)' y 'even? (string-length s)', OCaml usa 'fun s ->' y 'String.length s mod 2 = 0'. Racket es más explícito con 'even?', OCaml usa una expresión matemática más directa, pero ambos logran lo mismo.",
        "Similitudes: Ambas usan líneas en blanco para organizar. Diferencias: Ninguna; ambas separan visualmente para claridad, como espacios en un pergamino.",
        "Similitudes: Ambas evalúan la función con la misma lista, dando '(\"elfo\" \"goblin\")'. Diferencias: Racket usa '(\"dragon\" \"elfo\" \"goblin\")' con paréntesis y espacios, OCaml usa '[\"dragon\"; \"elfo\"; \"goblin\"]' con punto y coma. Racket es más uniforme con paréntesis, OCaml usa notación de lista más variada."
      ]
    },
    "ejercicio-2": {
      "title": "Transformar códigos de navegación a mayúsculas para protocolos de emergencia espacial",
      "racket": {
        "lines": [
          "(define (mayusculas-lista lst)",
          "  (map string-upcase lst))",
          "",
          "(mayusculas-lista '(\"warp\" \"nebula\" \"star\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "let mayusculas_lista lst =",
          "  List.map String.uppercase_ascii lst",
          "in",
          "mayusculas_lista [\"warp\"; \"nebula\"; \"star\"]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un piloto en una aventura espacial, y necesitas transformar códigos de navegación para activar protocolos de emergencia. La línea '(define (mayusculas-lista lst)' crea un hechizo llamado 'mayusculas-lista' que toma una lista 'lst' de códigos, como '(\"warp\" \"nebula\" \"star\")'. 'define' le dice a la computadora que estás creando una nueva instrucción. Este hechizo convierte cada código a mayúsculas, como gritar órdenes en una nave para que el sistema las reconozca. En programación, esto es útil para estandarizar datos, como en juegos de ciencia ficción o interfaces de usuario donde el texto debe ser uniforme.",
        "'(map string-upcase lst))' es el núcleo del hechizo. 'map' actúa como un traductor automático que aplica 'string-upcase' a cada código en 'lst', convirtiendo cadenas como \"warp\" en \"WARP\". Por ejemplo, para '(\"warp\" \"nebula\" \"star\")', produce '(\"WARP\" \"NEBULA\" \"STAR\")'. Esto se usa en sistemas donde el formato importa, como nombres de planetas en un juego de navegación espacial. Los paréntesis cierran 'map' y la función, como sellar un mensaje codificado en una cápsula espacial.",
        "Línea en blanco, como un espacio en un panel de control estelar, separa la definición del hechizo de su prueba, haciendo el código más claro, como organizar botones en una nave. En programación, esto mejora la legibilidad, evitando un código desordenado.",
        "'(mayusculas-lista '(\"warp\" \"nebula\" \"star\"))' invoca el hechizo con la lista dada, dando '(\"WARP\" \"NEBULA\" \"STAR\")'. Es como un piloto probando los códigos transformados en el sistema de la nave. En programación, esto verifica que la función funcione, útil para pruebas en juegos o aplicaciones donde el texto debe procesarse correctamente."
      ],
      "explanations_ocaml": [
        "En la misma aventura espacial, 'let mayusculas_lista lst =' es como nombrar un hechizo 'mayusculas_lista' que toma una lista 'lst', como '[\"warp\"; \"nebula\"; \"star\"]'. 'let' define la instrucción en OCaml, como programar un panel de control en una nave. El hechizo convierte códigos a mayúsculas para protocolos de emergencia, como estandarizar nombres de planetas. Esto es útil en programación para formatear datos, como en juegos de ciencia ficción donde los sistemas requieren texto uniforme, añadiendo un toque inmersivo y didáctico.",
        "'List.map String.uppercase_ascii lst' es el corazón del hechizo. 'List.map' aplica 'String.uppercase_ascii' a cada código en 'lst', transformando \"warp\" en \"WARP\", \"nebula\" en \"NEBULA\", y \"star\" en \"STAR\". Es como un traductor automático en una nave espacial. Esto se usa en interfaces o juegos donde el texto debe ser consistente, como en paneles de navegación. La línea completa aplica el mapeo a 'lst', sin necesidad de paréntesis extras, manteniendo la sintaxis limpia.",
        "'in' conecta la definición del hechizo con su uso, como encender un interruptor en la nave para activar el protocolo. En OCaml, 'in' indica que la función definida se usará inmediatamente después, asegurando que la computadora entienda el flujo. No programa un juego de carreras, pero es crucial para organizar el código, como un botón que activa una secuencia en una nave.",
        "'mayusculas_lista [\"warp\"; \"nebula\"; \"star\"]' invoca el hechizo con la lista dada, dando '[\"WARP\"; \"NEBULA\"; \"STAR\"]'. Es como un piloto probando los códigos en el sistema de navegación. En programación, esto verifica que la función funcione, útil para pruebas en sistemas interactivos, como juegos o aplicaciones de texto."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para transformar códigos a mayúsculas usando una herramienta de mapeo. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con una sintaxis más lineal. Racket es más visual con su estructura anidada, OCaml es más compacto pero requiere entender el módulo 'List'.",
        "Similitudes: Ambas usan una función de mapeo ('map'/'List.map') para aplicar una transformación de mayúsculas. Diferencias: Racket usa 'map string-upcase', OCaml usa 'List.map String.uppercase_ascii'. Racket es más directo al usar 'string-upcase' sin módulos, OCaml requiere 'String.uppercase_ascii' y es más explícito sobre el módulo, pero ambos logran el mismo resultado.",
        "Similitudes: Ambas usan líneas en blanco para organizar el código. Diferencias: Ninguna; ambas separan visualmente la definición de la evaluación, como espacios en un panel de control.",
        "Similitudes: Ambas evalúan la función con la misma lista, dando '(\"WARP\" \"NEBULA\" \"STAR\")'. Diferencias: Racket usa '(\"warp\" \"nebula\" \"star\")' con paréntesis y espacios, OCaml usa '[\"warp\"; \"nebula\"; \"star\"]' con punto y coma. Racket es más uniforme con paréntesis, OCaml usa una notación de lista más variada."
      ]
    },
    "ejercicio-3": {
      "title": "Filtrar pistas con vocal inicial y añadir prefijo 'clue-' en un laberinto encantado",
      "racket": {
        "lines": [
          "(define (vocal-inicial? s)",
          "  (member (string-ref (string-downcase s) 0) '(#\\a #\\e #\\i #\\o #\\u)))",
          "",
          "(define (filtrar-vocal-inicial lst)",
          "  (filter vocal-inicial? lst))",
          "",
          "(define (añadir-prefijo-clue lst)",
          "  (map (lambda (s) (string-append \"clue-\" s)) lst))",
          "",
          "(define (compuesta-tres lst)",
          "  (añadir-prefijo-clue (filtrar-vocal-inicial lst)))",
          "",
          "(compuesta-tres '(\"apple\" \"banana\" \"cherry\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "let vocal_inicial s =",
          "  List.mem (Char.lowercase_ascii s.[0]) ['a'; 'e'; 'i'; 'o'; 'u']",
          ";;",
          "",
          "let filtrar_vocal_inicial lst =",
          "  List.filter vocal_inicial lst",
          ";;",
          "",
          "let añadir_prefijo_clue lst =",
          "  List.map (fun s -> \"clue-\" ^ s) lst",
          ";;",
          "",
          "let compuesta_tres lst =",
          "  añadir_prefijo_clue (filtrar_vocal_inicial lst)",
          ";;",
          "",
          "compuesta_tres [\"apple\"; \"banana\"; \"cherry\"]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un explorador en un laberinto encantado, buscando pistas para encontrar la salida. La línea '(define (vocal-inicial? s)' crea un hechizo auxiliar llamado 'vocal-inicial?' que toma una cadena 's', como \"apple\". 'define' le dice a la computadora que estás nombrando una nueva instrucción. Este hechizo verifica si la primera letra de 's' es una vocal, como seleccionar pistas mágicas con un poder especial. En programación, esto es útil para validar propiedades de datos, como en un juego de puzzles donde solo ciertas palabras son válidas.",
        "'(member (string-ref (string-downcase s) 0) '(#\\a #\\e #\\i #\\o #\\u)))' revisa si la primera letra de 's' (convertida a minúsculas con 'string-downcase' y extraída con 'string-ref 0') está en la lista de vocales '(#\\a #\\e #\\i #\\o #\\u)'. Por ejemplo, para \"apple\", 'a' es una vocal, así que devuelve verdadero. Esto se usa para filtrar datos según condiciones específicas, como en sistemas de búsqueda o juegos. Los paréntesis cierran 'member' y la función, como sellar un pergamino con una runa mágica.",
        "Línea en blanco, como un espacio en un mapa del laberinto, separa hechizos para mantener el código claro, como dividir secciones en un libro de aventuras. Esto mejora la legibilidad en programación.",
        "'(define (filtrar-vocal-inicial lst)' crea un hechizo 'filtrar-vocal-inicial' que toma una lista 'lst', como '(\"apple\" \"banana\" \"cherry\")'. Este hechizo filtra palabras que comienzan con vocal, como elegir pistas válidas para avanzar en el laberinto. Es útil para seleccionar subconjuntos de datos, como en juegos de rol o bases de datos.",
        "'(filter vocal-inicial? lst))' aplica 'filter' para usar 'vocal-inicial?' en cada elemento de 'lst', dejando solo palabras con vocal inicial, como \"apple\" y \"cherry\". 'filter' es como un colador mágico que descarta pistas inválidas. Esto se usa en sistemas donde necesitas datos específicos, como en un juego de puzzles. Los paréntesis cierran 'filter' y la función, como cerrar un cofre del tesoro.",
        "Línea en blanco para organizar, como un respiro en el laberinto, manteniendo el código claro.",
        "'(define (añadir-prefijo-clue lst)' crea un hechizo 'añadir-prefijo-clue' que toma una lista 'lst'. Este hechizo agrega el prefijo \"clue-\" a cada palabra, como marcar pistas para el mapa del laberinto. Es útil para transformar datos, como en interfaces o juegos donde etiquetas elementos.",
        "'(map (lambda (s) (string-append \"clue-\" s)) lst))' usa 'map' para aplicar 'string-append' a cada palabra, añadiendo \"clue-\" (e.g., \"apple\" se convierte en \"clue-apple\"). 'lambda (s)' crea una mini-instrucción para cada palabra. Esto se usa en sistemas de formato, como en juegos narrativos. Los paréntesis cierran 'lambda', 'map', y la función, como sellar un mapa encantado.",
        "Línea en blanco para separar, como un espacio en el pergamino del explorador.",
        "'(define (compuesta-tres lst)' crea un hechizo 'compuesta-tres' que combina los pasos anteriores, tomando 'lst' y encadenando los hechizos para filtrar y transformar pistas. Es como un ritual completo para resolver un acertijo en el laberinto.",
        "'(añadir-prefijo-clue (filtrar-vocal-inicial lst)))' encadena 'filtrar-vocal-inicial' y 'añadir-prefijo-clue', primero filtrando palabras con vocal inicial y luego añadiendo \"clue-\". Para '(\"apple\" \"banana\" \"cherry\")', da '(\"clue-apple\" \"clue-cherry\")'. Esto se usa en flujos de procesamiento, como en juegos o pipelines de datos. Los paréntesis cierran la composición y la función, como completar un ritual mágico.",
        "Línea en blanco para organizar, como un espacio antes de probar el mapa.",
        "'(compuesta-tres '(\"apple\" \"banana\" \"cherry\"))' invoca el hechizo con la lista dada, dando '(\"clue-apple\" \"clue-cherry\")'. Es como un explorador probando las pistas en el laberinto. En programación, esto verifica que la función compuesta funcione, útil para pruebas en juegos o sistemas interactivos."
      ],
      "explanations_ocaml": [
        "En el mismo laberinto encantado, 'let vocal_inicial s =' define un hechizo auxiliar 'vocal_inicial' que toma una cadena 's', como \"apple\". 'let' registra la instrucción en OCaml, como escribir una runa en un pergamino. Este hechizo verifica si la primera letra es una vocal, como seleccionar pistas con poder especial. Es útil para validar datos, como en un juego de puzzles donde solo ciertas palabras cuentan.",
        "'List.mem (Char.lowercase_ascii s.[0]) ['a'; 'e'; 'i'; 'o'; 'u']' comprueba si la primera letra de 's' (en minúsculas con 'Char.lowercase_ascii' y extraída con 's.[0]') está en la lista de vocales. Para \"apple\", 'a' es vocal, devolviendo verdadero. Esto se usa para filtrar datos, como en sistemas de búsqueda o juegos narrativos. La línea completa define el hechizo.",
        "';;' cierra la definición, como un sello en un pergamino que indica que el hechizo está completo. En OCaml, ';;' separa funciones en un archivo o intérprete, evitando errores. No programa un juego de carreras, pero es esencial para la claridad del código.",
        "Línea en blanco, como un espacio en el mapa del laberinto, para mantener el código organizado.",
        "'let filtrar_vocal_inicial lst =' define un hechizo 'filtrar_vocal_inicial' que toma una lista 'lst'. Este hechizo filtra palabras con vocal inicial, como elegir pistas válidas en el laberinto. Es útil para seleccionar datos, como en juegos o bases de datos.",
        "'List.filter vocal_inicial lst' aplica 'List.filter' para usar 'vocal_inicial' en cada palabra, dejando solo las que comienzan con vocal, como \"apple\" y \"cherry\". Es como un colador mágico para pistas. Esto se usa en sistemas de filtrado, como en juegos de aventuras.",
        "';;' cierra la definición, asegurando que el hechizo esté completo en OCaml, como un sello mágico.",
        "Línea en blanco para claridad, como un respiro en el pergamino.",
        "'let añadir_prefijo_clue lst =' define un hechizo 'añadir_prefijo_clue' que toma 'lst' y agrega \"clue-\" a cada palabra, como marcar pistas en el mapa. Es útil para transformar datos, como en juegos narrativos o interfaces.",
        "'List.map (fun s -> \"clue-\" ^ s) lst' usa 'List.map' para aplicar la concatenación '\"clue-\" ^ s' a cada palabra, transformando \"apple\" en \"clue-apple\". '(fun s ->' crea una mini-instrucción. Esto se usa para formatear datos, como en sistemas de etiquetado. La línea completa aplica el mapeo.",
        "';;' cierra la definición, como un sello que completa el hechizo en OCaml.",
        "Línea en blanco para organizar, como un espacio en el pergamino.",
        "'let compuesta_tres lst =' define un hechizo 'compuesta_tres' que combina los pasos, como un ritual completo para resolver acertijos en el laberinto.",
        "'añadir_prefijo_clue (filtrar_vocal_inicial lst)' encadena los hechizos, filtrando primero y luego añadiendo \"clue-\". Para '[\"apple\"; \"banana\"; \"cherry\"]', da '[\"clue-apple\"; \"clue-cherry\"]'. Esto se usa en flujos de datos, como en juegos o pipelines.",
        "';;' cierra la definición, asegurando que el hechizo esté completo en OCaml.",
        "Línea en blanco para separar, como un espacio antes de probar el ritual.",
        "'compuesta_tres [\"apple\"; \"banana\"; \"cherry\"]' invoca el hechizo, dando '[\"clue-apple\"; \"clue-cherry\"]'. Es como probar las pistas en el laberinto. En programación, esto verifica la función compuesta, útil para pruebas en juegos o sistemas."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función auxiliar para verificar vocales iniciales. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con sintaxis lineal. Racket es más visual con anidamiento, OCaml más compacto pero requiere el módulo 'List'.",
        "Similitudes: Ambas verifican si la primera letra es vocal. Diferencias: Racket usa 'string-ref' y 'string-downcase' con una lista de caracteres, OCaml usa 'Char.lowercase_ascii' y 's.[0]'. Racket usa 'member' con paréntesis, OCaml usa 'List.mem' más directo. Ambos logran lo mismo, pero OCaml es más conciso.",
        "Similitudes: Ambas cierran definiciones. Diferencias: Racket usa ')', OCaml usa ';;' para separar funciones en un archivo, esencial para evitar errores en OCaml, no para juegos sino para claridad.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna; ambas separan visualmente.",
        "Similitudes: Ambas definen funciones para filtrar palabras con vocal inicial. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida paréntesis, OCaml es más lineal.",
        "Similitudes: Ambas usan filtrado ('filter'/'List.filter'). Diferencias: Racket usa 'vocal-inicial?' explícitamente, OCaml usa 'vocal_inicial' como función definida. OCaml requiere 'List', Racket es más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;', esencial para OCaml.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna.",
        "Similitudes: Ambas definen funciones para añadir un prefijo. Diferencias: Racket usa 'define' y 'map', OCaml usa 'let' y 'List.map'. Racket anida más, OCaml es más lineal.",
        "Similitudes: Ambas aplican mapeo para añadir \"clue-\". Diferencias: Racket usa 'lambda' y 'string-append', OCaml usa 'fun' y '^'. OCaml es más conciso con su operador de concatenación, Racket más explícito con 'string-append'.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Ambas definen funciones compuestas. Diferencias: Racket usa 'define' con paréntesis anidados, OCaml usa 'let' con sintaxis lineal. Racket muestra el flujo visualmente, OCaml es más compacto.",
        "Similitudes: Ambas encadenan filtrado y mapeo. Diferencias: Racket usa paréntesis para anidar, OCaml usa una sintaxis más plana. Ambos logran el mismo resultado, pero Racket es más explícito en la jerarquía.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco separan. Diferencias: Ninguna.",
        "Similitudes: Ambas evalúan con la misma lista, dando '(\"clue-apple\" \"clue-cherry\")'. Diferencias: Racket usa '(\"apple\" \"banana\" \"cherry\")' con paréntesis, OCaml usa '[\"apple\"; \"banana\"; \"cherry\"]' con punto y coma. Racket es más uniforme, OCaml más variado en notación."
      ]
    },
    "ejercicio-4": {
      "title": "Filtrar colores vibrantes con longitud impar y mapear a códigos hexadecimales en un reino de sueños lúcidos",
      "racket": {
        "lines": [
          "(define (longitud-impar? s)",
          "  (odd? (string-length s)))",
          "",
          "(define (filtrar-longitud-impar lst)",
          "  (filter longitud-impar? lst))",
          "",
          "(define (es-primario? s)",
          "  (member (string-downcase s) '(\"red\" \"green\" \"blue\")))",
          "",
          "(define (filtrar-primarios lst)",
          "  (filter es-primario? lst))",
          "",
          "(define (mapear-hex lst)",
          "  (map (lambda (s)",
          "         (cond [(string=? (string-downcase s) \"red\") \"#FF0000\"]",
          "               [(string=? (string-downcase s) \"green\") \"#00FF00\"]",
          "               [(string=? (string-downcase s) \"blue\") \"#0000FF\"]",
          "               [else \"#000000\"]))",
          "       lst))",
          "",
          "(define (compuesta-cuatro lst)",
          "  (mapear-hex (filtrar-primarios (filtrar-longitud-impar lst))))",
          "",
          "(compuesta-cuatro '(\"red\" \"green\" \"blue\" \"yellow\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "let longitud_impar s =",
          "  String.length s mod 2 = 1",
          ";;",
          "",
          "let filtrar_longitud_impar lst =",
          "  List.filter longitud_impar lst",
          ";;",
          "",
          "let es_primario s =",
          "  List.mem (String.lowercase_ascii s) [\"red\"; \"green\"; \"blue\"]",
          ";;",
          "",
          "let filtrar_primarios lst =",
          "  List.filter es_primario lst",
          ";;",
          "",
          "let mapear_hex lst =",
          "  List.map (fun s ->",
          "    match String.lowercase_ascii s with",
          "    | \"red\" -> \"#FF0000\"",
          "    | \"green\" -> \"#00FF00\"",
          "    | \"blue\" -> \"#0000FF\"",
          "    | _ -> \"#000000\"",
          "  ) lst",
          ";;",
          "",
          "let compuesta_cuatro lst =",
          "  mapear_hex (filtrar_primarios (filtrar_longitud_impar lst))",
          ";;",
          "",
          "compuesta_cuatro [\"red\"; \"green\"; \"blue\"; \"yellow\"]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un soñador en un reino de sueños lúcidos, seleccionando colores para construir mundos oníricos. La línea '(define (longitud-impar? s)' crea un hechizo auxiliar 'longitud-impar?' que toma una cadena 's', como \"red\". 'define' registra la instrucción, como anotar una runa en un libro de sueños. Este hechizo verifica si la longitud de 's' es impar, como elegir colores con una vibración especial. Es útil para validar propiedades, como en un juego de realidad virtual donde seleccionas elementos según reglas.",
        "'(odd? (string-length s)))' usa 'string-length' para contar las letras de 's' y 'odd?' para verificar si es impar. Por ejemplo, \"red\" (3 letras) es impar, devolviendo verdadero. Esto se usa para filtrar datos, como en juegos o diseño gráfico. Los paréntesis cierran la función, como sellar una visión onírica.",
        "Línea en blanco, como un espacio en un lienzo de sueños, organiza el código, como dividir escenas en un relato onírico, mejorando la legibilidad.",
        "'(define (filtrar-longitud-impar lst)' crea un hechizo 'filtrar-longitud-impar' que toma una lista 'lst', como '(\"red\" \"green\" \"blue\" \"yellow\")'. Filtra colores con longitud impar, como seleccionar tonos para un mundo de sueños. Es útil para subseleccionar datos, como en juegos o bases de datos.",
        "'(filter longitud-impar? lst))' aplica 'filter' con 'longitud-impar?', dejando solo colores con longitud impar (\"red\", \"green\", \"blue\"). Es como un colador mágico que elige tonos vibrantes. Esto se usa en sistemas de filtrado, como en juegos de diseño. Los paréntesis cierran 'filter' y la función, como cerrar un portal onírico.",
        "Línea en blanco para claridad, como un respiro en el reino de sueños.",
        "'(define (es-primario? s)' crea un hechizo auxiliar 'es-primario?' que verifica si 's' es un color primario (\"red\", \"green\", \"blue\"). Es como identificar colores fundamentales en un sueño. Útil para validar datos, como en juegos o gráficos.",
        "'(member (string-downcase s) '(\"red\" \"green\" \"blue\")))' convierte 's' a minúsculas y verifica si está en la lista de primarios. Para \"red\", devuelve verdadero. Esto se usa para filtrar elementos específicos, como en sistemas de diseño. Los paréntesis cierran la función, como sellar una paleta de colores.",
        "Línea en blanco para organizar, como un espacio en el libro de sueños.",
        "'(define (filtrar-primarios lst)' crea un hechizo 'filtrar-primarios' que filtra colores primarios de 'lst'. Es como elegir tonos esenciales para un mundo onírico, útil para subseleccionar datos en juegos o aplicaciones.",
        "'(filter es-primario? lst))' aplica 'filter' con 'es-primario?', dejando solo primarios (\"red\", \"green\", \"blue\"). Es como un colador que selecciona colores puros. Los paréntesis cierran la función, como cerrar un lienzo mágico.",
        "Línea en blanco para claridad, como un espacio en el sueño.",
        "'(define (mapear-hex lst)' crea un hechizo 'mapear-hex' que transforma colores en códigos hexadecimales, como codificar tonos para un sistema de realidad virtual.",
        "'(map (lambda (s)' inicia la transformación, usando 'map' para aplicar una regla a cada color. 'lambda (s)' crea una mini-instrucción, como un soñador pintando cada tono.",
        "'(cond [(string=? (string-downcase s) \"red\") \"#FF0000\"]' verifica si 's' es \"red\" (en minúsculas), devolviendo \"#FF0000\". Es como asignar un código mágico a un color. 'cond' permite múltiples casos, útil en juegos o diseño.",
        "'[(string=? (string-downcase s) \"green\") \"#00FF00\"]' asigna \"#00FF00\" a \"green\", como codificar otro tono onírico.",
        "'[(string=? (string-downcase s) \"blue\") \"#0000FF\"]' asigna \"#0000FF\" a \"blue\", completando los primarios.",
        "'[else \"#000000\"]))' asigna \"#000000\" a cualquier otro color, como un valor por defecto. Los paréntesis cierran 'cond' y 'lambda', como sellar una transformación.",
        "'lst))' aplica 'map' a toda la lista, completando el hechizo, como pintar un mundo de sueños.",
        "Línea en blanco para separar, como un respiro en el lienzo onírico.",
        "'(define (compuesta-cuatro lst)' crea un hechizo 'compuesta-cuatro' que combina los pasos, como un ritual para construir un mundo de sueños.",
        "'(mapear-hex (filtrar-primarios (filtrar-longitud-impar lst))))' encadena los hechizos: filtra longitud impar, filtra primarios, mapea a hexadecimales. Para '(\"red\" \"green\" \"blue\" \"yellow\")', da '(\"#FF0000\" \"#00FF00\" \"#0000FF\")'. Es útil en flujos de datos, como en juegos de realidad virtual. Los paréntesis cierran la composición, como completar un ritual.",
        "Línea en blanco para organizar, como un espacio antes de probar el hechizo.",
        "'(compuesta-cuatro '(\"red\" \"green\" \"blue\" \"yellow\"))' invoca el hechizo, dando '(\"#FF0000\" \"#00FF00\" \"#0000FF\")'. Es como un soñador probando los códigos en un sistema onírico. Útil para pruebas en juegos o aplicaciones."
      ],
      "explanations_ocaml": [
        "En el reino de sueños lúcidos, 'let longitud_impar s =' define un hechizo auxiliar 'longitud_impar' que toma una cadena 's'. 'let' registra la instrucción en OCaml, como escribir una runa en un libro de sueños. Verifica si la longitud de 's' es impar, como seleccionar colores con vibración especial. Es útil para validar datos, como en juegos de diseño.",
        "'String.length s mod 2 = 1' calcula la longitud de 's' y verifica si es impar con 'mod 2 = 1'. Para \"red\" (3 letras), devuelve verdadero. Esto se usa para filtrar, como en sistemas gráficos o juegos. La línea define el hechizo.",
        "';;' cierra la definición, como un sello en un pergamino onírico, esencial en OCaml para separar funciones y evitar errores. No programa un juego de carreras, pero organiza el código.",
        "Línea en blanco para claridad, como un espacio en el lienzo de sueños.",
        "'let filtrar_longitud_impar lst =' define un hechizo 'filtrar_longitud_impar' que filtra colores con longitud impar, como elegir tonos vibrantes para un mundo onírico. Es útil para subseleccionar datos, como en juegos.",
        "'List.filter longitud_impar lst' aplica 'List.filter' con 'longitud_impar', dejando colores con longitud impar (\"red\", \"green\", \"blue\"). Es como un colador mágico para tonos. Se usa en sistemas de filtrado, como juegos de diseño.",
        "';;' cierra la definición, como un sello en OCaml.",
        "Línea en blanco para organizar, como un respiro en el sueño.",
        "'let es_primario s =' define un hechizo 'es_primario' que verifica si 's' es un color primario. Es como identificar tonos esenciales en un sueño, útil para validar datos.",
        "'List.mem (String.lowercase_ascii s) [\"red\"; \"green\"; \"blue\"]' convierte 's' a minúsculas y verifica si está en la lista de primarios. Para \"red\", devuelve verdadero. Es útil para filtrar elementos, como en gráficos o juegos.",
        "';;' cierra la definición, asegurando claridad en OCaml.",
        "Línea en blanco para organizar.",
        "'let filtrar_primarios lst =' define un hechizo 'filtrar_primarios' que filtra primarios, como elegir colores puros para un mundo de sueños.",
        "'List.filter es_primario lst' aplica 'List.filter' con 'es_primario', dejando solo primarios (\"red\", \"green\", \"blue\"). Es como un colador para tonos esenciales.",
        "';;' cierra la definición, como un sello mágico.",
        "Línea en blanco para claridad.",
        "'let mapear_hex lst =' define un hechizo 'mapear_hex' que transforma colores en códigos hexadecimales, como codificar tonos para un sistema onírico.",
        "'List.map (fun s ->' inicia el mapeo, usando 'List.map' con una mini-instrucción '(fun s ->' para cada color, como un soñador pintando tonos.",
        "'match String.lowercase_ascii s with' usa 'match' para comparar 's' (en minúsculas) con casos, como clasificar colores en un sueño. 'match' es ideal para múltiples condiciones, como en juegos o diseño.",
        "'| \"red\" -> \"#FF0000\"' asigna \"#FF0000\" a \"red\", como codificar un tono vibrante.",
        "'| \"green\" -> \"#00FF00\"' asigna \"#00FF00\" a \"green\".",
        "'| \"blue\" -> \"#0000FF\"' asigna \"#0000FF\" a \"blue\".",
        "'| _ -> \"#000000\"' asigna \"#000000\" por defecto, cerrando 'match'.",
        "') lst' aplica 'List.map' a toda la lista, completando el hechizo.",
        "';;' cierra la definición, asegurando claridad.",
        "Línea en blanco para organizar.",
        "'let compuesta_cuatro lst =' define un hechizo 'compuesta_cuatro' que combina los pasos, como un ritual onírico completo.",
        "'mapear_hex (filtrar_primarios (filtrar_longitud_impar lst))' encadena los hechizos, dando '[\"#FF0000\"; \"#00FF00\"; \"#0000FF\"]' para '[\"red\"; \"green\"; \"blue\"; \"yellow\"]'. Es útil en flujos de datos, como en juegos de realidad virtual.",
        "';;' cierra la definición, como un sello en OCaml.",
        "Línea en blanco para separar.",
        "'compuesta_cuatro [\"red\"; \"green\"; \"blue\"; \"yellow\"]' invoca el hechizo, dando '[\"#FF0000\"; \"#00FF00\"; \"#0000FF\"]', como probar códigos en un sistema onírico. Útil para pruebas en juegos."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican si la longitud es impar. Diferencias: Racket usa 'define' y 'odd?', OCaml usa 'let' y 'mod 2 = 1'. Racket es más explícito, OCaml más matemático.",
        "Similitudes: Ambas calculan la longitud y verifican paridad. Diferencias: Racket usa 'string-length' y 'odd?', OCaml usa 'String.length' y 'mod 2 = 1'. OCaml es más conciso, Racket más claro para principiantes.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;', esencial para separar funciones en OCaml.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Ambas filtran longitud impar. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida paréntesis, OCaml es más lineal.",
        "Similitudes: Aplican filtrado. Diferencias: Racket usa 'longitud-impar?', OCaml usa 'longitud_impar'. OCaml requiere 'List', Racket es más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Verifican colores primarios. Diferencias: Racket usa 'define' y 'member', OCaml usa 'let' y 'List.mem'. Racket anida, OCaml es más compacto.",
        "Similitudes: Comparan con lista de primarios. Diferencias: Racket usa 'string-downcase' y '(\"red\" \"green\" \"blue\")', OCaml usa 'String.lowercase_ascii' y '[\"red\"; \"green\"; \"blue\"]'. OCaml es más conciso, Racket más visual.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Filtran primarios. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican filtrado con 'es-primario?'. Diferencias: Racket usa función explícita, OCaml usa 'es_primario'. OCaml requiere 'List'.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Transforman a hexadecimales. Diferencias: Racket usa 'define' y 'map', OCaml usa 'let' y 'List.map'. Racket anida, OCaml es más compacto.",
        "Similitudes: Inician mapeo. Diferencias: Racket usa 'lambda (s)', OCaml usa 'fun s ->'. OCaml es más conciso, Racket más explícito.",
        "Similitudes: Usan estructuras condicionales. Diferencias: Racket usa 'cond', OCaml usa 'match'. OCaml es más elegante para casos, Racket más flexible.",
        "Similitudes: Asignan \"#FF0000\" a \"red\". Diferencias: Racket usa 'string=?' con 'cond', OCaml usa 'match' con patrón. OCaml es más directo.",
        "Similitudes: Asignan \"#00FF00\" a \"green\". Diferencias: Racket usa 'string=?', OCaml usa 'match'. Mismo patrón de sintaxis.",
        "Similitudes: Asignan \"#0000FF\" a \"blue\". Diferencias: Igual que las anteriores, Racket usa 'cond', OCaml usa 'match'.",
        "Similitudes: Asignan valor por defecto. Diferencias: Racket usa '[else \"#000000\"]', OCaml usa '| _ -> \"#000000\"'. OCaml es más conciso.",
        "Similitudes: Completan mapeo. Diferencias: Racket usa 'lst))', OCaml usa ') lst'. Racket anida más, OCaml es lineal.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con sintaxis lineal. Racket es más visual, OCaml más compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket usa paréntesis anidados, OCaml usa sintaxis plana. Ambos logran el mismo resultado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Evalúan con la misma lista, dando '(\"#FF0000\" \"#00FF00\" \"#0000FF\")'. Diferencias: Racket usa paréntesis, OCaml usa punto y coma. Racket es más uniforme, OCaml más variado."
      ]
    },
    "ejercicio-5": {
      "title": "Filtrar actos con 'm', asignar tiempos y sumarlos en un circo victoriano",
      "racket": {
        "lines": [
          "(define (contiene-m? s)",
          "  (string-contains? (string-downcase s) \"m\"))",
          "",
          "(define (filtrar-contiene-m lst)",
          "  (filter contiene-m? lst))",
          "",
          "(define (asignar-tiempo s)",
          "  (let ([len (string-length s)])",
          "    (if (> len 5)",
          "        20",
          "        10)))",
          "",
          "(define (mapear-tiempos lst)",
          "  (map asignar-tiempo lst))",
          "",
          "(define (sumar-tiempos lst)",
          "  (foldl + 0 lst))",
          "",
          "(define (compuesta-cinco lst)",
          "  (sumar-tiempos (mapear-tiempos (filtrar-contiene-m lst))))",
          "",
          "(compuesta-cinco '(\"magia\" \"misterio\" \"truco\" \"ilusión\"))"
        ]
      },
      "ocaml": {
        "lines": [
          "let contiene_m s =",
          "  String.contains (String.lowercase_ascii s) 'm'",
          ";;",
          "",
          "let filtrar_contiene_m lst =",
          "  List.filter contiene_m lst",
          ";;",
          "",
          "let asignar_tiempo s =",
          "  let len = String.length s in",
          "  if len > 5 then 20 else 10",
          ";;",
          "",
          "let mapear_tiempos lst =",
          "  List.map asignar_tiempo lst",
          ";;",
          "",
          "let sumar_tiempos lst =",
          "  List.fold_left (+) 0 lst",
          ";;",
          "",
          "let compuesta_cinco lst =",
          "  sumar_tiempos (mapear_tiempos (filtrar_contiene_m lst))",
          ";;",
          "",
          "compuesta_cinco [\"magia\"; \"misterio\"; \"truco\"; \"ilusión\"]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un ilusionista en un circo victoriano, organizando actos misteriosos. La línea '(define (contiene-m? s)' crea un hechizo auxiliar 'contiene-m?' que toma una cadena 's', como \"magia\". 'define' registra la instrucción, como anotar un truco en un libro de magia. Este hechizo verifica si 's' contiene 'm', como seleccionar actos con un aura especial. Es útil para validar datos, como en un juego de gestión de eventos donde eliges actos según criterios.",
        "'(string-contains? (string-downcase s) \"m\"))' usa 'string-downcase' para convertir 's' a minúsculas y 'string-contains?' para verificar si tiene 'm'. Para \"magia\", devuelve verdadero. Esto se usa para filtrar datos, como en sistemas de organización o juegos narrativos. Los paréntesis cierran la función, como sellar un truco en un pergamino victoriano.",
        "Línea en blanco, como un espacio en el programa del circo, organiza el código, como dividir actos en un cartel, mejorando la legibilidad.",
        "'(define (filtrar-contiene-m lst)' crea un hechizo 'filtrar-contiene-m' que toma una lista 'lst', como '(\"magia\" \"misterio\" \"truco\" \"ilusión\")'. Filtra actos con 'm', como seleccionar trucos especiales para el espectáculo. Es útil para subseleccionar datos, como en juegos de gestión.",
        "'(filter contiene-m? lst))' aplica 'filter' con 'contiene-m?', dejando solo actos con 'm' (\"magia\", \"misterio\"). Es como un colador mágico para actos. Se usa en sistemas de filtrado, como en juegos o bases de datos. Los paréntesis cierran 'filter' y la función, como cerrar un baúl de trucos.",
        "Línea en blanco para claridad, como un respiro en el cartel del circo.",
        "'(define (asignar-tiempo s)' crea un hechizo 'asignar-tiempo' que asigna tiempos a cada acto según su longitud, como planificar la duración de trucos en el circo.",
        "'(let ([len (string-length s)])' usa 'let' para calcular la longitud de 's' y almacenarla en 'len', como medir un truco para el horario. 'let' organiza variables locales, útil para cálculos intermedios en juegos o sistemas.",
        "'(if (> len 5)' inicia una condición: si 'len' es mayor a 5, el acto es largo. 'if' decide el tiempo, como un ilusionista eligiendo la duración de un truco.",
        "'20' asigna 20 minutos a actos largos (como \"misterio\", 8 letras), como un número estelar en el circo.",
        "'10)))' asigna 10 minutos a actos cortos (como \"magia\", 5 letras), cerrando 'if' y 'let'. Los paréntesis sellan el hechizo, como finalizar un plan de tiempos.",
        "Línea en blanco para organizar, como un espacio en el programa del circo.",
        "'(define (mapear-tiempos lst)' crea un hechizo 'mapear-tiempos' que aplica 'asignar-tiempo' a cada acto en 'lst', como asignar horarios a todos los trucos.",
        "'(map asignar-tiempo lst))' usa 'map' para transformar cada acto en su tiempo (\"magia\" → 10, \"misterio\" → 20). Es como un asistente mágico que organiza horarios. Se usa en sistemas de transformación, como en juegos de gestión. Los paréntesis cierran 'map' y la función.",
        "Línea en blanco para claridad.",
        "'(define (sumar-tiempos lst)' crea un hechizo 'sumar-tiempos' que suma los tiempos de los actos, como calcular la duración total del espectáculo.",
        "'(foldl + 0 lst))' usa 'foldl' para sumar los tiempos en 'lst', empezando desde 0. Es como un contador mágico que acumula minutos. Se usa en cálculos acumulativos, como en juegos o sistemas de planificación. Los paréntesis cierran 'foldl' y la función.",
        "Línea en blanco para separar.",
        "'(define (compuesta-cinco lst)' crea un hechizo 'compuesta-cinco' que combina los pasos, como un ritual completo para organizar el circo.",
        "'(sumar-tiempos (mapear-tiempos (filtrar-contiene-m lst))))' encadena los hechizos: filtra actos con 'm', asigna tiempos, y los suma, dando 70 para '(\"magia\" \"misterio\" \"truco\" \"ilusión\")'. Es útil en flujos de datos, como en juegos de gestión. Los paréntesis cierran la composición, como completar el programa del circo.",
        "Línea en blanco para organizar.",
        "'(compuesta-cinco '(\"magia\" \"misterio\" \"truco\" \"ilusión\"))' invoca el hechizo, dando 70. Es como probar el horario del circo. Útil para pruebas en juegos o sistemas."
      ],
      "explanations_ocaml": [
        "En el circo victoriano, 'let contiene_m s =' define un hechizo auxiliar 'contiene_m' que toma una cadena 's'. 'let' registra la instrucción en OCaml, como anotar un truco en un pergamino. Verifica si 's' contiene 'm', como seleccionar actos con magia especial. Es útil para validar datos, como en juegos de gestión.",
        "'String.contains (String.lowercase_ascii s) 'm'' usa 'String.lowercase_ascii' para convertir 's' a minúsculas y 'String.contains' para verificar 'm'. Para \"magia\", devuelve verdadero. Es útil para filtrar, como en sistemas narrativos o juegos. La línea define el hechizo.",
        "';;' cierra la definición, como un sello en un pergamino victoriano, esencial en OCaml para separar funciones.",
        "Línea en blanco para claridad, como un espacio en el cartel del circo.",
        "'let filtrar_contiene_m lst =' define un hechizo 'filtrar_contiene_m' que filtra actos con 'm', como elegir trucos especiales para el espectáculo.",
        "'List.filter contiene_m lst' aplica 'List.filter' con 'contiene_m', dejando actos con 'm' (\"magia\", \"misterio\"). Es como un colador mágico para trucos. Se usa en sistemas de filtrado, como en juegos.",
        "';;' cierra la definición, como un sello en OCaml.",
        "Línea en blanco para organizar.",
        "'let asignar_tiempo s =' define un hechizo 'asignar_tiempo' que asigna tiempos según la longitud del acto, como planificar el horario del circo.",
        "'let len = String.length s in' calcula la longitud de 's' y la almacena en 'len', como medir un truco. 'let ... in' organiza variables locales, útil para cálculos en juegos.",
        "'if len > 5 then 20 else 10' asigna 20 minutos a actos largos (\"misterio\") y 10 a cortos (\"magia\"), como decidir la duración de un truco. 'if' maneja la lógica condicional.",
        "';;' cierra la definición, asegurando claridad en OCaml.",
        "Línea en blanco para organizar.",
        "'let mapear_tiempos lst =' define un hechizo 'mapear_tiempos' que aplica 'asignar_tiempo' a cada acto, como asignar horarios a todos los trucos.",
        "'List.map asignar_tiempo lst' transforma cada acto en su tiempo (\"magia\" → 10, \"misterio\" → 20). Es como un asistente que organiza horarios. Se usa en sistemas de transformación, como en juegos.",
        "';;' cierra la definición, como un sello mágico.",
        "Línea en blanco para claridad.",
        "'let sumar_tiempos lst =' define un hechizo 'sumar_tiempos' que suma los tiempos, como calcular la duración total del espectáculo.",
        "'List.fold_left (+) 0 lst' usa 'List.fold_left' para sumar los tiempos, empezando desde 0. Es como un contador que acumula minutos. Se usa en cálculos acumulativos, como en juegos de gestión.",
        "';;' cierra la definición, asegurando claridad.",
        "Línea en blanco para organizar.",
        "'let compuesta_cinco lst =' define un hechizo 'compuesta_cinco' que combina los pasos, como un ritual completo para el circo.",
        "'sumar_tiempos (mapear_tiempos (filtrar_contiene_m lst))' encadena los hechizos, dando 70 para '[\"magia\"; \"misterio\"; \"truco\"; \"ilusión\"]'. Es útil en flujos de datos, como en juegos.",
        "';;' cierra la definición, como un sello en OCaml.",
        "Línea en blanco para separar.",
        "'compuesta_cinco [\"magia\"; \"misterio\"; \"truco\"; \"ilusión\"]' invoca el hechizo, dando 70. Es como probar el horario del circo. Útil para pruebas en juegos."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican si la cadena contiene 'm'. Diferencias: Racket usa 'define' y 'string-contains?', OCaml usa 'let' y 'String.contains'. Racket anida paréntesis, OCaml es más lineal.",
        "Similitudes: Ambas convierten a minúsculas y buscan 'm'. Diferencias: Racket usa 'string-downcase' y 'string-contains?', OCaml usa 'String.lowercase_ascii' y 'String.contains'. OCaml es más conciso, Racket más explícito.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;', esencial para separar funciones en OCaml.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Filtran actos con 'm'. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican filtrado. Diferencias: Racket usa 'contiene-m?', OCaml usa 'contiene_m'. OCaml requiere 'List', Racket es más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Asignan tiempos según longitud. Diferencias: Racket usa 'define', OCaml usa 'let'. Racket anida más, OCaml es más compacto.",
        "Similitudes: Calculan longitud. Diferencias: Racket usa 'let' con '[len (string-length s)]', OCaml usa 'let ... in' con 'String.length'. OCaml es más lineal, Racket más explícito.",
        "Similitudes: Usan condicional para asignar tiempos. Diferencias: Racket usa 'if', OCaml usa 'if ... then ... else'. OCaml es más conciso, Racket más visual.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Mapean tiempos. Diferencias: Racket usa 'define' y 'map', OCaml usa 'let' y 'List.map'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican mapeo. Diferencias: Racket usa 'asignar-tiempo', OCaml usa 'asignar_tiempo'. OCaml requiere 'List', Racket es más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Suman tiempos. Diferencias: Racket usa 'define' y 'foldl', OCaml usa 'let' y 'List.fold_left'. Racket anida, OCaml es más compacto.",
        "Similitudes: Usan acumulación. Diferencias: Racket usa 'foldl + 0', OCaml usa 'List.fold_left (+) 0'. OCaml requiere 'List', Racket es más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con sintaxis lineal. Racket es más visual, OCaml más compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket usa paréntesis anidados, OCaml usa sintaxis plana. Ambos logran el mismo resultado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Evalúan con la misma lista, dando 70. Diferencias: Racket usa paréntesis, OCaml usa punto y coma. Racket es más uniforme, OCaml más variado."
      ]
    },
    "ejercicio-6": {
      "title": "Filtrar libros con vocal inicial, generar resúmenes, filtrar largos y contar palabras en una biblioteca de mitos",
      "racket": {
        "lines": [
          "(define (vocal-inicio? s)",
          "  (member (char-downcase (string-ref s 0)) '(#\\a #\\e #\\i #\\o #\\u)))",
          "",
          "(define (filtrar-vocal-inicio lst)",
          "  (filter (lambda (p) (vocal-inicio? (car p))) lst))",
          "",
          "(define (generar-resumen p)",
          "  (let ([titulo (car p)] [genero (cdr p)])",
          "    (if (string=? genero \"epica\")",
          "        (string-append \"Epica: \" titulo)",
          "        (if (string=? genero \"leyenda\")",
          "            (string-append \"Leyenda: \" titulo)",
          "            (string-append \"Mito: \" titulo))))",
          "",
          "(define (mapear-resumenes lst)",
          "  (map generar-resumen lst))",
          "",
          "(define (resumen-largo? s)",
          "  (> (string-length s) 10))",
          "",
          "(define (filtrar-resumenes-largos lst)",
          "  (filter resumen-largo? lst))",
          "",
          "(define (contar-palabras lst)",
          "  (foldl (lambda (s acc)",
          "           (+ acc (length (string-split s))))",
          "         0 lst))",
          "",
          "(define (compuesta-seis lst)",
          "  (contar-palabras (filtrar-resumenes-largos (mapear-resumenes (filtrar-vocal-inicio lst)))))",
          "",
          "(compuesta-seis '((\"Odisea\" . \"epica\") (\"Iliada\" . \"epica\") (\"Beowulf\" . \"leyenda\") (\"Gilgamesh\" . \"mito\")))"
        ]
      },
      "ocaml": {
        "lines": [
          "let vocal_inicio s =",
          "  List.mem (Char.lowercase_ascii s.[0]) ['a'; 'e'; 'i'; 'o'; 'u']",
          ";;",
          "",
          "let filtrar_vocal_inicio lst =",
          "  List.filter (fun (titulo, _) -> vocal_inicio titulo) lst",
          ";;",
          "",
          "let generar_resumen (titulo, genero) =",
          "  if genero = \"epica\" then",
          "    \"Epica: \" ^ titulo",
          "  else if genero = \"leyenda\" then",
          "    \"Leyenda: \" ^ titulo",
          "  else",
          "    \"Mito: \" ^ titulo",
          ";;",
          "",
          "let mapear_resumenes lst =",
          "  List.map generar_resumen lst",
          ";;",
          "",
          "let resumen_largo s =",
          "  String.length s > 10",
          ";;",
          "",
          "let filtrar_resumenes_largos lst =",
          "  List.filter resumen_largo lst",
          ";;",
          "",
          "let contar_palabras lst =",
          "  List.fold_left (fun acc s ->",
          "    acc + (List.length (String.split_on_char ' ' s))",
          "  ) 0 lst",
          ";;",
          "",
          "let compuesta_seis lst =",
          "  contar_palabras (filtrar_resumenes_largos (mapear_resumenes (filtrar_vocal_inicio lst)))",
          ";;",
          "",
          "compuesta_seis [(\"Odisea\", \"epica\"); (\"Iliada\", \"epica\"); (\"Beowulf\", \"leyenda\"); (\"Gilgamesh\", \"mito\")]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un archivero en una biblioteca de mitos olvidados, organizando libros mágicos. La línea '(define (vocal-inicio? s)' crea un hechizo auxiliar 'vocal-inicio?' que toma una cadena 's', como \"Odisea\". 'define' registra la instrucción, como catalogar un tomo en un archivo místico. Este hechizo verifica si 's' comienza con vocal, como seleccionar libros con un aura especial. Es útil para validar datos, como en un juego de rol donde eliges artefactos según propiedades.",
        "'(member (char-downcase (string-ref s 0)) '(#\\a #\\e #\\i #\\o #\\u)))' convierte la primera letra de 's' a minúscula con 'char-downcase' y 'string-ref 0', luego verifica si está en la lista de vocales. Para \"Odisea\", 'o' es vocal, devolviendo verdadero. Esto se usa para filtrar datos, como en sistemas narrativos o juegos. Los paréntesis cierran la función, como sellar un libro mágico.",
        "Línea en blanco, como un espacio en el archivo de la biblioteca, organiza el código, mejorando la legibilidad.",
        "'(define (filtrar-vocal-inicio lst)' crea un hechizo 'filtrar-vocal-inicio' que toma una lista 'lst' de pares, como '((\"Odisea\" . \"epica\"))'. Filtra libros con títulos que comienzan con vocal, como elegir tomos especiales. Es útil para subseleccionar datos, como en juegos de rol.",
        "'(filter (lambda (p) (vocal-inicio? (car p))) lst))' usa 'filter' con una mini-instrucción 'lambda (p)' que aplica 'vocal-inicio?' al título ('car p') de cada par, dejando solo los que cumplen (\"Odisea\", \"Iliada\"). Es como un colador mágico para libros. Se usa en sistemas de filtrado. Los paréntesis cierran 'lambda', 'filter', y la función, como cerrar un estante místico.",
        "Línea en blanco para claridad, como un respiro en el archivo.",
        "'(define (generar-resumen p)' crea un hechizo 'generar-resumen' que toma un par 'p', como '(\"Odisea\" . \"epica\")', para crear un resumen según el género, como catalogar un libro con una nota descriptiva.",
        "'(let ([titulo (car p)] [genero (cdr p)])' usa 'let' para extraer el título ('car p') y género ('cdr p'), como abrir un libro para leer su contenido. 'let' organiza variables locales, útil para procesar pares en juegos o bases de datos.",
        "'(if (string=? genero \"epica\")' verifica si el género es \"epica\", como clasificar un libro en una categoría mítica. 'if' inicia una decisión, útil para lógica condicional.",
        "'(string-append \"Epica: \" titulo)' concatena \"Epica: \" con el título, como \"Epica: Odisea\", si el género es \"epica\". Es como escribir una nota en el archivo.",
        "'(if (string=? genero \"leyenda\")' verifica si el género es \"leyenda\", como clasificar otro tipo de mito.",
        "'(string-append \"Leyenda: \" titulo)' concatena \"Leyenda: \" con el título, como \"Leyenda: Beowulf\".",
        "'(string-append \"Mito: \" titulo))))' concatena \"Mito: \" por defecto, como \"Mito: Gilgamesh\". Los paréntesis cierran los 'if' y 'let', como sellar una nota mística.",
        "Línea en blanco para organizar, como un espacio en el archivo.",
        "'(define (mapear-resumenes lst)' crea un hechizo 'mapear-resumenes' que aplica 'generar-resumen' a cada par en 'lst', como catalogar todos los libros.",
        "'(map generar-resumen lst))' usa 'map' para transformar cada par en su resumen, como '(\"Epica: Odisea\")'. Es como un escriba mágico que anota resúmenes. Se usa en sistemas de transformación, como en juegos narrativos. Los paréntesis cierran 'map' y la función.",
        "Línea en blanco para claridad.",
        "'(define (resumen-largo? s)' crea un hechizo 'resumen-largo?' que verifica si un resumen 's' tiene más de 10 caracteres, como seleccionar notas extensas en el archivo.",
        "'(> (string-length s) 10))' usa 'string-length' para contar caracteres y verifica si son más de 10. Para \"Epica: Odisea\", da verdadero (12 caracteres). Es útil para filtrar datos, como en juegos o sistemas de texto. Los paréntesis cierran la función.",
        "Línea en blanco para organizar.",
        "'(define (filtrar-resumenes-largos lst)' crea un hechizo 'filtrar-resumenes-largos' que filtra resúmenes largos, como elegir notas extensas para un ritual mítico.",
        "'(filter resumen-largo? lst))' aplica 'filter' con 'resumen-largo?', dejando resúmenes largos (\"Epica: Odisea\", \"Epica: Iliada\"). Es como un colador para notas. Se usa en sistemas de filtrado. Los paréntesis cierran 'filter' y la función.",
        "Línea en blanco para claridad.",
        "'(define (contar-palabras lst)' crea un hechizo 'contar-palabras' que suma las palabras en los resúmenes, como contar historias en el archivo.",
        "'(foldl (lambda (s acc)' inicia una acumulación con 'foldl', usando 'lambda (s acc)' para procesar cada resumen 's' y acumulador 'acc', como un escriba contando palabras.",
        "'(+ acc (length (string-split s))))' suma al acumulador el número de palabras en 's' (usando 'string-split' para dividir en palabras). Para \"Epica: Odisea\", da 2 palabras. Es útil para cálculos acumulativos, como en juegos o análisis de texto.",
        "'0 lst))' inicia 'foldl' con 0 y aplica a 'lst', cerrando 'lambda' y 'foldl'. Los paréntesis sellan el hechizo.",
        "Línea en blanco para organizar.",
        "'(define (compuesta-seis lst)' crea un hechizo 'compuesta-seis' que combina todos los pasos, como un ritual completo para procesar el archivo mítico.",
        "'(contar-palabras (filtrar-resumenes-largos (mapear-resumenes (filtrar-vocal-inicio lst)))))' encadena los hechizos: filtra vocal inicial, genera resúmenes, filtra largos, cuenta palabras, dando 8 para la lista dada. Es útil en flujos de datos, como en juegos de rol. Los paréntesis cierran la composición.",
        "Línea en blanco para separar.",
        "'(compuesta-seis '((\"Odisea\" . \"epica\") (\"Iliada\" . \"epica\") (\"Beowulf\" . \"leyenda\") (\"Gilgamesh\" . \"mito\")))' invoca el hechizo, dando 8. Es como probar el archivo en un ritual. Útil para pruebas en juegos o sistemas."
      ],
      "explanations_ocaml": [
        "En la biblioteca de mitos olvidados, 'let vocal_inicio s =' define un hechizo auxiliar 'vocal_inicio' que toma una cadena 's'. 'let' registra la instrucción en OCaml, como catalogar un tomo. Verifica si 's' comienza con vocal, como seleccionar libros con magia especial. Es útil para validar datos, como en juegos de rol.",
        "'List.mem (Char.lowercase_ascii s.[0]) ['a'; 'e'; 'i'; 'o'; 'u']' convierte la primera letra de 's' a minúscula y verifica si es vocal. Para \"Odisea\", 'o' devuelve verdadero. Es útil para filtrar, como en sistemas narrativos. La línea define el hechizo.",
        "';;' cierra la definición, como un sello en un pergamino mítico, esencial en OCaml para separar funciones.",
        "Línea en blanco para claridad, como un espacio en el archivo.",
        "'let filtrar_vocal_inicio lst =' define un hechizo 'filtrar_vocal_inicio' que filtra pares con títulos que comienzan con vocal, como elegir tomos especiales.",
        "'List.filter (fun (titulo, _) -> vocal_inicio titulo) lst' usa 'List.filter' con una mini-instrucción '(fun (titulo, _)' que aplica 'vocal_inicio' al título, dejando pares como '(\"Odisea\", \"epica\")'. Es como un colador mágico. Se usa en sistemas de filtrado.",
        "';;' cierra la definición, como un sello en OCaml.",
        "Línea en blanco para organizar.",
        "'let generar_resumen (titulo, genero) =' define un hechizo 'generar_resumen' que toma un par, como '(\"Odisea\", \"epica\")', para crear un resumen según el género.",
        "'if genero = \"epica\" then' verifica si el género es \"epica\", como clasificar un libro.",
        "'\"Epica: \" ^ titulo' concatena \"Epica: \" con el título, como \"Epica: Odisea\", si es \"epica\".",
        "'else if genero = \"leyenda\" then' verifica si el género es \"leyenda\".",
        "'\"Leyenda: \" ^ titulo' concatena \"Leyenda: \" con el título, como \"Leyenda: Beowulf\".",
        "'else' indica el caso por defecto, como clasificar cualquier otro género.",
        "'\"Mito: \" ^ titulo' concatena \"Mito: \" con el título, como \"Mito: Gilgamesh\".",
        "';;' cierra la definición, asegurando claridad.",
        "Línea en blanco para organizar.",
        "'let mapear_resumenes lst =' define un hechizo 'mapear_resumenes' que aplica 'generar_resumen' a cada par, como catalogar todos los libros.",
        "'List.map generar_resumen lst' transforma cada par en su resumen, como '[\"Epica: Odisea\"]'. Es como un escriba mágico que anota resúmenes. Se usa en sistemas de transformación.",
        "';;' cierra la definición, como un sello.",
        "Línea en blanco para claridad.",
        "'let resumen_largo s =' define un hechizo 'resumen_largo' que verifica si un resumen tiene más de 10 caracteres, como seleccionar notas extensas.",
        "'String.length s > 10' cuenta caracteres y verifica si son más de 10. Para \"Epica: Odisea\", da verdadero. Es útil para filtrar, como en juegos o texto.",
        "';;' cierra la definición, asegurando claridad.",
        "Línea en blanco para organizar.",
        "'let filtrar_resumenes_largos lst =' define un hechizo 'filtrar_resumenes_largos' que filtra resúmenes largos, como elegir notas extensas.",
        "'List.filter resumen_largo lst' aplica 'List.filter' con 'resumen_largo', dejando resúmenes largos. Es como un colador para notas.",
        "';;' cierra la definición, como un sello.",
        "Línea en blanco para organizar.",
        "'let contar_palabras lst =' define un hechizo 'contar_palabras' que suma las palabras en los resúmenes, como contar historias.",
        "'List.fold_left (fun acc s ->' inicia una acumulación con 'List.fold_left', usando una mini-instrucción para cada resumen 's' y acumulador 'acc'.",
        "'acc + (List.length (String.split_on_char ' ' s))' suma al acumulador el número de palabras en 's', usando 'String.split_on_char' para dividir en palabras.",
        "') 0 lst' inicia con 0 y aplica a 'lst', cerrando 'List.fold_left'.",
        "';;' cierra la definición, como un sello.",
        "Línea en blanco para organizar.",
        "'let compuesta_seis lst =' define un hechizo 'compuesta_seis' que combina todos los pasos, como un ritual completo.",
        "'contar_palabras (filtrar_resumenes_largos (mapear_resumenes (filtrar_vocal_inicio lst)))' encadena los hechizos, dando 8. Es útil en flujos de datos, como en juegos de rol.",
        "';;' cierra la definición, como un sello.",
        "Línea en blanco para separar.",
        "'compuesta_seis [(\"Odisea\", \"epica\"); (\"Iliada\", \"epica\"); (\"Beowulf\", \"leyenda\"); (\"Gilgamesh\", \"mito\")]' invoca el hechizo, dando 8. Es como probar el archivo. Útil para pruebas."
      ],
      "comparisons": [
        "Similitudes: Verifican vocal inicial. Diferencias: Racket usa 'define' y 'char-downcase', OCaml usa 'let' y 'Char.lowercase_ascii'. Racket anida, OCaml es más lineal.",
        "Similitudes: Comparan primera letra con vocales. Diferencias: Racket usa 'string-ref' y 'member', OCaml usa 's.[0]' y 'List.mem'. OCaml es más conciso, Racket más visual.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Filtran títulos con vocal inicial. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican filtrado. Diferencias: Racket usa 'lambda (p)' y 'car', OCaml usa '(fun (titulo, _))'. OCaml ignora el segundo elemento explícitamente, Racket es más general.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Generan resúmenes según género. Diferencias: Racket usa 'define', OCaml usa 'let'. Racket anida, OCaml es más compacto.",
        "Similitudes: Extraen título y género. Diferencias: Racket usa 'let' con 'car'/'cdr', OCaml usa desestructuración directa en '(titulo, genero)'. OCaml es más elegante, Racket más explícito.",
        "Similitudes: Verifican género \"epica\". Diferencias: Racket usa 'string=?', OCaml usa '='. Racket anida 'if', OCaml usa 'then'.",
        "Similitudes: Concatenan \"Epica: \". Diferencias: Racket usa 'string-append', OCaml usa '^'. OCaml es más conciso.",
        "Similitudes: Verifican género \"leyenda\". Diferencias: Racket usa 'if' anidado, OCaml usa 'else if'. OCaml es más lineal.",
        "Similitudes: Concatenan \"Leyenda: \". Diferencias: Racket usa 'string-append', OCaml usa '^'.",
        "Similitudes: Casos por defecto. Diferencias: Racket usa 'if' anidado, OCaml usa 'else'. OCaml es más directo.",
        "Similitudes: Concatenan \"Mito: \". Diferencias: Racket usa 'string-append', OCaml usa '^'. Racket cierra con paréntesis, OCaml con línea final.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Mapean resúmenes. Diferencias: Racket usa 'define' y 'map', OCaml usa 'let' y 'List.map'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican mapeo. Diferencias: Racket usa 'generar-resumen', OCaml usa 'generar_resumen'. OCaml requiere 'List', Racket es más directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Verifican resúmenes largos. Diferencias: Racket usa 'define', OCaml usa 'let'. Racket anida, OCaml es compacto.",
        "Similitudes: Comparan longitud. Diferencias: Racket usa 'string-length', OCaml usa 'String.length'. Ambos son similares, pero OCaml usa módulo 'String'.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Filtran resúmenes largos. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican filtrado. Diferencias: Racket usa 'resumen-largo?', OCaml usa 'resumen_largo'. OCaml requiere 'List'.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Cuentan palabras. Diferencias: Racket usa 'define' y 'foldl', OCaml usa 'let' y 'List.fold_left'. Racket anida, OCaml es compacto.",
        "Similitudes: Inician acumulación. Diferencias: Racket usa 'lambda (s acc)', OCaml usa '(fun acc s ->'. OCaml invierte argumentos, Racket es más estándar.",
        "Similitudes: Suman palabras. Diferencias: Racket usa 'length' y 'string-split', OCaml usa 'List.length' y 'String.split_on_char'. OCaml usa módulos explícitos.",
        "Similitudes: Completan acumulación. Diferencias: Racket usa '0 lst))', OCaml usa ') 0 lst'. Racket anida más, OCaml es lineal.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con sintaxis lineal. Racket es más visual, OCaml más compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket usa paréntesis anidados, OCaml usa sintaxis plana. Ambos logran el mismo resultado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Evalúan con la misma lista, dando 8. Diferencias: Racket usa paréntesis y '.', OCaml usa punto y coma y comas. Racket es más uniforme, OCaml más variado."
      ]
    },
    "ejercicio-7": {
      "title": "Filtrar instrumentos con vocal final, mapear a frecuencias, filtrar pares, mapear a notas y componer melodía en una orquesta sobrenatural",
      "racket": {
        "lines": [
          "(define (termina-vocal? s)",
          "  (let ([ultima (string-ref (string-downcase s) (- (string-length s) 1))])",
          "    (member ultima '(#\\a #\\e #\\i #\\o #\\u))))",
          "",
          "(define (filtrar-termina-vocal lst)",
          "  (filter (lambda (p) (termina-vocal? (car p))) lst))",
          "",
          "(define (asignar-frecuencia p)",
          "  (let ([instrumento (car p)] [tipo (cdr p)])",
          "    (cond [(string=? tipo \"cuerda\") (* (string-length instrumento) 10)]",
          "          [(string=? tipo \"viento\") (* (string-length instrumento) 15)]",
          "          [else (* (string-length instrumento) 20)]))",
          "",
          "(define (mapear-frecuencias lst)",
          "  (map asignar-frecuencia lst))",
          "",
          "(define (frecuencia-par? n)",
          "  (even? n))",
          "",
          "(define (filtrar-frecuencias-pares lst)",
          "  (filter frecuencia-par? lst))",
          "",
          "(define (mapear-notas lst)",
          "  (map (lambda (f)",
          "         (cond [(> f 100) \"DO\"]",
          "               [(> f 50) \"RE\"]",
          "               [else \"MI\"]))",
          "       lst))",
          "",
          "(define (componer-melodia lst)",
          "  (foldl (lambda (nota acc)",
          "           (let ([len (string-length nota)])",
          "             (if (> len 2)",
          "                 (string-append acc nota \"-\")",
          "                 (if (< len 2)",
          "                     (string-append acc nota \"!\")",
          "                     (string-append acc nota)))))",
          "         \"\" lst))",
          "",
          "(define (compuesta-siete lst)",
          "  (componer-melodia (mapear-notas (filtrar-frecuencias-pares (mapear-frecuencias (filtrar-termina-vocal lst)))))",
          "",
          "(compuesta-siete '((\"violin\" . \"cuerda\") (\"flauta\" . \"viento\") (\"tambor\" . \"percusión\") (\"arpa\" . \"cuerda\") (\"oboe\" . \"viento\")))"
        ]
      },
      "ocaml": {
        "lines": [
          "let termina_vocal s =",
          "  let ultima = Char.lowercase_ascii s.[String.length s - 1] in",
          "  List.mem ultima ['a'; 'e'; 'i'; 'o'; 'u']",
          ";;",
          "",
          "let filtrar_termina_vocal lst =",
          "  List.filter (fun (instrumento, _) -> termina_vocal instrumento) lst",
          ";;",
          "",
          "let asignar_frecuencia (instrumento, tipo) =",
          "  match tipo with",
          "  | \"cuerda\" -> (String.length instrumento) * 10",
          "  | \"viento\" -> (String.length instrumento) * 15",
          "  | _ -> (String.length instrumento) * 20",
          ";;",
          "",
          "let mapear_frecuencias lst =",
          "  List.map asignar_frecuencia lst",
          ";;",
          "",
          "let frecuencia_par n =",
          "  n mod 2 = 0",
          ";;",
          "",
          "let filtrar_frecuencias_pares lst =",
          "  List.filter frecuencia_par lst",
          ";;",
          "",
          "let mapear_notas lst =",
          "  List.map (fun f ->",
          "    if f > 100 then \"DO\"",
          "    else if f > 50 then \"RE\"",
          "    else \"MI\"",
          "  ) lst",
          ";;",
          "",
          "let componer_melodia lst =",
          "  List.fold_left (fun acc nota ->",
          "    let len = String.length nota in",
          "    if len > 2 then",
          "      acc ^ nota ^ \"-\"",
          "    else if len < 2 then",
          "      acc ^ nota ^ \"!\"",
          "    else",
          "      acc ^ nota",
          "  ) \"\" lst",
          ";;",
          "",
          "let compuesta_siete lst =",
          "  componer_melodia (mapear_notas (filtrar_frecuencias_pares (mapear_frecuencias (filtrar_termina_vocal lst))))",
          ";;",
          "",
          "compuesta_siete [(\"violin\", \"cuerda\"); (\"flauta\", \"viento\"); (\"tambor\", \"percusión\"); (\"arpa\", \"cuerda\"); (\"oboe\", \"viento\")]"
        ]
      },
      "explanations_racket": [
        "Imagina que eres un director en una orquesta de sombras sobrenaturales, seleccionando instrumentos malditos. La línea '(define (termina-vocal? s)' crea un hechizo auxiliar 'termina-vocal?' que toma una cadena 's', como \"violin\". 'define' registra la instrucción, como anotar un instrumento en un grimorio espectral. Este hechizo verifica si 's' termina en vocal, como elegir instrumentos con un tono maldito. Es útil para validar datos, como en un juego de horror donde seleccionas elementos por propiedades.",
        "'(let ([ultima (string-ref (string-downcase s) (- (string-length s) 1))])' usa 'let' para calcular la última letra de 's' (en minúsculas con 'string-downcase', extraída con 'string-ref' en la posición 'string-length s - 1'), como inspeccionar un instrumento encantado. 'let' organiza variables locales, útil para cálculos en juegos.",
        "'(member ultima '(#\\a #\\e #\\i #\\o #\\u))))' verifica si la última letra está en la lista de vocales. Para \"flauta\", 'a' es vocal, devolviendo verdadero. Esto se usa para filtrar datos, como en sistemas narrativos. Los paréntesis cierran 'member', 'let', y la función, como sellar un hechizo oscuro.",
        "Línea en blanco, como un espacio en el grimorio, organiza el código, mejorando la legibilidad.",
        "'(define (filtrar-termina-vocal lst)' crea un hechizo 'filtrar-termina-vocal' que toma una lista 'lst' de pares, como '((\"flauta\" . \"viento\"))'. Filtra instrumentos que terminan en vocal, como elegir los más malditos. Es útil para subseleccionar datos, como en juegos de horror.",
        "'(filter (lambda (p) (termina-vocal? (car p))) lst))' usa 'filter' con una mini-instrucción 'lambda (p)' que aplica 'termina-vocal?' al instrumento ('car p'), dejando pares como '(\"flauta\" . \"viento\")', '(\"arpa\" . \"cuerda\")', '(\"oboe\" . \"viento\")'. Es como un colador espectral. Los paréntesis cierran 'lambda', 'filter', y la función.",
        "Línea en blanco para claridad, como un respiro en el grimorio.",
        "'(define (asignar-frecuencia p)' crea un hechizo 'asignar-frecuencia' que toma un par 'p', como '(\"flauta\" . \"viento\")', para asignar una frecuencia espectral según el tipo, como ajustar un instrumento maldito.",
        "'(let ([instrumento (car p)] [tipo (cdr p)])' extrae el instrumento y tipo con 'let', como abrir un cofre encantado para inspeccionar su contenido. 'let' organiza variables locales.",
        "'(cond [(string=? tipo \"cuerda\") (* (string-length instrumento) 10)]' asigna una frecuencia multiplicando la longitud del instrumento por 10 si es \"cuerda\", como \"arpa\" (4 letras → 40). 'cond' permite múltiples casos, como clasificar tonos oscuros.",
        "'[(string=? tipo \"viento\") (* (string-length instrumento) 15)]' asigna frecuencia por 15 para \"viento\", como \"flauta\" (6 letras → 90).",
        "'[else (* (string-length instrumento) 20)])' asigna frecuencia por 20 por defecto, como para \"percusión\". Los paréntesis cierran 'cond' y 'let'.",
        "Línea en blanco para organizar.",
        "'(define (mapear-frecuencias lst)' crea un hechizo 'mapear-frecuencias' que aplica 'asignar-frecuencia' a cada par, como ajustar todos los instrumentos malditos.",
        "'(map asignar-frecuencia lst))' usa 'map' para transformar pares en frecuencias (\"flauta\" → 90, \"arpa\" → 40, \"oboe\" → 75). Es como un ritual que afina tonos espectrales. Los paréntesis cierran 'map' y la función.",
        "Línea en blanco para claridad.",
        "'(define (frecuencia-par? n)' crea un hechizo 'frecuencia-par?' que verifica si una frecuencia 'n' es par, como seleccionar tonos con resonancia sobrenatural.",
        "'(even? n))' usa 'even?' para verificar si 'n' es par, como 40 (verdadero). Es útil para filtrar datos numéricos, como en juegos de horror. Los paréntesis cierran la función.",
        "Línea en blanco para organizar.",
        "'(define (filtrar-frecuencias-pares lst)' crea un hechizo 'filtrar-frecuencias-pares' que filtra frecuencias pares, como elegir tonos malditos resonantes.",
        "'(filter frecuencia-par? lst))' aplica 'filter' con 'frecuencia-par?', dejando frecuencias pares (40 para \"arpa\"). Es como un colador espectral. Los paréntesis cierran 'filter' y la función.",
        "Línea en blanco para claridad.",
        "'(define (mapear-notas lst)' crea un hechizo 'mapear-notas' que transforma frecuencias en notas musicales, como transcribir tonos malditos a una partitura.",
        "'(map (lambda (f)' inicia el mapeo con 'lambda (f)', como un escriba sobrenatural asignando notas.",
        "'(cond [(> f 100) \"DO\"]' asigna \"DO\" a frecuencias mayores a 100, como un tono grave y maldito.",
        "'[(> f 50) \"RE\"]' asigna \"RE\" a frecuencias entre 51 y 100, como un tono medio espectral.",
        "'[else \"MI\"]))' asigna \"MI\" por defecto, como un tono agudo. Los paréntesis cierran 'cond' y 'lambda'.",
        "'lst))' aplica 'map' a la lista, completando el hechizo.",
        "Línea en blanco para organizar.",
        "'(define (componer-melodia lst)' crea un hechizo 'componer-melodia' que acumula notas en una melodía codificada, como componer una sinfonía maldita.",
        "'(foldl (lambda (nota acc)' inicia una acumulación con 'foldl', usando 'lambda (nota acc)' para procesar cada nota y acumulador, como ensamblar una partitura.",
        "'(let ([len (string-length nota)])' calcula la longitud de la nota, como medir su resonancia sobrenatural.",
        "'(if (> len 2)' verifica si la nota tiene más de 2 caracteres, como un tono largo y ominoso.",
        "'(string-append acc nota \"-\")' concatena la nota con un guión si es larga, como \"DO-\".",
        "'(if (< len 2)' verifica si la nota tiene menos de 2 caracteres, como un tono corto y agudo.",
        "'(string-append acc nota \"!\")' concatena con un signo de exclamación si es corta.",
        "'(string-append acc nota)))))' concatena la nota sola por defecto, cerrando los 'if', 'let', 'lambda', y 'foldl'. Los paréntesis sellan la melodía.",
        "Línea en blanco para organizar.",
        "'(define (compuesta-siete lst)' crea un hechizo 'compuesta-siete' que combina todos los pasos, como un ritual completo para la sinfonía maldita.",
        "'(componer-melodia (mapear-notas (filtrar-frecuencias-pares (mapear-frecuencias (filtrar-termina-vocal lst)))))' encadena los hechizos, dando \"RE-DO-REMI\" para la lista dada. Es útil en flujos de datos, como en juegos de horror. Los paréntesis cierran la composición.",
        "Línea en blanco para organizar.",
        "'(compuesta-siete '((\"violin\" . \"cuerda\") (\"flauta\" . \"viento\") (\"tambor\" . \"percusión\") (\"arpa\" . \"cuerda\") (\"oboe\" . \"viento\")))' invoca el hechizo, dando \"RE-DO-REMI\". Es como probar la sinfonía en un ritual sobrenatural. Útil para pruebas en juegos."
      ],
      "explanations_ocaml": [
        "En la orquesta de sombras sobrenaturales, 'let termina_vocal s =' define un hechizo auxiliar 'termina_vocal' que toma una cadena 's'. 'let' registra la instrucción en OCaml, como anotar un instrumento en un grimorio. Verifica si 's' termina en vocal, como seleccionar instrumentos malditos. Es útil para validar datos, como en juegos de horror.",
        "'let ultima = Char.lowercase_ascii s.[String.length s - 1] in' calcula la última letra de 's' en minúsculas, como inspeccionar un instrumento encantado. 'let ... in' organiza variables locales.",
        "'List.mem ultima ['a'; 'e'; 'i'; 'o'; 'u']' verifica si la última letra es vocal. Para \"flauta\", 'a' devuelve verdadero. Es útil para filtrar, como en sistemas narrativos.",
        "';;' cierra la definición, como un sello en un grimorio, esencial en OCaml para separar funciones.",
        "Línea en blanco para claridad, como un espacio en el grimorio.",
        "'let filtrar_termina_vocal lst =' define un hechizo 'filtrar_termina_vocal' que filtra pares con instrumentos que terminan en vocal, como elegir los más malditos.",
        "'List.filter (fun (instrumento, _) -> termina_vocal instrumento) lst' aplica 'List.filter' con una mini-instrucción que usa 'termina_vocal' en el instrumento, dejando pares como '(\"flauta\", \"viento\")'. Es como un colador espectral.",
        "';;' cierra la definición, como un sello en OCaml.",
        "Línea en blanco para organizar.",
        "'let asignar_frecuencia (instrumento, tipo) =' define un hechizo 'asignar_frecuencia' que asigna frecuencias según el tipo, como ajustar un instrumento maldito.",
        "'match tipo with' inicia una estructura de coincidencia para clasificar el tipo, como inspeccionar un instrumento en un ritual.",
        "'| \"cuerda\" -> (String.length instrumento) * 10' asigna frecuencia por 10 para \"cuerda\", como \"arpa\" (40).",
        "'| \"viento\" -> (String.length instrumento) * 15' asigna frecuencia por 15 para \"viento\", como \"flauta\" (90).",
        "'| _ -> (String.length instrumento) * 20' asigna frecuencia por 20 por defecto.",
        "';;' cierra la definición, asegurando claridad.",
        "Línea en blanco para organizar.",
        "'let mapear_frecuencias lst =' define un hechizo 'mapear_frecuencias' que aplica 'asignar_frecuencia' a cada par, como afinar todos los instrumentos.",
        "'List.map asignar_frecuencia lst' transforma pares en frecuencias (\"flauta\" → 90, \"arpa\" → 40, \"oboe\" → 75). Es como un ritual de afinación espectral.",
        "';;' cierra la definición, como un sello.",
        "Línea en blanco para claridad.",
        "'let frecuencia_par n =' define un hechizo 'frecuencia_par' que verifica si una frecuencia es par, como seleccionar tonos resonantes.",
        "'n mod 2 = 0' verifica paridad, como 40 (verdadero). Es útil para filtrar datos numéricos.",
        "';;' cierra la definición.",
        "Línea en blanco para organizar.",
        "'let filtrar_frecuencias_pares lst =' define un hechizo 'filtrar_frecuencias_pares' que filtra frecuencias pares, como elegir tonos malditos.",
        "'List.filter frecuencia_par lst' aplica 'List.filter' con 'frecuencia_par', dejando frecuencias pares (40).",
        "';;' cierra la definición.",
        "Línea en blanco para organizar.",
        "'let mapear_notas lst =' define un hechizo 'mapear_notas' que transforma frecuencias en notas, como transcribir a una partitura maldita.",
        "'List.map (fun f ->' inicia el mapeo con una mini-instrucción para cada frecuencia.",
        "'if f > 100 then \"DO\"' asigna \"DO\" a frecuencias mayores a 100.",
        "'else if f > 50 then \"RE\"' asigna \"RE\" a frecuencias entre 51 y 100.",
        "'else \"MI\"' asigna \"MI\" por defecto.",
        "') lst' aplica 'List.map' a la lista, cerrando el hechizo.",
        "';;' cierra la definición.",
        "Línea en blanco para organizar.",
        "'let componer_melodia lst =' define un hechizo 'componer_melodia' que acumula notas en una melodía codificada, como componer una sinfonía maldita.",
        "'List.fold_left (fun acc nota ->' inicia una acumulación con 'List.fold_left', procesando cada nota y acumulador.",
        "'let len = String.length nota in' calcula la longitud de la nota, como medir su resonancia.",
        "'if len > 2 then' verifica si la nota es larga.",
        "'acc ^ nota ^ \"-\"' concatena con un guión si es larga.",
        "'else if len < 2 then' verifica si la nota es corta.",
        "'acc ^ nota ^ \"!\"' concatena con un signo de exclamación si es corta.",
        "'else acc ^ nota' concatena la nota sola por defecto.",
        "') \"\" lst' inicia con una cadena vacía y aplica a 'lst', cerrando 'List.fold_left'.",
        "';;' cierra la definición.",
        "Línea en blanco para organizar.",
        "'let compuesta_siete lst =' define un hechizo 'compuesta_siete' que combina los pasos, como un ritual completo.",
        "'componer_melodia (mapear_notas (filtrar_frecuencias_pares (mapear_frecuencias (filtrar_termina_vocal lst))))' encadena los hechizos, dando \"RE-DO-REMI\".",
        "';;' cierra la definición.",
        "Línea en blanco para separar.",
        "'compuesta_siete [(\"violin\", \"cuerda\"); (\"flauta\", \"viento\"); (\"tambor\", \"percusión\"); (\"arpa\", \"cuerda\"); (\"oboe\", \"viento\")]' invoca el hechizo, dando \"RE-DO-REMI\". Es como probar la sinfonía."
      ],
      "comparisons": [
        "Similitudes: Verifican si termina en vocal. Diferencias: Racket usa 'define' y 'string-ref', OCaml usa 'let' y 's.[String.length s - 1]'. Racket anida, OCaml es más lineal.",
        "Similitudes: Calculan última letra. Diferencias: Racket usa 'let' con 'string-downcase', OCaml usa 'let ... in' con 'Char.lowercase_ascii'. OCaml es más conciso.",
        "Similitudes: Comparan con vocales. Diferencias: Racket usa 'member', OCaml usa 'List.mem'. Racket anida más, OCaml es directo.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Filtran instrumentos con vocal final. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican filtrado. Diferencias: Racket usa 'lambda (p)' y 'car', OCaml usa '(fun (instrumento, _))'. OCaml ignora el segundo elemento explícitamente.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Asignan frecuencias según tipo. Diferencias: Racket usa 'define' y 'cond', OCaml usa 'let' y 'match'. OCaml es más elegante, Racket más explícito.",
        "Similitudes: Extraen instrumento y tipo. Diferencias: Racket usa 'let' con 'car'/'cdr', OCaml usa desestructuración directa. OCaml es más conciso.",
        "Similitudes: Verifican tipo \"cuerda\". Diferencias: Racket usa 'string=?', OCaml usa patrón 'cuerda'. OCaml es más directo.",
        "Similitudes: Verifican tipo \"viento\". Diferencias: Racket usa 'string=?', OCaml usa patrón 'viento'.",
        "Similitudes: Casos por defecto. Diferencias: Racket usa 'else', OCaml usa '_'. OCaml es más conciso.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Mapean frecuencias. Diferencias: Racket usa 'define' y 'map', OCaml usa 'let' y 'List.map'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican mapeo. Diferencias: Racket usa 'asignar-frecuencia', OCaml usa 'asignar_frecuencia'. OCaml requiere 'List'.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Verifican paridad de frecuencias. Diferencias: Racket usa 'define' y 'even?', OCaml usa 'let' y 'mod 2 = 0'. OCaml es más matemático.",
        "Similitudes: Comparan paridad. Diferencias: Racket usa 'even?', OCaml usa 'mod 2 = 0'. OCaml es más conciso.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Filtran frecuencias pares. Diferencias: Racket usa 'define' y 'filter', OCaml usa 'let' y 'List.filter'. Racket anida, OCaml es lineal.",
        "Similitudes: Aplican filtrado. Diferencias: Racket usa 'frecuencia-par?', OCaml usa 'frecuencia_par'. OCaml requiere 'List'.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Mapean notas. Diferencias: Racket usa 'define' y 'map', OCaml usa 'let' y 'List.map'. Racket anida, OCaml es lineal.",
        "Similitudes: Inician mapeo. Diferencias: Racket usa 'lambda (f)', OCaml usa '(fun f ->'. OCaml es más conciso.",
        "Similitudes: Verifican frecuencia > 100. Diferencias: Racket usa 'cond', OCaml usa 'if'. OCaml es más lineal.",
        "Similitudes: Verifican frecuencia > 50. Diferencias: Racket usa 'cond', OCaml usa 'else if'. OCaml es más directo.",
        "Similitudes: Casos por defecto. Diferencias: Racket usa 'else', OCaml usa 'else'.",
        "Similitudes: Completan mapeo. Diferencias: Racket usa 'lst))', OCaml usa ') lst'. Racket anida más.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Componen melodía. Diferencias: Racket usa 'define' y 'foldl', OCaml usa 'let' y 'List.fold_left'. Racket anida, OCaml es compacto.",
        "Similitudes: Inician acumulación. Diferencias: Racket usa 'lambda (nota acc)', OCaml usa '(fun acc nota ->'. OCaml invierte argumentos.",
        "Similitudes: Calculan longitud de nota. Diferencias: Racket usa 'let', OCaml usa 'let ... in'. OCaml es más lineal.",
        "Similitudes: Verifican longitud > 2. Diferencias: Racket usa 'if', OCaml usa 'if ... then'.",
        "Similitudes: Concatenan con guión. Diferencias: Racket usa 'string-append', OCaml usa '^'. OCaml es más conciso.",
        "Similitudes: Verifican longitud < 2. Diferencias: Racket usa 'if' anidado, OCaml usa 'else if'.",
        "Similitudes: Concatenan con exclamación. Diferencias: Racket usa 'string-append', OCaml usa '^'.",
        "Similitudes: Concatenan nota sola. Diferencias: Racket usa 'if' anidado, OCaml usa 'else'.",
        "Similitudes: Completan acumulación. Diferencias: Racket usa '\"\" lst))', OCaml usa ') \"\" lst'. Racket anida más.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Definen función compuesta. Diferencias: Racket usa 'define' con paréntesis, OCaml usa 'let' con sintaxis lineal. Racket es más visual, OCaml más compacto.",
        "Similitudes: Encadenan funciones. Diferencias: Racket usa paréntesis anidados, OCaml usa sintaxis plana. Ambos logran el mismo resultado.",
        "Similitudes: Cierres de definición. Diferencias: Racket usa ')', OCaml usa ';;'.",
        "Similitudes: Líneas en blanco organizan. Diferencias: Ninguna.",
        "Similitudes: Evalúan con la misma lista, dando \"RE-DO-REMI\". Diferencias: Racket usa paréntesis y '.', OCaml usa punto y coma y comas. Racket es más uniforme, OCaml más variado."
      ]
    }
  }
}
