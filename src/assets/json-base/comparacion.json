{
  "paradigma-funcional": {
    "ejercicio-1": {
      "title": "Sumar distancias de un viaje",
      "racket": {
        "lines": ["(+ 5 3)", "(+ 2 7)", "(+ 10 4)", "(+ 1 6)", "(+ 8 2)"]
      },
      "ocaml": {
        "lines": ["5 + 3", "2 + 7", "10 + 4", "1 + 6", "8 + 2"]
      },
      "explanations_racket": [
        "Calcula la distancia sumando 5 km y 3 km con '+', resultando en 8. La notación prefija (+ 5 3) en Racket enfatiza la suma como función pura, ideal para modelar tramos de un viaje, como ir a la escuela y volver, con resultados predecibles y sin estado.",
        "Suma 2 km y 7 km con '+', dando 9. La notación (+ 2 7) muestra cómo Racket trata la suma como función, útil para caminatas cortas, como de casa al parque, manteniendo inmutabilidad.",
        "Suma 10 km y 4 km, resultando en 14. La expresión (+ 10 4) refuerza la pureza funcional, modelando viajes largos con determinismo para principiantes.",
        "Suma 1 km y 6 km, dando 7. La notación (+ 1 6) es clara para tramos pequeños, como ir a una tienda, sin alterar estado.",
        "Suma 8 km y 2 km, resultando en 10. (+ 8 2) enseña cómo sumar distancias, como paseos matutinos y vespertinos, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula la distancia sumando 5 km y 3 km con '+', dando 8. La notación infija 5 + 3 en OCaml es intuitiva, como matemáticas escolares, ideal para modelar tramos de un viaje con pureza y sin efectos secundarios.",
        "Suma 2 km y 7 km, resultando en 9. La expresión 2 + 7 es simple, como sumar distancias de caminatas diarias, con tipado estático asegurando enteros.",
        "Suma 10 km y 4 km, dando 14. La expresión 10 + 4 modela viajes largos, manteniendo determinismo y facilidad para principiantes.",
        "Suma 1 km y 6 km, resultando en 7. La notación 1 + 6 es clara para tramos cortos, como ir al mercado, con pureza funcional.",
        "Suma 8 km y 2 km, dando 10. La expresión 8 + 2 representa caminatas combinadas, con OCaml asegurando resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan 5 + 3 = 8, con pureza funcional, usando suma para modelar distancias de un viaje. Diferencias: Racket usa notación prefija (+ 5 3) con paréntesis, explícita como función, mientras que OCaml usa infija 5 + 3, más concisa y matemática. Racket tiene tipado dinámico, OCaml infiere enteros.",
        "Similitudes: Ambas calculan 2 + 7 = 9, con pureza funcional, para caminatas cortas. Diferencias: Racket usa prefija (+ 2 7), destacando la función, mientras que OCaml usa infija 2 + 7, más natural. Racket dinámico, OCaml estático, pero resultado idéntico.",
        "Similitudes: Ambas calculan 10 + 4 = 14, con pureza funcional, modelando viajes largos. Diferencias: Racket usa prefija (+ 10 4), explícita, mientras que OCaml usa infija 10 + 4, concisa. Tipado dinámico en Racket, estático en OCaml.",
        "Similitudes: Ambas calculan 1 + 6 = 7, con pureza funcional, para tramos pequeños. Diferencias: Racket usa prefija (+ 1 6), mientras que OCaml usa infija 1 + 6, más intuitiva. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 8 + 2 = 10, con pureza funcional, para paseos combinados. Diferencias: Racket usa prefija (+ 8 2), explícita, mientras que OCaml usa infija 8 + 2, concisa. Tipado dinámico vs. estático, pero idéntico."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar paridad con resto",
      "racket": {
        "lines": [
          "(remainder 7 2)",
          "(remainder 4 2)",
          "(remainder 9 2)",
          "(remainder 6 2)",
          "(remainder 3 2)"
        ]
      },
      "ocaml": {
        "lines": ["7 mod 2", "4 mod 2", "9 mod 2", "6 mod 2", "3 mod 2"]
      },
      "explanations_racket": [
        "Calcula el resto de 7 ÷ 2 con 'remainder', dando 1 (impar). La notación prefija (remainder 7 2) muestra la operación como función pura, ideal para verificar si un número de sillas deja sobrantes en pares, manteniendo inmutabilidad.",
        "Calcula 4 ÷ 2, dando 0 (par). (remainder 4 2) enseña paridad, como dividir dulces equitativamente, con pureza funcional y sin efectos secundarios.",
        "Calcula 9 ÷ 2, resultando en 1 (impar). (remainder 9 2) modela casos como organizar invitados, asegurando determinismo para principiantes.",
        "Calcula 6 ÷ 2, dando 0 (par). (remainder 6 2) es útil para dividir objetos en grupos, manteniendo la inmutabilidad del estado.",
        "Calcula 3 ÷ 2, dando 1 (impar). (remainder 3 2) refuerza paridad, como clasificar frutas, con pureza funcional y resultados predecibles."
      ],
      "explanations_ocaml": [
        "Calcula el resto de 7 ÷ 2 con 'mod', dando 1 (impar). La notación infija 7 mod 2 es intuitiva, como verificar sillas sobrantes, con pureza funcional y sin efectos secundarios.",
        "Calcula 4 ÷ 2, dando 0 (par). 4 mod 2 modela división equitativa, como repartir dulces, con tipado estático asegurando enteros.",
        "Calcula 9 ÷ 2, resultando en 1 (impar). 9 mod 2 es útil para organizar grupos, manteniendo determinismo y facilidad para principiantes.",
        "Calcula 6 ÷ 2, dando 0 (par). 6 mod 2 enseña división en pares, como clasificar objetos, con pureza funcional.",
        "Calcula 3 ÷ 2, dando 1 (impar). 3 mod 2 modela paridad, como contar frutas sobrantes, con resultados predecibles y sin estado."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan resto de 7 ÷ 2 = 1, con pureza funcional, verificando imparidad. Diferencias: Racket usa 'remainder' prefija, explícita, mientras que OCaml usa 'mod' infija, concisa. Racket dinámico, OCaml estático, pero resultado idéntico.",
        "Similitudes: Ambas calculan 4 ÷ 2 = 0, con pureza funcional, verificando paridad. Diferencias: Racket usa 'remainder' prefija, mientras que OCaml usa 'mod' infija. Tipado dinámico vs. estático, pero idéntico.",
        "Similitudes: Ambas calculan 9 ÷ 2 = 1, con pureza funcional, para imparidad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 6 ÷ 2 = 0, con pureza funcional, para paridad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 3 ÷ 2 = 1, con pureza funcional, verificando imparidad. Diferencias: Racket usa 'remainder' prefija, OCaml usa 'mod' infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-3": {
      "title": "Comparar inventarios con sumas",
      "racket": {
        "lines": [
          "(> (+ 12 4) 15)",
          "(> (+ 5 5) 12)",
          "(> (+ 15 3) 10)",
          "(> (+ 3 3) 6)",
          "(> (+ 9 6) 8)"
        ]
      },
      "ocaml": {
        "lines": [
          "12 + 4 > 15",
          "5 + 5 > 12",
          "15 + 3 > 10",
          "3 + 3 > 6",
          "9 + 6 > 8"
        ]
      },
      "explanations_racket": [
        "Compara el resultado de 12 + 4 = 16 con 15 usando '>', dando #t. La notación prefija (> (+ 12 4) 15) en Racket muestra la comparación como función pura, ideal para evaluar inventarios con nuevas unidades frente a la competencia, manteniendo inmutabilidad.",
        "Compara 5 + 5 = 10 con 12, dando #f. (> (+ 5 5) 12) enseña decisiones funcionales, como verificar existencias, con determinismo y sin efectos secundarios.",
        "Compara 15 + 3 = 18 con 10, resultando en #t. (> (+ 15 3) 10) modela comparar cantidades de productos, asegurando pureza funcional.",
        "Compara 3 + 3 = 6 con 6, dando #f. (> (+ 3 3) 6) enseña que igual no es mayor, útil para inventarios equilibrados, con resultados predecibles.",
        "Compara 9 + 6 = 15 con 8, dando #t. (> (+ 9 6) 8) modela comparar ventas con adiciones, manteniendo la inmutabilidad del estado."
      ],
      "explanations_ocaml": [
        "Compara 12 + 4 = 16 con 15 usando '>', dando true. La notación infija 12 + 4 > 15 es intuitiva, como comparar inventarios con nuevas unidades, con pureza funcional y sin efectos secundarios.",
        "Compara 5 + 5 = 10 con 12, dando false. 5 + 5 > 12 modela decisiones de stock, con tipado estático asegurando enteros y determinismo.",
        "Compara 15 + 3 = 18 con 10, dando true. 15 + 3 > 10 es útil para comparar cantidades, manteniendo pureza funcional para principiantes.",
        "Compara 3 + 3 = 6 con 6, dando false. 3 + 3 > 6 enseña que igual no es mayor, con pureza y sin estado.",
        "Compara 9 + 6 = 15 con 8, dando true. 9 + 6 > 8 modela comparar ventas con adiciones, asegurando resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan 12 + 4 = 16 > 15, dando #t/true, con pureza funcional, para inventarios con sumas. Diferencias: Racket usa '>' prefija con paréntesis anidados (> (+ 12 4) 15), explícita, mientras que OCaml usa infija 12 + 4 > 15, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 5 + 5 = 10 > 12, dando #f/false, con pureza funcional, para existencias. Diferencias: Racket usa '>' prefija (> (+ 5 5) 12), OCaml infija 5 + 5 > 12. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 15 + 3 = 18 > 10, dando #t/true, con pureza funcional, para cantidades. Diferencias: Racket usa '>' prefija (> (+ 15 3) 10), OCaml infija 15 + 3 > 10. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 3 + 3 = 6 > 6, dando #f/false, con pureza funcional, para inventarios equilibrados. Diferencias: Racket usa '>' prefija (> (+ 3 3) 6), OCaml infija 3 + 3 > 6. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 9 + 6 = 15 > 8, dando #t/true, con pureza funcional, para ventas. Diferencias: Racket usa '>' prefija (> (+ 9 6) 8), OCaml infija 9 + 6 > 8. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-4": {
      "title": "Dividir ganancias netas",
      "racket": {
        "lines": [
          "(/ (- 20 10) 2)",
          "(/ (- 15 3) 4)",
          "(/ (- 18 10) 2)",
          "(/ (- 12 3) 3)",
          "(/ (- 24 4) 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "(20 - 10) / 2",
          "(15 - 3) / 4",
          "(18 - 10) / 2",
          "(12 - 3) / 3",
          "(24 - 4) / 5"
        ]
      },
      "explanations_racket": [
        "Calcula (20 - 10) / 2 con '/', dando 5. La notación prefija (/ (- 20 10) 2) en Racket muestra la división como función pura, ideal para repartir ganancias netas entre 2 personas, con inmutabilidad y determinismo.",
        "Calcula (15 - 3) / 4, dando 3. (/ (- 15 3) 4) modela dividir ganancias entre 4 personas, con pureza funcional y sin efectos secundarios.",
        "Calcula (18 - 10) / 2, resultando en 4. (/ (- 18 10) 2) enseña cómo dividir ingresos netos, como en proyectos, manteniendo inmutabilidad.",
        "Calcula (12 - 3) / 3, dando 3. (/ (- 12 3) 3) modela repartir beneficios entre 3, con resultados predecibles y sin estado.",
        "Calcula (24 - 4) / 5, dando 4. (/ (- 24 4) 5) representa dividir ganancias entre 5, con pureza funcional para escenarios más complejos."
      ],
      "explanations_ocaml": [
        "Calcula (20 - 10) / 2 con '/', dando 5. La notación infija (20 - 10) / 2 es intuitiva, como repartir ganancias netas entre 2, con pureza funcional y sin efectos secundarios.",
        "Calcula (15 - 3) / 4, dando 3. (15 - 3) / 4 modela dividir beneficios entre 4, con tipado estático asegurando enteros y determinismo.",
        "Calcula (18 - 10) / 2, resultando en 4. (18 - 10) / 2 enseña repartir ingresos netos, manteniendo pureza funcional.",
        "Calcula (12 - 3) / 3, dando 3. (12 - 3) / 3 modela dividir entre 3, con resultados predecibles y sin estado.",
        "Calcula (24 - 4) / 5, dando 4. (24 - 4) / 5 representa repartir entre 5, con OCaml asegurando cálculos predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan (20 - 10) / 2 = 5, con pureza funcional, para repartir ganancias. Diferencias: Racket usa '/' prefija (/ (- 20 10) 2), explícita, mientras que OCaml usa infija (20 - 10) / 2, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan (15 - 3) / 4 = 3, con pureza funcional, para beneficios. Diferencias: Racket usa '/' prefija (/ (- 15 3) 4), OCaml infija (15 - 3) / 4. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan (18 - 10) / 2 = 4, con pureza funcional, para ingresos netos. Diferencias: Racket usa '/' prefija (/ (- 18 10) 2), OCaml infija (18 - 10) / 2. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan (12 - 3) / 3 = 3, con pureza funcional, para dividir beneficios. Diferencias: Racket usa '/' prefija (/ (- 12 3) 3), OCaml infija (12 - 3) / 3. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan (24 - 4) / 5 = 4, con pureza funcional, para repartir entre 5. Diferencias: Racket usa '/' prefija (/ (- 24 4) 5), OCaml infija (24 - 4) / 5. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-5": {
      "title": "Comparar cálculos con igualdad",
      "racket": {
        "lines": [
          "(= (- (+ 5 3) 1) 7)",
          "(= (* 2 3) 7)",
          "(= (+ (* 4 2) 1) 9)",
          "(= (- 10 3) 6)",
          "(= (* 5 1) 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "(5 + 3 - 1) = 7",
          "(2 * 3) = 7",
          "((4 * 2) + 1) = 9",
          "(10 - 3) = 6",
          "(5 * 1) = 5"
        ]
      },
      "explanations_racket": [
        "Compara (5 + 3 - 1) = 7 con '=', dando #t (7 = 7). La notación prefija (= (- (+ 5 3) 1) 7) muestra igualdad como función pura, ideal para validar inventarios con operaciones compuestas, con inmutabilidad.",
        "Compara (2 * 3) = 7, dando #f (6 ≠ 7). (= (* 2 3) 7) enseña verificar resultados, como en cálculos de stock, con pureza funcional.",
        "Compara (4 * 2 + 1) = 9, dando #t (9 = 9). (= (+ (* 4 2) 1) 9) modela validar operaciones complejas, como en inventarios, sin efectos secundarios.",
        "Compara (10 - 3) = 6, dando #f (7 ≠ 6). (= (- 10 3) 6) enseña verificar diferencias, con resultados predecibles.",
        "Compara (5 * 1) = 5, dando #t (5 = 5). (= (* 5 1) 5) modela validar cálculos simples, manteniendo inmutabilidad."
      ],
      "explanations_ocaml": [
        "Compara (5 + 3 - 1) = 7 con '=', dando true (7 = 7). La notación infija (5 + 3 - 1) = 7 es intuitiva, como validar inventarios con operaciones, con pureza funcional.",
        "Compara (2 * 3) = 7, dando false (6 ≠ 7). (2 * 3) = 7 modela verificar cálculos, con tipado estático asegurando enteros.",
        "Compara ((4 * 2) + 1) = 9, dando true (9 = 9). ((4 * 2) + 1) = 9 valida operaciones complejas, manteniendo determinismo.",
        "Compara (10 - 3) = 6, dando false (7 ≠ 6). (10 - 3) = 6 enseña verificar diferencias, con pureza funcional.",
        "Compara (5 * 1) = 5, dando true (5 = 5). (5 * 1) = 5 modela validar cálculos simples, con resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan (5 + 3 - 1) = 7, dando #t/true, con pureza funcional, para validar inventarios. Diferencias: Racket usa '=' prefija (= (- (+ 5 3) 1) 7), explícita, mientras que OCaml usa infija (5 + 3 - 1) = 7, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan (2 * 3) = 7, dando #f/false, con pureza funcional, para cálculos. Diferencias: Racket usa '=' prefija (= (* 2 3) 7), OCaml infija (2 * 3) = 7. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan (4 * 2 + 1) = 9, dando #t/true, con pureza funcional, para operaciones complejas. Diferencias: Racket usa '=' prefija (= (+ (* 4 2) 1) 9), OCaml infija ((4 * 2) + 1) = 9. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan (10 - 3) = 6, dando #f/false, con pureza funcional, para diferencias. Diferencias: Racket usa '=' prefija (= (- 10 3) 6), OCaml infija (10 - 3) = 6. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan (5 * 1) = 5, dando #t/true, con pureza funcional, para cálculos simples. Diferencias: Racket usa '=' prefija (= (* 5 1) 5), OCaml infija (5 * 1) = 5. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-6": {
      "title": "Calcular distancias absolutas",
      "racket": {
        "lines": [
          "(abs (- (+ 5 3) 10))",
          "(abs (* -2 3))",
          "(abs (- 4 (+ 1 6)))",
          "(abs 0)",
          "(abs (- (* 3 4) 15))"
        ]
      },
      "ocaml": {
        "lines": [
          "abs (5 + 3 - 10)",
          "abs (-2 * 3)",
          "abs (4 - (1 + 6))",
          "abs 0",
          "abs ((3 * 4) - 15)"
        ]
      },
      "explanations_racket": [
        "Calcula |5 + 3 - 10| con 'abs', dando 2 (|8 - 10| = |-2|). La notación prefija (abs (- (+ 5 3) 10)) muestra el valor absoluto como función pura, ideal para medir desviaciones en mapas, con inmutabilidad.",
        "Calcula |-2 * 3| con 'abs', dando 6 (|-6|). (abs (* -2 3)) enseña manejar negativos, como en cálculos de desplazamiento, con pureza funcional.",
        "Calcula |4 - (1 + 6)|, dando 3 (|4 - 7| = |-3|). (abs (- 4 (+ 1 6))) modela desviaciones complejas, asegurando determinismo.",
        "Calcula |0| con 'abs', dando 0. (abs 0) es un caso base, útil para mediciones nulas, con pureza funcional.",
        "Calcula |(3 * 4) - 15| con 'abs', dando 3 (|12 - 15| = |-3|). (abs (- (* 3 4) 15)) modela cálculos anidados, como en mapas, sin efectos secundarios."
      ],
      "explanations_ocaml": [
        "Calcula |5 + 3 - 10| con 'abs', dando 2 (|8 - 10| = |-2|). La notación infija abs (5 + 3 - 10) es intuitiva, como medir desviaciones en mapas, con pureza funcional.",
        "Calcula |-2 * 3| con 'abs', dando 6 (|-6|). abs (-2 * 3) modela manejar negativos, con tipado estático asegurando enteros.",
        "Calcula |4 - (1 + 6)|, dando 3 (|4 - 7| = |-3|). abs (4 - (1 + 6)) valida desviaciones complejas, manteniendo determinismo.",
        "Calcula |0| con 'abs', dando 0. abs 0 es un caso base, con pureza funcional para mediciones nulas.",
        "Calcula |(3 * 4) - 15| con 'abs', dando 3 (|12 - 15| = |-3|). abs ((3 * 4) - 15) modela cálculos anidados, con resultados predecibles."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan |5 + 3 - 10| = 2, con pureza funcional, para desviaciones. Diferencias: Racket usa 'abs' prefija (abs (- (+ 5 3) 10)), explícita, mientras que OCaml usa infija abs (5 + 3 - 10), concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan |-2 * 3| = 6, con pureza funcional, para negativos. Diferencias: Racket usa 'abs' prefija (abs (* -2 3)), OCaml infija abs (-2 * 3). Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan |4 - (1 + 6)| = 3, con pureza funcional, para desviaciones complejas. Diferencias: Racket usa 'abs' prefija (abs (- 4 (+ 1 6))), OCaml infija abs (4 - (1 + 6)). Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan |0| = 0, con pureza funcional, para casos base. Diferencias: Racket usa 'abs' prefija (abs 0), OCaml infija abs 0. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan |(3 * 4) - 15| = 3, con pureza funcional, para cálculos anidados. Diferencias: Racket usa 'abs' prefija (abs (- (* 3 4) 15)), OCaml infija abs ((3 * 4) - 15). Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-7": {
      "title": "Calcular hipotenusas con raíz cuadrada",
      "racket": {
        "lines": [
          "(sqrt (+ (* 3 3) (* 4 4)))",
          "(sqrt (+ (* 5 5) (* 12 12)))",
          "(sqrt (+ (* 8 8) (* 6 6)))",
          "(sqrt (+ (* 7 7) (* 24 24)))",
          "(sqrt (+ (* 20 20) (* 21 21)))"
        ]
      },
      "ocaml": {
        "lines": [
          "sqrt (3.0 *. 3.0 +. 4.0 *. 4.0)",
          "sqrt (5.0 *. 5.0 +. 12.0 *. 12.0)",
          "sqrt (8.0 *. 8.0 +. 6.0 *. 6.0)",
          "sqrt (7.0 *. 7.0 +. 24.0 *. 24.0)",
          "sqrt (20.0 *. 20.0 +. 21.0 *. 21.0)"
        ]
      },
      "explanations_racket": [
        "Calcula √(3² + 4²) = √(9 + 16) = 5 con 'sqrt'. La notación prefija (sqrt (+ (* 3 3) (* 4 4))) muestra la raíz como función pura, ideal para hallar hipotenusas en diseño estructural, con inmutabilidad.",
        "Calcula √(5² + 12²) = √(25 + 144) = 13 con 'sqrt'. (sqrt (+ (* 5 5) (* 12 12))) modela triángulos rectángulos, con pureza funcional y determinismo.",
        "Calcula √(8² + 6²) = √(64 + 36) = 10 con 'sqrt'. (sqrt (+ (* 8 8) (* 6 6))) enseña cálculos complejos, como en ingeniería, sin efectos secundarios.",
        "Calcula √(7² + 24²) = √(49 + 576) = 25 con 'sqrt'. (sqrt (+ (* 7 7) (* 24 24))) modela triángulos grandes, con resultados predecibles.",
        "Calcula √(20² + 21²) = √(400 + 441) = 29 con 'sqrt'. (sqrt (+ (* 20 20) (* 21 21))) representa cálculos avanzados, como en estructuras, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula √(3.0² + 4.0²) = √(9 + 16) = 5 con 'sqrt'. La notación infija sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) es intuitiva, como hallar hipotenusas, con pureza funcional y tipado estático para flotantes.",
        "Calcula √(5.0² + 12.0²) = √(25 + 144) = 13 con 'sqrt'. sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) modela triángulos, con determinismo y sin estado.",
        "Calcula √(8.0² + 6.0²) = √(64 + 36) = 10 con 'sqrt'. sqrt (8.0 *. 8.0 +. 6.0 *. 6.0) enseña cálculos de ingeniería, con pureza funcional.",
        "Calcula √(7.0² + 24.0²) = √(49 + 576) = 25 con 'sqrt'. sqrt (7.0 *. 7.0 +. 24.0 *. 24.0) modela triángulos grandes, con resultados predecibles.",
        "Calcula √(20.0² + 21.0²) = √(400 + 441) = 29 con 'sqrt'. sqrt (20.0 *. 20.0 +. 21.0 *. 21.0) representa cálculos avanzados, con OCaml asegurando precisión."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan √(3² + 4²) = 5, con pureza funcional, para hipotenusas. Diferencias: Racket usa 'sqrt' prefija (sqrt (+ (* 3 3) (* 4 4))), explícita, mientras que OCaml usa infija sqrt (3.0 *. 3.0 +. 4.0 *. 4.0), con flotantes explícitos. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan √(5² + 12²) = 13, con pureza funcional, para triángulos. Diferencias: Racket usa 'sqrt' prefija, OCaml infija con flotantes (*. y +. operadores). Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan √(8² + 6²) = 10, con pureza funcional, para ingeniería. Diferencias: Racket usa 'sqrt' prefija, OCaml infija con flotantes. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan √(7² + 24²) = 25, con pureza funcional, para triángulos grandes. Diferencias: Racket usa 'sqrt' prefija, OCaml infija con flotantes. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan √(20² + 21²) = 29, con pureza funcional, para cálculos avanzados. Diferencias: Racket usa 'sqrt' prefija, OCaml infija con flotantes. Racket dinámico, OCaml estático."
      ]
    }
  },
  "expresiones": {
    "ejercicio-1": {
      "title": "Verificar igualdad de paquetes",
      "racket": {
        "lines": ["(= 8 8)", "(= 5 6)", "(= 7 7)", "(= 3 3)", "(= 9 10)"]
      },
      "ocaml": {
        "lines": ["8 = 8", "5 = 6", "7 = 7", "3 = 3", "9 = 10"]
      },
      "explanations_racket": [
        "Verifica si 8 = 8 con '=', dando #t. La notación prefija (= 8 8) en Racket muestra igualdad como función pura, ideal para comparar paquetes de galletas en inventarios.",
        "Verifica 5 = 6, dando #f. (= 5 6) enseña comparar cantidades distintas, como cajas de productos, con determinismo.",
        "Verifica 7 = 7, dando #t. (= 7 7) modela validar medidas iguales, como en control de calidad, con inmutabilidad.",
        "Verifica 3 = 3, dando #t. (= 3 3) es útil para confirmar inventarios, sin efectos secundarios.",
        "Verifica 9 = 10, dando #f. (= 9 10) enseña comparar cantidades distintas, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Verifica 8 = 8 con '=', dando true. La notación infija 8 = 8 es intuitiva, como comparar galletas, con pureza funcional.",
        "Verifica 5 = 6, dando false. 5 = 6 modela comparar cantidades, con tipado estático asegurando enteros.",
        "Verifica 7 = 7, dando true. 7 = 7 enseña validar medidas, con determinismo.",
        "Verifica 3 = 3, dando true. 3 = 3 es útil para inventarios, sin efectos secundarios.",
        "Verifica 9 = 10, dando false. 9 = 10 modela comparar cantidades distintas, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas verifican 8 = 8, dando #t/true, con pureza funcional, para comparar galletas. Diferencias: Racket usa '=' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas verifican 5 = 6, dando #f/false, con pureza funcional, para cantidades distintas. Diferencias: Racket usa '=' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas verifican 7 = 7, dando #t/true, con pureza funcional, para medidas. Diferencias: Racket usa '=' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas verifican 3 = 3, dando #t/true, con pureza funcional, para inventarios. Diferencias: Racket usa '=' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas verifican 9 = 10, dando #f/false, con pureza funcional, para cantidades distintas. Diferencias: Racket usa '=' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-2": {
      "title": "Comparar presupuesto con límite",
      "racket": {
        "lines": ["(> 15 10)", "(> 8 9)", "(> 12 5)", "(> 10 10)", "(> 20 15)"]
      },
      "ocaml": {
        "lines": ["15 > 10", "8 > 9", "12 > 5", "10 > 10", "20 > 15"]
      },
      "explanations_racket": [
        "Compara 15 > 10 con '>', dando #t. La notación prefija (> 15 10) en Racket muestra comparación como función pura, ideal para verificar presupuestos en planificación financiera.",
        "Compara 8 > 9, dando #f. (> 8 9) enseña decisiones de límites, con determinismo.",
        "Compara 12 > 5, dando #t. (> 12 5) modela comparar gastos, sin efectos secundarios.",
        "Compara 10 > 10, dando #f. (> 10 10) enseña que igual no es mayor, útil para presupuestos equilibrados.",
        "Compara 20 > 15, dando #t. (> 20 15) modela verificar excedentes, con inmutabilidad."
      ],
      "explanations_ocaml": [
        "Compara 15 > 10 con '>', dando true. La notación infija 15 > 10 es intuitiva, como verificar presupuestos, con pureza funcional.",
        "Compara 8 > 9, dando false. 8 > 9 modela decisiones de límites, con tipado estático.",
        "Compara 12 > 5, dando true. 12 > 5 es útil para comparar gastos, con determinismo.",
        "Compara 10 > 10, dando false. 10 > 10 enseña que igual no es mayor, con pureza.",
        "Compara 20 > 15, dando true. 20 > 15 modela verificar excedentes, sin efectos secundarios."
      ],
      "comparisons": [
        "Similitudes: Ambas comparan 15 > 10, dando #t/true, con pureza funcional, para presupuestos. Diferencias: Racket usa '>' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 8 > 9, dando #f/false, con pureza funcional, para límites. Diferencias: Racket usa '>' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 12 > 5, dando #t/true, con pureza funcional, para gastos. Diferencias: Racket usa '>' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas comparan 10 > 10, dando #f/false, con pureza funcional, para presupuestos equilibrados. Diferencias: Racket usa '>' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas comparan 20 > 15, dando #t/true, con pureza funcional, para excedentes. Diferencias: Racket usa '>' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-3": {
      "title": "Sumar distancias caminadas",
      "racket": {
        "lines": ["(+ 7 5)", "(+ 3 4)", "(+ 6 8)", "(+ 2 9)", "(+ 10 3)"]
      },
      "ocaml": {
        "lines": ["7 + 5", "3 + 4", "6 + 8", "2 + 9", "10 + 3"]
      },
      "explanations_racket": [
        "Calcula 7 + 5 con '+', dando 12. La notación prefija (+ 7 5) en Racket muestra suma como función pura, ideal para combinar distancias de caminatas.",
        "Suma 3 + 4, dando 7. (+ 3 4) modela tramos cortos, como ir al parque, con determinismo.",
        "Suma 6 + 8, dando 14. (+ 6 8) es útil para recorridos largos, sin efectos secundarios.",
        "Suma 2 + 9, dando 11. (+ 2 9) enseña sumar distancias variadas, con inmutabilidad.",
        "Suma 10 + 3, dando 13. (+ 10 3) modela combinar tramos, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 7 + 5 con '+', dando 12. La notación infija 7 + 5 es intuitiva, como sumar tramos de caminatas, con pureza funcional.",
        "Suma 3 + 4, dando 7. 3 + 4 modela tramos cortos, con tipado estático asegurando enteros.",
        "Suma 6 + 8, dando 14. 6 + 8 es útil para recorridos largos, con determinismo.",
        "Suma 2 + 9, dando 11. 2 + 9 enseña sumar distancias, sin efectos secundarios.",
        "Suma 10 + 3, dando 13. 10 + 3 modela combinar tramos, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan 7 + 5 = 12, con pureza funcional, para distancias de caminatas. Diferencias: Racket usa '+' prefija con paréntesis, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 3 + 4 = 7, con pureza funcional, para tramos cortos. Diferencias: Racket usa '+' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 6 + 8 = 14, con pureza funcional, para recorridos largos. Diferencias: Racket usa '+' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 2 + 9 = 11, con pureza funcional, para distancias variadas. Diferencias: Racket usa '+' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 10 + 3 = 13, con pureza funcional, para combinar tramos. Diferencias: Racket usa '+' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-4": {
      "title": "Calcular caramelos sobrantes",
      "racket": {
        "lines": ["(- 20 6)", "(- 15 4)", "(- 12 3)", "(- 8 2)", "(- 10 5)"]
      },
      "ocaml": {
        "lines": ["20 - 6", "15 - 4", "12 - 3", "8 - 2", "10 - 5"]
      },
      "explanations_racket": [
        "Calcula 20 - 6 con '-', dando 14. La notación prefija (- 20 6) en Racket muestra resta como función pura, ideal para calcular caramelos sobrantes.",
        "Resta 15 - 4, dando 11. (- 15 4) modela distribución de recursos, con determinismo.",
        "Resta 12 - 3, dando 9. (- 12 3) enseña calcular sobrantes, sin efectos secundarios.",
        "Resta 8 - 2, dando 6. (- 8 2) es útil para repartir objetos, con inmutabilidad.",
        "Resta 10 - 5, dando 5. (- 10 5) modela calcular sobrantes, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 20 - 6 con '-', dando 14. La notación infija 20 - 6 es intuitiva, como calcular caramelos sobrantes, con pureza funcional.",
        "Resta 15 - 4, dando 11. 15 - 4 modela distribución, con tipado estático.",
        "Resta 12 - 3, dando 9. 12 - 3 enseña calcular sobrantes, con determinismo.",
        "Resta 8 - 2, dando 6. 8 - 2 es útil para repartir objetos, sin efectos secundarios.",
        "Resta 10 - 5, dando 5. 10 - 5 modela sobrantes, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas restan 20 - 6 = 14, con pureza funcional, para caramelos sobrantes. Diferencias: Racket usa '-' prefija, explícita, mientras que OCaml usa infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas restan 15 - 4 = 11, con pureza funcional, para distribución. Diferencias: Racket usa '-' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas restan 12 - 3 = 9, con pureza funcional, para sobrantes. Diferencias: Racket usa '-' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas restan 8 - 2 = 6, con pureza funcional, para repartir objetos. Diferencias: Racket usa '-' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas restan 10 - 5 = 5, con pureza funcional, para sobrantes. Diferencias: Racket usa '-' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-5": {
      "title": "Verificar divisibilidad de libros",
      "racket": {
        "lines": [
          "(remainder 10 3)",
          "(remainder 8 2)",
          "(remainder 7 4)",
          "(remainder 12 5)",
          "(remainder 9 3)"
        ]
      },
      "ocaml": {
        "lines": ["10 mod 3", "8 mod 2", "7 mod 4", "12 mod 5", "9 mod 3"]
      },
      "explanations_racket": [
        "Calcula resto de 10 ÷ 3 con 'remainder', dando 1. La notación prefija (remainder 10 3) en Racket muestra módulo como función pura, ideal para verificar sobrantes de libros.",
        "Calcula 8 ÷ 2, dando 0. (remainder 8 2) enseña divisibilidad exacta, con determinismo.",
        "Calcula 7 ÷ 4, dando 3. (remainder 7 4) modela sobrantes en grupos, sin efectos secundarios.",
        "Calcula 12 ÷ 5, dando 2. (remainder 12 5) es útil para organización, con inmutabilidad.",
        "Calcula 9 ÷ 3, dando 0. (remainder 9 3) modela división exacta, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula resto de 10 ÷ 3 con 'mod', dando 1. La notación infija 10 mod 3 es intuitiva, como verificar sobrantes de libros, con pureza funcional.",
        "Calcula 8 ÷ 2, dando 0. 8 mod 2 modela divisibilidad exacta, con tipado estático.",
        "Calcula 7 ÷ 4, dando 3. 7 mod 4 enseña sobrantes, con determinismo.",
        "Calcula 12 ÷ 5, dando 2. 12 mod 5 es útil para organización, sin efectos secundarios.",
        "Calcula 9 ÷ 3, dando 0. 9 mod 3 modela división exacta, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas calculan resto de 10 ÷ 3 = 1, con pureza funcional, para sobrantes de libros. Diferencias: Racket usa 'remainder' prefija, explícita, mientras que OCaml usa 'mod' infija, concisa. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 8 ÷ 2 = 0, con pureza funcional, para divisibilidad exacta. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 7 ÷ 4 = 3, con pureza funcional, para sobrantes en grupos. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas calculan 12 ÷ 5 = 2, con pureza funcional, para organización. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas calculan 9 ÷ 3 = 0, con pureza funcional, para división exacta. Diferencias: Racket usa 'remainder' prefija, OCaml 'mod' infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-6": {
      "title": "Repartir huevos entre personas",
      "racket": {
        "lines": ["(/ 12 3)", "(/ 8 2)", "(/ 15 5)", "(/ 6 2)", "(/ 9 3)"]
      },
      "ocaml": {
        "lines": ["12 / 3", "8 / 2", "15 / 5", "6 / 2", "9 / 3"]
      },
      "explanations_racket": [
        "Calcula 12 ÷ 3 con '/', dando 4. La notación prefija (/ 12 3) en Racket muestra división como función pura, ideal para repartir huevos entre personas.",
        "Divide 8 ÷ 2, dando 4. (/ 8 2) modela reparto equitativo, con determinismo.",
        "Divide 15 ÷ 5, dando 3. (/ 15 5) enseña distribución, sin efectos secundarios.",
        "Divide 6 ÷ 2, dando 3. (/ 6 2) es útil para repartir recursos, con inmutabilidad.",
        "Divide 9 ÷ 3, dando 3. (/ 9 3) modela reparto en recetas, con pureza funcional."
      ],
      "explanations_ocaml": [
        "Calcula 12 ÷ 3 con '/', dando 4. La notación infija 12 / 3 es intuitiva, como repartir huevos, con pureza funcional.",
        "Divide 8 ÷ 2, dando 4. 8 / 2 modela reparto equitativo, con tipado estático.",
        "Divide 15 ÷ 5, dando 3. 15 / 5 enseña distribución, con determinismo.",
        "Divide 6 ÷ 2, dando 3. 6 / 2 es útil para repartir recursos, sin efectos secundarios.",
        "Divide 9 ÷ 3, dando 3. 9 / 3 modela reparto en recetas, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas dividen 12 ÷ 3 = 4, con pureza funcional, para repartir huevos. Diferencias: Racket usa '/' prefija, explícita, mientras que OCaml usa infija, concisa. Racket puede dar fracciones, OCaml entera, pero idéntico aquí.",
        "Similitudes: Ambas dividen 8 ÷ 2 = 4, con pureza funcional, para reparto equitativo. Diferencias: Racket usa '/' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas dividen 15 ÷ 5 = 3, con pureza funcional, para distribución. Diferencias: Racket usa '/' prefija, OCaml infija. Racket dinámico, OCaml estático.",
        "Similitudes: Ambas dividen 6 ÷ 2 = 3, con pureza funcional, para repartir recursos. Diferencias: Racket usa '/' prefija, OCaml infija. Tipado dinámico vs. estático.",
        "Similitudes: Ambas dividen 9 ÷ 3 = 3, con pureza funcional, para recetas. Diferencias: Racket usa '/' prefija, OCaml infija. Racket dinámico, OCaml estático."
      ]
    },
    "ejercicio-7": {
      "title": "Comparar área ajustada con límite",
      "racket": {
        "lines": [
          "(> (- (expt 3 2) 4) 5)",
          "(> (- (expt 4 2) 3) 7)",
          "(> (- (expt 2 2) 2) 1)",
          "(> (- (expt 5 2) 5) 10)",
          "(> (- (expt 6 2) 6) 15)"
        ]
      },
      "ocaml": {
        "lines": [
          "( ( (3 ** 2.0) - 4 ) > 5 )",
          "( ( (4 ** 2.0) - 3 ) > 7 )",
          "( ( (2 ** 2.0) - 2 ) > 1 )",
          "( ( (5 ** 2.0) - 5 ) > 10 )",
          "( ( (6 ** 2.0) - 6 ) > 15 )"
        ]
      },
      "explanations_racket": [
        "Calcula (> (- (expt 3 2) 4) 5), dando #f (9 - 4 = 5, 5 > 5 = #f). La notación prefija en Racket muestra anidamiento puro, ideal para ajustes de áreas en diseño estructural.",
        "Calcula (> (- (expt 4 2) 3) 7), dando #t (16 - 3 = 13, 13 > 7 = #t). Enseña combinar operaciones, con determinismo.",
        "Calcula (> (- (expt 2 2) 2) 1), dando #t (4 - 2 = 2, 2 > 1 = #t). Modela cálculos estructurales, sin efectos secundarios.",
        "Calcula (> (- (expt 5 2) 5) 10), dando #t (25 - 5 = 20, 20 > 10 = #t). Útil para diseño, con inmutabilidad.",
        "Calcula (> (- (expt 6 2) 6) 15), dando #t (36 - 6 = 30, 30 > 15 = #t). Modela ajustes complejos, con pureza."
      ],
      "explanations_ocaml": [
        "Calcula ( ( (3 ** 2.0) - 4 ) > 5 ), dando false (9.0 - 4 = 5, 5 > 5 = false). La notación infija en OCaml con flotantes es clara, ideal para ajustes de áreas, con pureza.",
        "Calcula ( ( (4 ** 2.0) - 3 ) > 7 ), dando true (16.0 - 3 = 13, 13 > 7 = true). Enseña anidamiento, con tipado estático.",
        "Calcula ( ( (2 ** 2.0) - 2 ) > 1 ), dando true (4.0 - 2 = 2, 2 > 1 = true). Modela cálculos estructurales, con determinismo.",
        "Calcula ( ( (5 ** 2.0) - 5 ) > 10 ), dando true (25.0 - 5 = 20, 20 > 10 = true). Útil para diseño, sin efectos secundarios.",
        "Calcula ( ( (6 ** 2.0) - 6 ) > 15 ), dando true (36.0 - 6 = 30, 30 > 15 = true). Modela ajustes complejos, con predictibilidad."
      ],
      "comparisons": [
        "Similitudes: Ambas evalúan (> (- (expt 3 2) 4) 5) = #f, con pureza funcional, para ajustes de áreas. Diferencias: Racket usa 'expt' prefija con enteros, OCaml usa '**' con flotantes (3 ** 2.0). Racket dinámico, OCaml estático.",
        "Similitudes: Ambas evalúan (> (- (expt 4 2) 3) 7) = #t, con pureza funcional, para diseño estructural. Diferencias: Racket usa 'expt' prefija, OCaml '**' con flotantes (4 ** 2.0). Tipado dinámico vs. estático.",
        "Similitudes: Ambas evalúan (> (- (expt 2 2) 2) 1) = #t, con pureza funcional, para cálculos estructurales. Diferencias: Racket usa 'expt' prefija, OCaml '**' con flotantes (2 ** 2.0). Racket dinámico, OCaml estático.",
        "Similitudes: Ambas evalúan (> (- (expt 5 2) 5) 10) = #t, con pureza funcional, para diseño. Diferencias: Racket usa 'expt' prefija, OCaml '**' con flotantes (5 ** 2.0). Tipado dinámico vs. estático.",
        "Similitudes: Ambas evalúan (> (- (expt 6 2) 6) 15) = #t, con pureza funcional, para ajustes complejos. Diferencias: Racket usa 'expt' prefija, OCaml '**' con flotantes (6 ** 2.0). Racket dinámico, OCaml estático."
      ]
    }
  },
  "funciones": {
    "ejercicio-1": {
      "title": "Área de un rectángulo",
      "racket": {
        "lines": [
          "(define (rectangle-area base height)",
          "  (* base height)",
          ")",
          "(rectangle-area 6 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let rectangle_area base height =",
          "  base * height",
          "in",
          "rectangle_area 6 3"
        ]
      },
      "explanations_racket": [
        "Esta línea define una función llamada `rectangle-area` que toma dos parámetros, `base` y `height`, usando la sintaxis `(define (nombre params) cuerpo)`. En Racket, las funciones son ciudadanos de primera clase en el paradigma funcional, permitiendo abstracción y reutilización. Esta línea prepara la función para calcular el área de un rectángulo, como imaginar medir un terreno rectangular para saber cuánto césped necesitas.",
        "Esta línea calcula el área multiplicando `base` por `height` con la función `*`. La notación prefija `(* base height)` refleja la filosofía Lisp de Racket, donde las operaciones son funciones explícitas. La expresión es pura, siempre retorna el mismo valor para los mismos argumentos, sin efectos secundarios, como calcular el área sin modificar el terreno.",
        "Esta línea cierra la definición de la función con un paréntesis, siguiendo la sintaxis de Racket que requiere paréntesis balanceados para estructurar el código. Es una convención estructural, no ejecuta lógica, pero es esencial para completar la definición.",
        "Esta línea llama a la función `rectangle-area` con argumentos 6 y 3, evaluando `(* 6 3)` para dar 18. Es un ejemplo práctico que muestra cómo usar la función definida, como medir un terreno de 6 metros por 3 metros para obtener el área total."
      ],
      "explanations_ocaml": [
        "Esta línea define una función `rectangle_area` con parámetros `base` y `height` usando la sintaxis `let nombre params = cuerpo`. En OCaml, las funciones son fundamentales en el paradigma funcional, promoviendo inmutabilidad y abstracción. Esta línea establece una función para calcular el área de un rectángulo, como planificar el espacio para una alfombra rectangular.",
        "Esta línea multiplica `base` por `height` usando el operador `*` en notación infija, que es intuitiva para principiantes por su similitud con la matemática estándar. La expresión es pura, siempre produce el mismo resultado sin efectos secundarios, alineándose con la filosofía funcional de OCaml, como calcular el área sin alterar el espacio.",
        "Esta línea usa `in` para introducir el contexto donde se usa la función definida, una característica de OCaml que separa la definición de su uso. No ejecuta lógica, pero es crucial para la estructura del programa, permitiendo evaluar la función en la siguiente línea.",
        "Esta línea llama a `rectangle_area` con argumentos 6 y 3, evaluando `6 * 3` para dar 18. Es un ejemplo práctico que muestra cómo invocar la función, como calcular el área de una alfombra de 6 metros por 3 metros."
      ],
      "comparisons": [
        "Similitudes: Ambas líneas definen una función con dos parámetros para calcular el área, siguiendo el principio funcional de abstracción. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, reflejando su herencia Lisp y estructura explícita. OCaml usa `let nombre params = cuerpo`, más concisa y sin paréntesis, alineándose con la sintaxis ML. El tipado dinámico de Racket contrasta con el estático de OCaml, que infiere que `base` y `height` son enteros.",
        "Similitudes: Ambas calculan el área con multiplicación, manteniendo pureza funcional. Diferencias: Racket usa notación prefija `(* base height)`, enfatizando que `*` es una función, mientras que OCaml usa notación infija `base * height`, más matemática y legible. La semántica es idéntica, pero OCaml es más compacto.",
        "Similitudes: Ambas líneas son estructurales, cerrando o preparando la definición. Diferencias: Racket usa un paréntesis de cierre `)`, parte de su sintaxis Lisp, mientras que OCaml usa `in` para indicar el contexto de uso, reflejando su enfoque ML. En este caso, OCaml requiere `in` para la llamada, mientras que Racket no necesita una palabra clave equivalente.",
        "Similitudes: Ambas llaman la función con 6 y 3, dando 18, mostrando cómo usar la función definida. Diferencias: Racket usa notación prefija `(rectangle-area 6 3)` con paréntesis, mientras que OCaml usa `rectangle_area 6 3` sin paréntesis, más simple. Ambos lenguajes logran el mismo resultado, pero OCaml es más conciso en la invocación."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar múltiplo",
      "racket": {
        "lines": [
          "(define (multiple? x y)",
          "  (= (remainder x y) 0)",
          ")",
          "(multiple? 9 3)"
        ]
      },
      "ocaml": {
        "lines": ["let multiple x y =", "  x mod y = 0", "in", "multiple 9 3"]
      },
      "explanations_racket": [
        "Define una función `multiple?` que toma dos parámetros, `x` y `y`, para verificar si `x` es múltiplo de `y`. La sintaxis `(define (nombre params) cuerpo)` es estándar en Racket, promoviendo abstracción funcional. Es como decidir si un número de caramelos se puede dividir equitativamente entre niños.",
        "Evalúa si el resto de `x` dividido por `y` es 0 usando `remainder` y `=`, retornando #t si `x` es múltiplo de `y`. La expresión es pura, sin efectos secundarios, y usa notación prefija. Este cálculo es como verificar si 9 caramelos se dividen perfectamente entre 3 niños.",
        "Cierra la definición de la función con un paréntesis, necesario para la sintaxis de Racket. No ejecuta lógica, pero completa la estructura de la función.",
        "Llama a `multiple?` con 9 y 3, evaluando `(= (remainder 9 3) 0)` para dar #t, ya que 9 es múltiplo de 3. Es un ejemplo práctico para mostrar la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `multiple` con parámetros `x` y `y` para verificar si `x` es múltiplo de `y`, usando `let nombre params = cuerpo`. En OCaml, las funciones son inmutables y puras, ideales para abstracción. Es como comprobar si un número de galletas se reparte equitativamente.",
        "Evalúa si `x` mod `y` es 0 usando el operador `mod` y `=`, retornando true si `x` es múltiplo. La notación infija es intuitiva, y la expresión es pura, como verificar si 9 galletas se dividen entre 3 personas.",
        "Usa `in` para introducir el contexto de la llamada, una característica estructural de OCaml que separa definición y uso, sin lógica propia.",
        "Llama a `multiple` con 9 y 3, evaluando `9 mod 3 = 0` para dar true. Es un ejemplo claro para mostrar cómo usar la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función con dos parámetros para verificar múltiplos, promoviendo abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, mientras que OCaml usa `let nombre params = cuerpo`, más compacto. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican si el resto es 0, retornando un booleano, con pureza funcional. Diferencias: Racket usa `remainder` y `=` en notación prefija, más explícita, mientras que OCaml usa `mod` y `=` infijos, más concisos. `remainder` puede dar negativos, `mod` no, pero aquí es idéntico.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 9 y 3, dando verdadero. Diferencias: Racket usa `(multiple? 9 3)`, OCaml usa `multiple 9 3`, más simple."
      ]
    },
    "ejercicio-3": {
      "title": "Calcular potencia",
      "racket": {
        "lines": [
          "(define (power base exp)",
          "  (if (= exp 0)",
          "      1",
          "      (* base (power base (- exp 1)))",
          "  )",
          ")",
          "(power 2 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec power base exp =",
          "  if exp = 0 then",
          "    1",
          "  else",
          "    base * power base (exp - 1)",
          "in",
          "power 2 3"
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `power` con parámetros `base` y `exp` para calcular `base` elevado a `exp`. La sintaxis `(define (nombre params) cuerpo)` introduce abstracción funcional, como calcular cuánto crece una inversión con interés compuesto.",
        "Inicia un condicional `if` que verifica si `exp` es 0. En Racket, `if` es una expresión pura que evalúa una condición, alineándose con el paradigma funcional.",
        "Si `exp` es 0, retorna 1 (caso base), ya que cualquier número elevado a 0 es 1. Esto evita recursión infinita, como decidir que sin crecimiento, el valor base es 1.",
        "Si `exp` no es 0, multiplica `base` por el resultado de `power` con `exp - 1`, usando recursión. Es como calcular 2^3 como 2 * 2^2, repitiendo hasta el caso base.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket, estructurando la lógica condicional.",
        "Cierra la definición de la función, completando la estructura de Racket.",
        "Llama a `power` con 2 y 3, calculando 2^3 = 8, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `power` con `let rec` para calcular `base` elevado a `exp`. `let rec` indica recursión en OCaml, promoviendo pureza y abstracción, como modelar el crecimiento de una población.",
        "Inicia un condicional `if` para verificar si `exp` es 0, usando notación infija `exp = 0`. En OCaml, `if` es una expresión pura, esencial en el paradigma funcional.",
        "Retorna 1 si `exp` es 0 (caso base), ya que cualquier número elevado a 0 es 1, previniendo recursión infinita.",
        "Introduce la rama `else` para el caso recursivo, necesaria en OCaml para completar el condicional, ya que todos los caminos deben retornar un valor.",
        "Multiplica `base` por `power base (exp - 1)`, usando recursión para calcular la potencia, como 2^3 = 2 * 2^2, hasta llegar al caso base.",
        "Usa `in` para introducir el contexto de la llamada, una convención estructural de OCaml.",
        "Llama a `power` con 2 y 3, dando 2^3 = 8, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular potencias, promoviendo abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito para recursión. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas verifican si `exp` es 0 con una expresión pura. Diferencias: Racket usa `if` con notación prefija `(= exp 0)`, OCaml usa infija `exp = 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base, esencial para recursión. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente, más estructurado.",
        "Similitudes: Ambas manejan el caso recursivo. Diferencias: Racket incluye la recursión en el `if`, mientras que OCaml usa `else`, requiriendo una línea extra para estructura, lo que refleja la necesidad de OCaml de explicitar todas las ramas.",
        "Similitudes: Ambas son estructurales para el condicional. Diferencias: Racket cierra el `if` con `)`, OCaml usa una línea para la recursión, haciendo que OCaml tenga más líneas aquí.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra la función con `)`, OCaml usa `in` para la llamada, alineándose con sus filosofías.",
        "Similitudes: Ambas llaman la función con 2 y 3, dando 8. Diferencias: Racket usa `(power 2 3)`, OCaml usa `power 2 3`, más conciso."
      ]
    },
    "ejercicio-4": {
      "title": "Promedio de dos distancias",
      "racket": {
        "lines": [
          "(define (average a b)",
          "  (/ (+ a b) 2)",
          ")",
          "(average 5 7)"
        ]
      },
      "ocaml": {
        "lines": ["let average a b =", "  (a + b) / 2", "in", "average 5 7"]
      },
      "explanations_racket": [
        "Define una función `average` con parámetros `a` y `b` para calcular el promedio de dos distancias. La sintaxis `(define (nombre params) cuerpo)` es típica de Racket, promoviendo abstracción funcional, como calcular el punto medio entre dos ubicaciones.",
        "Calcula el promedio sumando `a` y `b` con `+`, dividiendo por 2 con `/`. La notación prefija `(/ (+ a b) 2)` es pura, siempre da el mismo resultado, como encontrar el punto intermedio en un viaje.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `average` con 5 y 7, evaluando `(/ (+ 5 7) 2)` = 6, mostrando cómo usar la función en un caso práctico."
      ],
      "explanations_ocaml": [
        "Define una función `average` con parámetros `a` y `b` para calcular el promedio, usando `let nombre params = cuerpo`. En OCaml, las funciones son puras, ideales para abstracción, como hallar el punto medio entre dos distancias.",
        "Suma `a` y `b` con `+`, divide por 2 con `/`, usando notación infija `(a + b) / 2`. La expresión es pura, como calcular el promedio de dos recorridos sin alterar datos.",
        "Usa `in` para introducir el contexto de la llamada, una característica estructural de OCaml.",
        "Llama a `average` con 5 y 7, dando `(5 + 7) / 2` = 6, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para promediar dos valores, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`, más conciso. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas calculan el promedio con suma y división, manteniendo pureza. Diferencias: Racket usa notación prefija `(/ (+ a b) 2)`, OCaml usa infija `(a + b) / 2`, más matemática. OCaml requiere paréntesis para prioridad.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 5 y 7, dando 6. Diferencias: Racket usa `(average 5 7)`, OCaml usa `average 5 7`, más simple."
      ]
    },
    "ejercicio-5": {
      "title": "Validar rango 1-100",
      "racket": {
        "lines": [
          "(define (between-1-100? x)",
          "  (and (>= x 1) (<= x 100))",
          ")",
          "(between-1-100? 75)"
        ]
      },
      "ocaml": {
        "lines": [
          "let between_1_100 x =",
          "  x >= 1 && x <= 100",
          "in",
          "between_1_100 75"
        ]
      },
      "explanations_racket": [
        "Define una función `between-1-100?` que verifica si `x` está entre 1 y 100. La sintaxis `(define (nombre params) cuerpo)` promueve abstracción funcional, como comprobar si una puntuación está en un rango válido.",
        "Evalúa si `x` es mayor o igual a 1 y menor o igual a 100 usando `and`, `>=`, y `<=`, retornando #t si ambas condiciones son ciertas. La expresión es pura, como validar una calificación escolar.",
        "Cierra la definición de la función, parte de la sintaxis de Racket.",
        "Llama a `between-1-100?` con 75, dando #t porque 75 está en el rango, mostrando el uso práctico."
      ],
      "explanations_ocaml": [
        "Define una función `between_1_100` para verificar si `x` está entre 1 y 100, usando `let nombre params = cuerpo`. Es una abstracción funcional, como validar un puntaje en un juego.",
        "Evalúa `x >= 1 && x <= 100` con operadores infijos, retornando true si ambas condiciones son ciertas. La expresión es pura, ideal para verificaciones lógicas.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `between_1_100` con 75, dando true, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para validar un rango, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas verifican el rango con operadores lógicos, retornando un booleano puro. Diferencias: Racket usa `and`, `>=`, `<=` en notación prefija, OCaml usa `&&`, `>=`, `<=` infijos, más concisos.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 75, dando verdadero. Diferencias: Racket usa `(between-1-100? 75)`, OCaml usa `between_1_100 75`, más simple."
      ]
    },
    "ejercicio-6": {
      "title": "Área de un círculo",
      "racket": {
        "lines": [
          "(define (circle-area r)",
          "  (* 3.14159 (* r r))",
          ")",
          "(circle-area 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let circle_area r =",
          "  3.14159 *. (r *. r)",
          "in",
          "circle_area 3.0"
        ]
      },
      "explanations_racket": [
        "Define una función `circle-area` que toma un parámetro `r` (radio) para calcular el área de un círculo. La sintaxis `(define (nombre params) cuerpo)` es funcional, como medir el área de una pizza redonda.",
        "Calcula π * r² usando `*` y la constante 3.14159, con notación prefija `(* 3.14159 (* r r))`. La expresión es pura, ideal para cálculos matemáticos precisos.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `circle-area` con radio 3, dando aproximadamente 28.27431, mostrando la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `circle_area` con parámetro `r` para calcular el área, usando `let nombre params = cuerpo`. Es una abstracción funcional, como calcular el área de un plato redondo.",
        "Calcula π * r² con `*.` (multiplicación de flotantes) y 3.14159, usando notación infija `3.14159 *. (r *. r)`. La expresión es pura, y OCaml requiere tipos flotantes explícitos.",
        "Usa `in` para introducir la llamada, parte de la estructura de OCaml.",
        "Llama a `circle_area` con 3.0, dando aproximadamente 28.27431, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular el área de un círculo, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml requiere `r` como flotante.",
        "Similitudes: Ambas calculan π * r², manteniendo pureza. Diferencias: Racket usa `*` en notación prefija, OCaml usa `*.` infijo para flotantes, requiriendo paréntesis para prioridad.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con radio 3, dando el mismo resultado. Diferencias: Racket usa `(circle-area 3)`, OCaml usa `circle_area 3.0`, con notación de flotante explícita."
      ]
    },
    "ejercicio-7": {
      "title": "Convertir Celsius a Fahrenheit",
      "racket": {
        "lines": [
          "(define (celsius-to-fahrenheit c)",
          "  (+ (* c 9/5) 32)",
          ")",
          "(celsius-to-fahrenheit 20)"
        ]
      },
      "ocaml": {
        "lines": [
          "let celsius_to_fahrenheit c =",
          "  (c *. 9.0 /. 5.0) +. 32.0",
          "in",
          "celsius_to_fahrenheit 20.0"
        ]
      },
      "explanations_racket": [
        "Define una función `celsius-to-fahrenheit` con parámetro `c` para convertir grados Celsius a Fahrenheit. La sintaxis `(define (nombre params) cuerpo)` promueve abstracción funcional, como ajustar un termómetro.",
        "Calcula la conversión con la fórmula c * 9/5 + 32, usando notación prefija `(+ (* c 9/5) 32)`. La expresión es pura, ideal para cálculos precisos, como convertir 20°C a 68°F.",
        "Cierra la definición de la función, parte de la sintaxis de Racket.",
        "Llama a `celsius-to-fahrenheit` con 20, dando 68, mostrando la conversión."
      ],
      "explanations_ocaml": [
        "Define una función `celsius_to_fahrenheit` con parámetro `c` para convertir Celsius a Fahrenheit, usando `let nombre params = cuerpo`. Es una abstracción funcional, como configurar un termostato.",
        "Calcula c * 9.0 / 5.0 + 32.0 con operadores `*.`, `/.`, y `+.`, usando notación infija para flotantes. La expresión es pura, y OCaml requiere tipos flotantes explícitos.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `celsius_to_fahrenheit` con 20.0, dando 68.0, demostrando la conversión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para convertir temperaturas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml requiere flotantes explícitos.",
        "Similitudes: Ambas aplican la fórmula c * 9/5 + 32, manteniendo pureza. Diferencias: Racket usa `*`, `/`, `+` en notación prefija con `9/5` como fracción, mientras que OCaml usa `*.`, `/.`, `+.` infijos con valores flotantes `9.0`, `5.0`, `32.0`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 20, dando 68. Diferencias: Racket usa `(celsius-to-fahrenheit 20)`, OCaml usa `celsius_to_fahrenheit 20.0`, con flotante explícito."
      ]
    }
  },
  "funciones-multiples": {
    "ejercicio-1": {
      "title": "Área de un triángulo",
      "racket": {
        "lines": [
          "(define (triangle-area base height)",
          "  (/ (* base height) 2)",
          ")",
          "(triangle-area 8 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let triangle_area base height =",
          "  (base *. height) /. 2.0",
          "in",
          "triangle_area 8.0 5.0"
        ]
      },
      "explanations_racket": [
        "Define una función `triangle-area` que toma dos parámetros, `base` y `height`, para calcular el área de un triángulo. La sintaxis `(define (nombre params) cuerpo)` es estándar en Racket, promoviendo abstracción funcional para encapsular cálculos, como medir el área de una carpa triangular.",
        "Calcula el área con la fórmula `(base * height) / 2`, usando notación prefija `(/ (* base height) 2)`. La expresión es pura, siempre retorna el mismo valor sin efectos secundarios, alineándose con el paradigma funcional. Es como dividir un terreno triangular por la mitad para saber cuánto material necesitas.",
        "Cierra la definición de la función con un paréntesis, una convención estructural de Racket necesaria para completar la sintaxis.",
        "Llama a `triangle-area` con `base` 8 y `height` 5, evaluando `(/ (* 8 5) 2)` = 20, mostrando cómo usar la función para un caso práctico, como calcular el área de un triángulo en un proyecto de construcción."
      ],
      "explanations_ocaml": [
        "Define una función `triangle_area` con parámetros `base` y `height` para calcular el área de un triángulo, usando `let nombre params = cuerpo`. En OCaml, las funciones son inmutables y puras, ideales para abstracción, como calcular el área de una vela triangular para un barco.",
        "Calcula `(base * height) / 2` usando operadores de flotantes `*.` y `/.`, con notación infija `(base *. height) /. 2.0`. La expresión es pura, garantizando el mismo resultado sin alterar estado. Es como medir la superficie de una vela para saber cuánta tela usar.",
        "Usa `in` para introducir el contexto de la llamada, una característica estructural de OCaml que separa la definición de su uso, sin lógica propia.",
        "Llama a `triangle_area` con 8.0 y 5.0, evaluando `(8.0 *. 5.0) /. 2.0` = 20.0, demostrando la función en un contexto práctico."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función con dos parámetros para calcular el área de un triángulo, promoviendo abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, reflejando su herencia Lisp, mientras que OCaml usa `let nombre params = cuerpo`, más conciso. OCaml requiere argumentos flotantes explícitos, mientras que Racket es dinámico y acepta enteros o fracciones.",
        "Similitudes: Ambas aplican la fórmula `(base * height) / 2`, manteniendo pureza funcional. Diferencias: Racket usa notación prefija `(/ (* base height) 2)`, más explícita, mientras que OCaml usa `*.` y `/.` en notación infija `(base *. height) /. 2.0`, requiriendo flotantes y paréntesis para prioridad, lo que es más matemático pero específico en tipos.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 8 y 5, dando 20. Diferencias: Racket usa `(triangle-area 8 5)`, mientras que OCaml usa `triangle_area 8.0 5.0`, requiriendo flotantes explícitos, lo que hace a OCaml más estricto en tipado."
      ]
    },
    "ejercicio-2": {
      "title": "Verificar orden ascendente",
      "racket": {
        "lines": [
          "(define (ascending? a b c)",
          "  (and (< a b) (< b c))",
          ")",
          "(ascending? 2 3 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let ascending a b c =",
          "  a < b && b < c",
          "in",
          "ascending 2 3 4"
        ]
      },
      "explanations_racket": [
        "Define una función `ascending?` que toma tres parámetros (`a`, `b`, `c`) para verificar si están en orden ascendente. La sintaxis `(define (nombre params) cuerpo)` permite abstracción funcional, como comprobar si tres notas musicales forman una escala ascendente.",
        "Evalúa si `a < b` y `b < c` usando `and` y `<`, retornando #t si ambas condiciones son ciertas. La expresión es pura, sin efectos secundarios, ideal para verificaciones lógicas en el paradigma funcional, como ordenar alturas de plantas.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `ascending?` con 2, 3, 4, evaluando `(and (< 2 3) (< 3 4))` = #t, mostrando que los números están en orden ascendente."
      ],
      "explanations_ocaml": [
        "Define una función `ascending` con tres parámetros (`a`, `b`, `c`) para verificar orden ascendente, usando `let nombre params = cuerpo`. En OCaml, las funciones son puras, ideales para lógica, como verificar si tres temperaturas suben progresivamente.",
        "Evalúa `a < b && b < c` con operadores infijos `<` y `&&`, retornando true si ambas condiciones son ciertas. La expresión es pura, alineándose con el paradigma funcional, como comprobar el orden de pasos en una carrera.",
        "Usa `in` para introducir el contexto de la llamada, una convención estructural de OCaml.",
        "Llama a `ascending` con 2, 3, 4, dando true, demostrando que los números están en orden."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función con tres parámetros para verificar orden ascendente, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`, más conciso. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas evalúan dos comparaciones con un operador lógico, retornando un booleano puro. Diferencias: Racket usa `and` y `<` en notación prefija, más explícita, mientras que OCaml usa `&&` y `<` infijos, más matemáticos y concisos.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 2, 3, 4, dando verdadero. Diferencias: Racket usa `(ascending? 2 3 4)`, OCaml usa `ascending 2 3 4`, más simple."
      ]
    },
    "ejercicio-3": {
      "title": "Distancia euclidiana",
      "racket": {
        "lines": [
          "(define (distance x1 y1 x2 y2)",
          "  (sqrt (+ (expt (- x2 x1) 2)",
          "           (expt (- y2 y1) 2)))",
          ")",
          "(distance 1 2 4 6)"
        ]
      },
      "ocaml": {
        "lines": [
          "let distance x1 y1 x2 y2 =",
          "  sqrt ((x2 -. x1) ** 2.0 +.",
          "        (y2 -. y1) ** 2.0)",
          "in",
          "distance 1.0 2.0 4.0 6.0"
        ]
      },
      "explanations_racket": [
        "Define una función `distance` con cuatro parámetros (`x1`, `y1`, `x2`, `y2`) para calcular la distancia euclidiana entre dos puntos. La sintaxis `(define (nombre params) cuerpo)` promueve abstracción funcional, como medir la distancia entre dos ciudades en un mapa.",
        "Calcula la raíz cuadrada de la suma de las diferencias al cuadrado, usando `sqrt`, `+`, `expt`, y `-` en notación prefija. La primera parte `(expt (- x2 x1) 2)` calcula (x2 - x1)^2, como medir la diferencia horizontal entre puntos.",
        "Continúa con `(expt (- y2 y1) 2)`, suma ambos términos y aplica `sqrt`, formando la fórmula √((x2 - x1)^2 + (y2 - y1)^2). La expresión es pura, ideal para cálculos geométricos precisos.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `distance` con (1, 2) y (4, 6), dando aproximadamente 5, mostrando la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `distance` con cuatro parámetros para calcular la distancia euclidiana, usando `let nombre params = cuerpo`. Es una abstracción funcional, como calcular la distancia entre dos puntos en un GPS.",
        "Calcula (x2 - x1)^2 con `-.` y `**` (exponenciación de flotantes), usando notación infija `(x2 -. x1) ** 2.0`. Esta línea inicia la fórmula, combinando operaciones aritméticas puras.",
        "Completa con `(y2 -. y1) ** 2.0`, suma con `+.`, y aplica `sqrt`, formando √((x2 - x1)^2 + (y2 - y1)^2). La expresión es pura, requiriendo flotantes explícitos en OCaml.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `distance` con (1.0, 2.0) y (4.0, 6.0), dando aproximadamente 5.0."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función con cuatro parámetros para calcular distancia euclidiana, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml requiere flotantes explícitos.",
        "Similitudes: Ambas inician la fórmula calculando (x2 - x1)^2, manteniendo pureza. Diferencias: Racket usa `expt` y `-` en notación prefija, OCaml usa `-.` y `**` infijos, más matemáticos. OCaml requiere flotantes (2.0).",
        "Similitudes: Ambas completan la fórmula con (y2 - y1)^2 and `sqrt`, puras. Diferencias: Racket combina ambas partes en una línea con notación prefija, más compacta aquí, mientras que OCaml separa en dos líneas por formato infijo, requiriendo `+.`.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con los mismos puntos, dando ~5. Diferencias: Racket usa `(distance 1 2 4 6)`, OCaml usa `distance 1.0 2.0 4.0 6.0`, con flotantes explícitos."
      ]
    },
    "ejercicio-4": {
      "title": "Máximo de tres valores",
      "racket": {
        "lines": [
          "(define (max-of-three a b c)",
          "  (max a (max b c))",
          ")",
          "(max-of-three 6 8 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let max_of_three a b c =",
          "  max a (max b c)",
          "in",
          "max_of_three 6 8 4"
        ]
      },
      "explanations_racket": [
        "Define una función `max-of-three` con tres parámetros (`a`, `b`, `c`) para encontrar el máximo. La sintaxis `(define (nombre params) cuerpo)` es funcional, como elegir el mayor de tres puntajes en un juego.",
        "Usa la función `max` para comparar `a` con el máximo de `b` y `c`, en notación prefija `(max a (max b c))`. La expresión es pura, retornando siempre el mismo valor, como seleccionar la puntuación más alta.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `max-of-three` con 6, 8, 4, dando 8, mostrando la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `max_of_three` con tres parámetros para hallar el máximo, usando `let nombre params = cuerpo`. Es una abstracción funcional, como encontrar el mayor tiempo en una carrera.",
        "Usa el operador `max` para comparar `a` con el máximo de `b` y `c`, en notación infija `max a (max b c)`. La expresión es pura, ideal para comparaciones lógicas.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `max_of_three` con 6, 8, 4, dando 8, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para encontrar el máximo de tres valores, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`, más conciso.",
        "Similitudes: Ambas usan `max` para comparar valores, manteniendo pureza. Diferencias: Racket usa notación prefija `(max a (max b c))`, OCaml usa infija `max a (max b c)`, más matemática.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 6, 8, 4, dando 8. Diferencias: Racket usa `(max-of-three 6 8 4)`, OCaml usa `max_of_three 6 8 4`, más simple."
      ]
    },
    "ejercicio-5": {
      "title": "Promedio de tres valores",
      "racket": {
        "lines": [
          "(define (average-three a b c)",
          "  (/ (+ a b c) 3)",
          ")",
          "(average-three 10 15 20)"
        ]
      },
      "ocaml": {
        "lines": [
          "let average_three a b c =",
          "  (a + b + c) / 3",
          "in",
          "average_three 10 15 20"
        ]
      },
      "explanations_racket": [
        "Define una función `average-three` con tres parámetros para calcular el promedio. La sintaxis `(define (nombre params) cuerpo)` es funcional, como promediar notas de tres exámenes.",
        "Calcula `(a + b + c) / 3` con notación prefija `(/ (+ a b c) 3)`, una expresión pura para obtener el promedio, como calcular el promedio de tres carreras.",
        "Cierra la definición de la función, necesaria para Racket.",
        "Llama a `average-three` con 10, 15, 20, dando 15, mostrando la función."
      ],
      "explanations_ocaml": [
        "Define una función `average_three` con tres parámetros para promediar, usando `let nombre params = cuerpo`. Es una abstracción funcional, como promediar tiempos de tres pruebas.",
        "Calcula `(a + b + c) / 3` con notación infija `(a + b + c) / 3`, una expresión pura para el promedio, como hallar el promedio de distancias recorridas.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `average_three` con 10, 15, 20, dando 15, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para promediar tres valores, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas calculan el promedio con suma y división, manteniendo pureza. Diferencias: Racket usa notación prefija `(/ (+ a b c) 3)`, OCaml usa infija `(a + b + c) / 3`, más matemática.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 10, 15, 20, dando 15. Diferencias: Racket usa `(average-three 10 15 20)`, OCaml usa `average_three 10 15 20`, más simple."
      ]
    },
    "ejercicio-6": {
      "title": "Verificar positivos",
      "racket": {
        "lines": [
          "(define (all-positive? a b c)",
          "  (and (> a 0) (> b 0) (> c 0))",
          ")",
          "(all-positive? 2 3 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let all_positive a b c =",
          "  a > 0 && b > 0 && c > 0",
          "in",
          "all_positive 2 3 4"
        ]
      },
      "explanations_racket": [
        "Define una función `all-positive?` con tres parámetros para verificar si todos son positivos. La sintaxis `(define (nombre params) cuerpo)` es funcional, como comprobar si tres medidas son válidas.",
        "Evalúa si `a`, `b`, y `c` son mayores que 0 usando `and` y `>`, retornando #t si todas las condiciones son ciertas. Es una expresión pura, como verificar si tres temperaturas están sobre cero.",
        "Cierra la definición de la función, necesaria para Racket.",
        "Llama a `all-positive?` con 2, 3, 4, dando #t, mostrando que todos son positivos."
      ],
      "explanations_ocaml": [
        "Define una función `all_positive` con tres parámetros para verificar si todos son positivos, usando `let nombre params = cuerpo`. Es una abstracción funcional, como validar tres cantidades.",
        "Evalúa `a > 0 && b > 0 && c > 0` con operadores infijos, retornando true si todas son ciertas. Es una expresión pura, como comprobar si tres valores son válidos.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `all_positive` con 2, 3, 4, dando true, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si tres valores son positivos, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas evalúan tres comparaciones con un operador lógico, retornando un booleano puro. Diferencias: Racket usa `and` y `>` en notación prefija, OCaml usa `&&` y `>` infijos, más concisos.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 2, 3, 4, dando verdadero. Diferencias: Racket usa `(all-positive? 2 3 4)`, OCaml usa `all_positive 2 3 4`, más simple."
      ]
    },
    "ejercicio-7": {
      "title": "Volumen de una caja",
      "racket": {
        "lines": [
          "(define (cuboid-volume l w h)",
          "  (* l w h)",
          ")",
          "(cuboid-volume 3 2 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let cuboid_volume l w h =",
          "  l *. w *. h",
          "in",
          "cuboid_volume 3.0 2.0 4.0"
        ]
      },
      "explanations_racket": [
        "Define una función `cuboid-volume` con tres parámetros (`l`, `w`, `h`) para calcular el volumen de una caja. La sintaxis `(define (nombre params) cuerpo)` es funcional, como medir el espacio en una caja de almacenamiento.",
        "Calcula el volumen con `l * w * h` usando notación prefija `(* l w h)`, una expresión pura para obtener el volumen, como calcular cuánto cabe en una caja.",
        "Cierra la definición de la función, necesaria para Racket.",
        "Llama a `cuboid-volume` con 3, 2, 4, dando 24, mostrando la función."
      ],
      "explanations_ocaml": [
        "Define una función `cuboid_volume` con tres parámetros para calcular el volumen, usando `let nombre params = cuerpo`. Es una abstracción funcional, como medir una caja de envío.",
        "Calcula `l * w * h` con operadores de flotantes `*.`, usando notación infija `l *. w *. h`. Es una expresión pura, requiriendo flotantes explícitos en OCaml.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `cuboid_volume` con 3.0, 2.0, 4.0, dando 24.0, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular el volumen de una caja, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml requiere flotantes.",
        "Similitudes: Ambas calculan el volumen con multiplicación, manteniendo pureza. Diferencias: Racket usa `*` en notación prefija, OCaml usa `*.` infijo, requiriendo flotantes y más explícito en tipado.",
        "Similitudes: Ambas son estructurales, sin lógica. Diferencias: Racket cierra con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 3, 2, 4, dando 24. Diferencias: Racket usa `(cuboid-volume 3 2 4)`, OCaml usa `cuboid_volume 3.0 2.0 4.0`, con flotantes explícitos."
      ]
    }
  },
  "condicionales": {
    "ejercicio-1": {
      "title": "Máximo de dos números",
      "racket": {
        "lines": [
          "(define (max-two a b)",
          "  (if (> a b)",
          "      a",
          "      b",
          "  )",
          ")",
          "(max-two 10 7)"
        ]
      },
      "ocaml": {
        "lines": [
          "let max_two a b =",
          "  if a > b then",
          "    a",
          "  else",
          "    b",
          "in",
          "max_two 10 7"
        ]
      },
      "explanations_racket": [
        "Define una función `max-two` que toma dos parámetros (`a`, `b`) para encontrar el mayor. La sintaxis `(define (nombre params) cuerpo)` es funcional, como elegir el mayor de dos ofertas en una subasta.",
        "Inicia un condicional `if` que evalúa si `a > b` usando `>` en notación prefija. Es una expresión pura, como decidir cuál de dos precios es más alto.",
        "Si `a > b` es verdadero, retorna `a`, seleccionando el mayor valor, como elegir la oferta más alta.",
        "Si `a > b` es falso, retorna `b`, formando la rama 'else' del condicional.",
        "Cierra el bloque `if`, asegurando que la función retorne un valor puro.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `max-two` con 10 y 7, retornando 10 porque `10 > 7`, mostrando la función en acción."
      ],
      "explanations_ocaml": [
        "Define una función `max_two` con dos parámetros para encontrar el mayor, usando `let nombre params = cuerpo`. Es una abstracción funcional, como seleccionar la mayor puja en un mercado.",
        "Inicia un condicional `if` con `a > b` en notación infija, evaluando cuál es mayor. Es una expresión pura, como comparar dos cantidades.",
        "Si `a > b`, retorna `a`, seleccionando el mayor valor, como elegir el mejor precio.",
        "Introduce la rama `else`, necesaria en OCaml para garantizar un valor en todos los casos, retornando `b` si `a` no es mayor.",
        "Cierra la rama `else` con `b`, completando el condicional con un valor puro.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `max_two` con 10 y 7, retornando 10 porque `10 > 7`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para encontrar el máximo de dos números, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con paréntesis, reflejando su herencia Lisp, mientras que OCaml usa `let nombre params = cuerpo`, más conciso. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas evalúan `a > b` con pureza funcional. Diferencias: Racket usa `>` en notación prefija, más explícita, mientras que OCaml usa infija, más matemática y concisa.",
        "Similitudes: Ambas retornan `a` si es mayor, con pureza. Diferencias: Racket integra la rama 'then' en el `if`, mientras que OCaml usa `then` explícitamente, requiriendo una estructura más verbal.",
        "Similitudes: Ambas retornan `b` si `a` no es mayor, con pureza. Diferencias: Racket incluye el caso falso en el `if`, mientras que OCaml usa `else` explícitamente, requiriendo una línea adicional.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if` con un paréntesis, OCaml cierra la rama `else` con `b`, aumentando el número de líneas en OCaml.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 10 y 7, retornando 10. Diferencias: Racket usa `(max-two 10 7)` con paréntesis, OCaml usa `max_two 10 7`, más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Clasificar número positivo, negativo o cero",
      "racket": {
        "lines": [
          "(define (classify-number x)",
          "  (cond",
          "    [(> x 0) 'positive]",
          "    [(< x 0) 'negative]",
          "    [else 'zero]",
          "  )",
          ")",
          "(classify-number 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let classify_number x =",
          "  if x > 0 then",
          "    \"positive\"",
          "  else if x < 0 then",
          "    \"negative\"",
          "  else",
          "    \"zero\"",
          "in",
          "classify_number 3"
        ]
      },
      "explanations_racket": [
        "Define una función `classify-number` que toma un parámetro `x` para clasificar un número como positivo, negativo o cero. La sintaxis `(define (nombre params) cuerpo)` es funcional, como etiquetar una temperatura según su valor.",
        "Inicia un condicional `cond`, que permite múltiples ramas en Racket. Es una expresión pura que evalúa condiciones secuencialmente, ideal para clasificaciones complejas.",
        "Evalúa si `x > 0`, retornando el símbolo `'positive` si es verdadero, como etiquetar una temperatura positiva.",
        "Evalúa si `x < 0`, retornando `'negative`, para el caso negativo, manteniendo pureza.",
        "Si ninguna condición previa es verdadera, retorna `'zero` con la rama `else`, como clasificar un valor neutro.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `classify-number` con 3, retornando `'positive` porque `3 > 0`, mostrando la clasificación."
      ],
      "explanations_ocaml": [
        "Define una función `classify_number` con un parámetro `x` para clasificar un número, usando `let nombre params = cuerpo`. Es una abstracción funcional, como categorizar un nivel de batería.",
        "Inicia un condicional `if` con `x > 0` en notación infija, evaluando la primera condición con pureza funcional.",
        "Si `x > 0`, retorna la cadena `\"positive\"`, como asignar una etiqueta a un valor positivo.",
        "Introduce un `else if` para evaluar `x < 0`, retornando `\"negative\"`, necesario para manejar múltiples condiciones en OCaml.",
        "Introduce la rama `else`, retornando `\"zero\"` si ninguna condición previa es verdadera, necesaria para completar el condicional.",
        "Cierra la rama `else` con `\"zero\"`, asegurando un valor puro en todos los casos.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `classify_number` con 3, retornando `\"positive\"` porque `3 > 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para clasificar un número como positivo, negativo o cero, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa cadenas, Racket usa símbolos.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza funcional. Diferencias: Racket usa `cond` para múltiples ramas, más flexible, mientras que OCaml usa `if` con anidamiento `else if`, más explícito.",
        "Similitudes: Ambas retornan un valor para el caso positivo. Diferencias: Racket usa el símbolo `'positive`, OCaml usa la cadena `\"positive\"` con `then`.",
        "Similitudes: Ambas manejan el caso negativo. Diferencias: Racket usa una rama de `cond` con `'negative`, más concisa, mientras que OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas manejan el caso cero. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `\"zero\"`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 3, retornando 'positive'. Diferencias: Racket usa `(classify-number 3)` con un símbolo, OCaml usa `classify_number 3` con una cadena."
      ]
    },
    "ejercicio-3": {
      "title": "Año bisiesto",
      "racket": {
        "lines": [
          "(define (leap-year? year)",
          "  (cond",
          "    [(= (remainder year 400) 0) #t]",
          "    [(= (remainder year 100) 0) #f]",
          "    [(= (remainder year 4) 0) #t]",
          "    [else #f]",
          "  )",
          ")",
          "(leap-year? 2024)"
        ]
      },
      "ocaml": {
        "lines": [
          "let leap_year year =",
          "  if year mod 400 = 0 then",
          "    true",
          "  else if year mod 100 = 0 then",
          "    false",
          "  else if year mod 4 = 0 then",
          "    true",
          "  else",
          "    false",
          "in",
          "leap_year 2024"
        ]
      },
      "explanations_racket": [
        "Define una función `leap-year?` que toma un parámetro `year` para verificar si un año es bisiesto. La sintaxis `(define (nombre params) cuerpo)` es funcional, como decidir si un año necesita un día extra en un calendario.",
        "Inicia un condicional `cond` para evaluar las reglas del año bisiesto, una expresión pura que verifica condiciones en orden.",
        "Evalúa si `year` es divisible por 400 usando `(= (remainder year 400) 0)`, retornando `#t` si es verdadero, como 2000.",
        "Evalúa si `year` es divisible por 100, retornando `#f`, como 1900, donde no se añade un día extra.",
        "Evalúa si `year` es divisible por 4, retornando `#t`, como 2024, un año bisiesto típico.",
        "Si ninguna condición es verdadera, retorna `#f` con `else`, para años no bisiestos.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `leap-year?` con 2024, retornando `#t` porque `2024 mod 4 = 0` y no es divisible por 100, mostrando que es bisiesto."
      ],
      "explanations_ocaml": [
        "Define una función `leap_year` con un parámetro `year` para verificar si es bisiesto, usando `let nombre params = cuerpo`. Es una abstracción funcional, como programar un calendario.",
        "Inicia un condicional `if` con `year mod 400 = 0` en notación infija, evaluando la primera regla del año bisiesto con pureza.",
        "Si `year mod 400 = 0`, retorna `true`, para años como 2000.",
        "Introduce un `else if` para `year mod 100 = 0`, retornando `false`, para años como 1900.",
        "Introduce otro `else if` para `year mod 4 = 0`, retornando `true`, para años como 2024.",
        "Introduce la rama `else`, retornando `false` para años no bisiestos, necesaria para completar el condicional.",
        "Cierra la rama `else` con `false`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `leap_year` con 2024, retornando `true` porque `2024 mod 4 = 0` y no es divisible por 100, demostrando que es bisiesto."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si un año es bisiesto, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas inician un condicional para evaluar reglas, con pureza. Diferencias: Racket usa `cond`, más flexible, mientras que OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas verifican divisibilidad por 400, retornando verdadero. Diferencias: Racket usa `(remainder year 400)` en notación prefija, OCaml usa `mod 400` infijo, más matemático.",
        "Similitudes: Ambas verifican divisibilidad por 100, retornando falso. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas verifican divisibilidad por 4, retornando verdadero. Diferencias: Racket usa una rama de `cond`, OCaml usa otro `else if`.",
        "Similitudes: Ambas manejan el caso no bisiesto. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `false`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 2024, retornando verdadero. Diferencias: Racket usa `(leap-year? 2024)`, OCaml usa `leap_year 2024`, más simple."
      ]
    },
    "ejercicio-4": {
      "title": "Signo de un número",
      "racket": {
        "lines": [
          "(define (sign x)",
          "  (cond",
          "    [(> x 0) 1]",
          "    [(< x 0) -1]",
          "    [else 0]",
          "  )",
          ")",
          "(sign -2)"
        ]
      },
      "ocaml": {
        "lines": [
          "let sign x =",
          "  if x > 0 then",
          "    1",
          "  else if x < 0 then",
          "    -1",
          "  else",
          "    0",
          "in",
          "sign (-2)"
        ]
      },
      "explanations_racket": [
        "Define una función `sign` que toma un parámetro `x` para determinar su signo (1, -1, 0). La sintaxis `(define (nombre params) cuerpo)` es funcional, como etiquetar el cambio en una reseña.",
        "Inicia un condicional `cond` para evaluar múltiples casos, una expresión pura que clasifica según condiciones.",
        "Evalúa si `x > 0`, retornando `1`, como indicar un cambio positivo en una puntuación.",
        "Evalúa si `x < 0`, retornando `-1`, para valores negativos, manteniendo pureza.",
        "Si ninguna condición previa es verdadera, retorna `0` con `else`, para el caso neutro.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `sign` con -2, retornando `-1` porque `-2 < 0`, mostrando la función."
      ],
      "explanations_ocaml": [
        "Define una función `sign` con un parámetro `x` para determinar su signo, usando `let nombre params = cuerpo`. Es una abstracción funcional, como clasificar una variación en datos.",
        "Inicia un condicional `if` con `x > 0` en notación infija, evaluando la primera condición con pureza.",
        "Si `x > 0`, retorna `1`, para valores positivos.",
        "Introduce un `else if` para `x < 0`, retornando `-1`, para valores negativos.",
        "Introduce la rama `else`, retornando `0` para el caso neutro, necesaria para completar el condicional.",
        "Cierra la rama `else` con `0`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `sign` con -2, retornando `-1` porque `-2 < 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para determinar el signo de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza. Diferencias: Racket usa `cond`, más flexible, OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas retornan `1` para el caso positivo. Diferencias: Racket usa una rama de `cond`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas retornan `-1` para el caso negativo. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`, aumentando líneas.",
        "Similitudes: Ambas retornan `0` para el caso neutro. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `0`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con -2, retornando `-1`. Diferencias: Racket usa `(sign -2)`, OCaml usa `sign (-2)` con paréntesis para el negativo."
      ]
    },
    "ejercicio-5": {
      "title": "Sistema de calificación",
      "racket": {
        "lines": [
          "(define (grade score)",
          "  (cond",
          "    [(>= score 90) 'A]",
          "    [(>= score 80) 'B]",
          "    [(>= score 70) 'C]",
          "    [(>= score 60) 'D]",
          "    [else 'F]",
          "  )",
          ")",
          "(grade 92)"
        ]
      },
      "ocaml": {
        "lines": [
          "let grade score =",
          "  if score >= 90 then",
          "    \"A\"",
          "  else if score >= 80 then",
          "    \"B\"",
          "  else if score >= 70 then",
          "    \"C\"",
          "  else if score >= 60 then",
          "    \"D\"",
          "  else",
          "    \"F\"",
          "in",
          "grade 92"
        ]
      },
      "explanations_racket": [
        "Define una función `grade` que toma un parámetro `score` para clasificar una calificación. La sintaxis `(define (nombre params) cuerpo)` es funcional, como asignar una letra a una nota de examen.",
        "Inicia un condicional `cond` para evaluar rangos, una expresión pura que clasifica según condiciones.",
        "Evalúa si `score >= 90`, retornando `'A`, para calificaciones excelentes, como un examen perfecto.",
        "Evalúa si `score >= 80`, retornando `'B`, para calificaciones buenas.",
        "Evalúa si `score >= 70`, retornando `'C`, para calificaciones aceptables.",
        "Evalúa si `score >= 60`, retornando `'D`, para calificaciones bajas pero aprobatorias.",
        "Si ninguna condición es verdadera, retorna `'F` con `else`, para calificaciones reprobatorias.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `grade` con 92, retornando `'A` porque `92 >= 90`, mostrando la clasificación."
      ],
      "explanations_ocaml": [
        "Define una función `grade` con un parámetro `score` para clasificar una calificación, usando `let nombre params = cuerpo`. Es una abstracción funcional, como etiquetar un puntaje académico.",
        "Inicia un condicional `if` con `score >= 90` en notación infija, evaluando el primer rango con pureza.",
        "Si `score >= 90`, retorna `\"A\"`, para calificaciones excelentes.",
        "Introduce un `else if` para `score >= 80`, retornando `\"B\"`, para calificaciones buenas.",
        "Introduce otro `else if` para `score >= 70`, retornando `\"C\"`, para calificaciones aceptables.",
        "Introduce otro `else if` para `score >= 60`, retornando `\"D\"`, para calificaciones bajas.",
        "Introduce la rama `else`, retornando `\"F\"` para calificaciones reprobatorias, necesaria para completar el condicional.",
        "Cierra la rama `else` con `\"F\"`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `grade` con 92, retornando `\"A\"` porque `92 >= 90`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para clasificar calificaciones, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa cadenas, Racket usa símbolos.",
        "Similitudes: Ambas inician un condicional para clasificar rangos, con pureza. Diferencias: Racket usa `cond`, más flexible, OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas retornan `A` para ≥ 90. Diferencias: Racket usa `'A` en `cond`, OCaml usa `\"A\"` con `then`.",
        "Similitudes: Ambas retornan `B` para ≥ 80. Diferencias: Racket usa una rama de `cond`, OCaml usa `else if`.",
        "Similitudes: Ambas retornan `C` para ≥ 70. Diferencias: Racket usa una rama de `cond`, OCaml usa otro `else if`.",
        "Similitudes: Ambas retornan `D` para ≥ 60. Diferencias: Racket usa una rama de `cond`, OCaml usa otro `else if`.",
        "Similitudes: Ambas retornan `F` para < 60. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `\"F\"`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 92, retornando `A`. Diferencias: Racket usa `(grade 92)` con un símbolo, OCaml usa `grade 92` con una cadena."
      ]
    },
    "ejercicio-6": {
      "title": "Divisibilidad por 2 y 3",
      "racket": {
        "lines": [
          "(define (divisible-both? x)",
          "  (and (= (remainder x 2) 0)",
          "       (= (remainder x 3) 0))",
          ")",
          "(divisible-both? 12)"
        ]
      },
      "ocaml": {
        "lines": [
          "let divisible_both x =",
          "  x mod 2 = 0 && x mod 3 = 0",
          "in",
          "divisible_both 12"
        ]
      },
      "explanations_racket": [
        "Define una función `divisible-both?` que toma un parámetro `x` para verificar si es divisible por 2 y 3. La sintaxis `(define (nombre params) cuerpo)` es funcional, como comprobar si un número activa una alarma especial.",
        "Usa `and` para combinar dos condiciones: `(= (remainder x 2) 0)` verifica divisibilidad por 2, y `(= (remainder x 3) 0)` por 3, en notación prefija. Es una expresión pura, como verificar si un número es múltiplo común.",
        "Continúa la expresión `and`, retornando `#t` si ambas condiciones son verdaderas, `#f` si alguna falla, manteniendo pureza.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `divisible-both?` con 12, retornando `#t` porque `12 mod 2 = 0` y `12 mod 3 = 0`, mostrando que es divisible por ambos."
      ],
      "explanations_ocaml": [
        "Define una función `divisible_both` con un parámetro `x` para verificar divisibilidad por 2 y 3, usando `let nombre params = cuerpo`. Es una abstracción funcional, como validar un código de alarma.",
        "Evalúa `x mod 2 = 0 && x mod 3 = 0` en notación infija, combinando dos condiciones con `&&`. Es una expresión pura, retornando `true` si ambas son ciertas.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml, sin lógica propia.",
        "Llama a `divisible_both` con 12, retornando `true` porque `12 mod 2 = 0` y `12 mod 3 = 0`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar divisibilidad por 2 y 3, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas evalúan divisibilidad por 2 y 3 con un operador lógico, con pureza. Diferencias: Racket usa `and` y `remainder` en notación prefija, más explícita, mientras que OCaml usa `&&` y `mod` infijos, más concisos y matemáticos.",
        "Similitudes: Ambas son parte de la lógica de evaluación. Diferencias: Racket divide la expresión `and` en dos líneas por formato, OCaml la integra en una línea, más compacta.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 12, retornando verdadero. Diferencias: Racket usa `(divisible-both? 12)`, OCaml usa `divisible_both 12`, más simple."
      ]
    },
    "ejercicio-7": {
      "title": "Clasificar triángulo",
      "racket": {
        "lines": [
          "(define (triangle-type a b c)",
          "  (cond",
          "    [(and (= a b) (= b c)) 'equilateral]",
          "    [(or (= a b) (= b c) (= a c)) 'isosceles]",
          "    [else 'scalene]",
          "  )",
          ")",
          "(triangle-type 3 3 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let triangle_type a b c =",
          "  if a = b && b = c then",
          "    \"equilateral\"",
          "  else if a = b || b = c || a = c then",
          "    \"isosceles\"",
          "  else",
          "    \"scalene\"",
          "in",
          "triangle_type 3 3 3"
        ]
      },
      "explanations_racket": [
        "Define una función `triangle-type` que toma tres parámetros (`a`, `b`, `c`) para clasificar un triángulo. La sintaxis `(define (nombre params) cuerpo)` es funcional, como identificar la forma de un triángulo en un plano.",
        "Inicia un condicional `cond` para evaluar las condiciones del triángulo, una expresión pura que clasifica según igualdad de lados.",
        "Evalúa si `a = b` y `b = c` usando `and`, retornando `'equilateral` si todos los lados son iguales, como un triángulo perfecto.",
        "Evalúa si al menos dos lados son iguales usando `or`, retornando `'isosceles`, para triángulos con dos lados iguales.",
        "Si ninguna condición previa es verdadera, retorna `'scalene` con `else`, para triángulos con lados distintos.",
        "Cierra el bloque `cond`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `triangle-type` con 3, 3, 3, retornando `'equilateral` porque todos los lados son iguales, mostrando la clasificación."
      ],
      "explanations_ocaml": [
        "Define una función `triangle_type` con tres parámetros para clasificar un triángulo, usando `let nombre params = cuerpo`. Es una abstracción funcional, como categorizar una figura geométrica.",
        "Inicia un condicional `if` con `a = b && b = c` en notación infija, evaluando si todos los lados son iguales con pureza.",
        "Si `a = b && b = c`, retorna `\"equilateral\"`, para triángulos con tres lados iguales.",
        "Introduce un `else if` para `a = b || b = c || a = c`, retornando `\"isosceles\"`, para triángulos con al menos dos lados iguales.",
        "Introduce la rama `else`, retornando `\"scalene\"` para triángulos con lados distintos, necesaria para completar el condicional.",
        "Cierra la rama `else` con `\"scalene\"`, asegurando un valor puro.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `triangle_type` con 3, 3, 3, retornando `\"equilateral\"` porque todos los lados son iguales, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para clasificar triángulos, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa cadenas, Racket usa símbolos.",
        "Similitudes: Ambas inician un condicional para clasificar, con pureza. Diferencias: Racket usa `cond`, más flexible, OCaml usa `if` con anidamiento `else if`.",
        "Similitudes: Ambas retornan 'equilateral' para lados iguales. Diferencias: Racket usa `and` y `'equilateral` en `cond`, OCaml usa `&&` y `\"equilateral\"` con `then`.",
        "Similitudes: Ambas retornan 'isosceles' para dos lados iguales. Diferencias: Racket usa `or` en `cond`, OCaml usa `||` en `else if`, aumentando líneas.",
        "Similitudes: Ambas retornan 'scalene' para lados distintos. Diferencias: Racket usa `else` en `cond`, OCaml separa `else` y `\"scalene\"`, requiriendo dos líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `cond`, OCaml cierra la rama `else`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 3, 3, 3, retornando 'equilateral'. Diferencias: Racket usa `(triangle-type 3 3 3)` con un símbolo, OCaml usa `triangle_type 3 3 3` con una cadena."
      ]
    }
  },
  "recursion": {
    "ejercicio-1": {
      "title": "Suma de los primeros n números",
      "racket": {
        "lines": [
          "(define (sum-n n)",
          "  (if (<= n 0)",
          "      0",
          "      (+ n (sum-n (- n 1))))",
          ")",
          "(sum-n 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2]
      },
      "ocaml": {
        "lines": [
          "let rec sum_n n =",
          "  if n <= 0 then",
          "    0",
          "  else",
          "    n + sum_n (n - 1)",
          "in",
          "sum_n 4"
        ],
        "recursion": [
          6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `sum-n` que suma los números de 1 a `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como sumar las ventas diarias de un comerciante hasta el día n.",
        "Inicia un condicional `if` que verifica si `n <= 0` con notación prefija `(<= n 0)`, una expresión pura para el caso base, como decidir cuándo detener la suma.",
        "Si `n <= 0`, retorna 0, el caso base, indicando que no hay ventas si no hay días.",
        "Si `n > 0`, suma `n` con `sum-n` de `n - 1` usando `(+ n (sum-n (- n 1)))`, una recursión pura, como sumar la venta actual con las anteriores.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `sum-n` con 4, calculando 4 + 3 + 2 + 1 = 10, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_n` para sumar de 1 a `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, ideal para cálculos funcionales, como sumar ingresos diarios.",
        "Inicia un condicional `if` con `n <= 0` en notación infija, una expresión pura para el caso base.",
        "Si `n <= 0`, retorna 0, como no sumar nada si no hay días.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma `n` con `sum_n (n - 1)` usando notación infija `n + sum_n (n - 1)`, una recursión pura, como sumar el día actual con los anteriores.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_n` con 4, calculando 4 + 3 + 2 + 1 = 10, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar de 1 a n, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito para recursión. OCaml infiere que `n` es entero, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 0` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 0)`, OCaml usa infija `n <= 0`, más matemática.",
        "Similitudes: Ambas retornan 0 como caso base, esencial para detener la recursión. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo sumando `n`. Diferencias: Racket usa `(+ n ...)` en una línea, OCaml separa `else` y la recursión, requiriendo más líneas por estructura.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada, reflejando filosofías distintas (Lisp vs ML).",
        "Similitudes: Ambas llaman la función con 4, retornando 10. Diferencias: Racket usa `(sum-n 4)` con paréntesis, OCaml usa `sum_n 4`, más conciso en la invocación."
      ]
    },
    "ejercicio-2": {
      "title": "Potencia de un número",
      "racket": {
        "lines": [
          "(define (power base exp)",
          "  (if (= exp 0)",
          "      1",
          "      (* base (power base (- exp 1))))",
          ")",
          "(power 2 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2]
      },
      "ocaml": {
        "lines": [
          "let rec power base exp =",
          "  if exp = 0 then",
          "    1",
          "  else",
          "    base * power base (exp - 1)",
          "in",
          "power 2 4"
        ],
        "recursion": [
          6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `power` para calcular `base` elevado a `exp`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el crecimiento de una inversión que se duplica repetidamente.",
        "Inicia un condicional `if` con `(= exp 0)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `exp = 0`, retorna 1, el caso base (base^0 = 1), como una inversión sin crecimiento.",
        "Si `exp ≠ 0`, multiplica `base` por `power` de `exp - 1` usando `(* base (power base (- exp 1)))`, una recursión pura, como calcular 2^4 = 2 * 2^3.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `power` con 2 y 4, calculando 2^4 = 16, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `power` para calcular `base` elevado a `exp`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un crecimiento exponencial.",
        "Inicia un condicional `if` con `exp = 0` en notación infija, verificando el caso base con pureza.",
        "Si `exp = 0`, retorna 1, el caso base, como un cálculo sin multiplicaciones.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica `base` por `power base (exp - 1)` en notación infija, una recursión pura, como calcular 2^4 = 2 * 2^3.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `power` con 2 y 4, calculando 2^4 = 16, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular potencias, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito.",
        "Similitudes: Ambas verifican `exp = 0` con pureza funcional. Diferencias: Racket usa notación prefija `(= exp 0)`, OCaml usa infija `exp = 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo multiplicando `base`. Diferencias: Racket usa `(* base ...)` en notación prefija, OCaml usa `base * ...` infija, más concisa y matemática.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 2 y 4, retornando 16. Diferencias: Racket usa `(power 2 4)` con paréntesis, OCaml usa `power 2 4`, más simple."
      ]
    },
    "ejercicio-3": {
      "title": "Factorial de un número",
      "racket": {
        "lines": [
          "(define (factorial n)",
          "  (if (<= n 1)",
          "      1",
          "      (* n (factorial (- n 1))))",
          ")",
          "(factorial 4)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2]
      },
      "ocaml": {
        "lines": [
          "let rec factorial n =",
          "  if n <= 1 then",
          "    1",
          "  else",
          "    n * factorial (n - 1)",
          "in",
          "factorial 4"
        ],
        "recursion": [
          6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `factorial` que calcula n!. La sintaxis `(define (nombre params) cuerpo)` es funcional, como contar las formas de organizar n cajas en un almacén.",
        "Inicia un condicional `if` con `(<= n 1)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 1`, retorna 1, el caso base (0! = 1, 1! = 1), como definir una sola forma de organizar una caja o ninguna.",
        "Si `n > 1`, multiplica `n` por `factorial` de `n - 1` usando `(* n (factorial (- n 1)))`, una recursión pura, como calcular 4! = 4 * 3!.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `factorial` con 4, calculando 4! = 4 * 3 * 2 * 1 = 24, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `factorial` para calcular n!, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como calcular combinaciones de objetos.",
        "Inicia un condicional `if` con `n <= 1` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 1`, retorna 1, el caso base, como una sola configuración para una caja o ninguna.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica `n` por `factorial (n - 1)` en notación infija, una recursión pura, como calcular 4! = 4 * 3!.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `factorial` con 4, calculando 4! = 24, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular el factorial, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere que `n` es entero, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 1` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 1)`, OCaml usa infija `n <= 1`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo multiplicando `n`. Diferencias: Racket usa `(* n ...)` en notación prefija, OCaml usa `n * ...` infija, requiriendo una línea extra para `else`.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 4, retornando 24. Diferencias: Racket usa `(factorial 4)` con paréntesis, OCaml usa `factorial 4`, más conciso."
      ]
    },
    "ejercicio-4": {
      "title": "Fibonacci en la posición n",
      "racket": {
        "lines": [
          "(define (fibonacci n)",
          "  (if (<= n 1)",
          "      n",
          "      (+ (fibonacci (- n 1))",
          "         (fibonacci (- n 2)))",
          "  )",
          ")",
          "(fibonacci 6)"
        ],
        "recursion": [
          7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2, 0, 1, 2,
          0, 1, 3, 4, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 0, 1, 2
        ]
      },
      "ocaml": {
        "lines": [
          "let rec fibonacci n =",
          "  if n <= 1 then",
          "    n",
          "  else",
          "    fibonacci (n - 1) +",
          "    fibonacci (n - 2)",
          "in",
          "fibonacci 6"
        ],
        "recursion": [
          7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1,
          2, 0, 1, 2, 0, 1, 3, 4, 5, 0, 1, 2, 0, 1, 2, 0, 1, 3, 4, 5, 0, 1, 2
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `fibonacci` para calcular el número de Fibonacci en la posición `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como modelar el crecimiento de una población de conejos en un ecosistema.",
        "Inicia un condicional `if` con `(<= n 1)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 1`, retorna `n` (Fib(0) = 0, Fib(1) = 1), el caso base, como definir los primeros pasos de la población.",
        "Si `n > 1`, suma `fibonacci` de `n - 1` y `n - 2` usando notación prefija, iniciando una recursión doble, como sumar generaciones previas de conejos.",
        "Completa la recursión con `(+ (fibonacci (- n 1)) (fibonacci (- n 2)))`, una expresión pura que descompone el problema.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `fibonacci` con 6, calculando Fib(6) = 8, mostrando la recursión en acción."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `fibonacci` para calcular Fib(n), usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un patrón biológico de crecimiento.",
        "Inicia un condicional `if` con `n <= 1` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 1`, retorna `n` (Fib(0) = 0, Fib(1) = 1), como establecer los primeros valores de una secuencia.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma `fibonacci (n - 1)` y `fibonacci (n - 2)` en notación infija, una recursión doble pura, como combinar generaciones previas.",
        "Completa la suma recursiva, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `fibonacci` con 6, calculando Fib(6) = 8, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular Fibonacci, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 1` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 1)`, OCaml usa infija `n <= 1`, más matemática.",
        "Similitudes: Ambas retornan `n` como caso base (0 o 1). Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión doble para `n > 1`. Diferencias: Racket divide la suma en dos líneas por formato prefijo, OCaml usa `else` para iniciar la recursión.",
        "Similitudes: Ambas completan la recursión sumando dos llamadas. Diferencias: Racket cierra la suma en una línea separada, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la suma, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 6, retornando 8. Diferencias: Racket usa `(fibonacci 6)` con paréntesis, OCaml usa `fibonacci 6`, más conciso."
      ]
    },
    "ejercicio-5": {
      "title": "Suma de dígitos",
      "racket": {
        "lines": [
          "(define (sum-digits n)",
          "  (if (< n 10)",
          "      n",
          "      (+ (remainder n 10)",
          "         (sum-digits (quotient n 10)))",
          "  )",
          ")",
          "(sum-digits 12345)"
        ],
        "recursion": [
          7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2
        ]
      },
      "ocaml": {
        "lines": [
          "let rec sum_digits n =",
          "  if n < 10 then",
          "    n",
          "  else",
          "    (n mod 10) +",
          "    sum_digits (n / 10)",
          "in",
          "sum_digits 12345"
        ],
        "recursion": [
          7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1,
          3, 4, 5, 0, 1, 2
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `sum-digits` para sumar los dígitos de `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como sumar los números de un código postal para validarlo.",
        "Inicia un condicional `if` con `(< n 10)`, verificando si `n` es un solo dígito, una expresión pura para el caso base.",
        "Si `n < 10`, retorna `n`, el caso base, como tomar un solo dígito de un código.",
        "Si `n >= 10`, suma el último dígito (`remainder n 10`) con la suma de los dígitos de `n` dividido por 10 (`quotient n 10`), iniciando la recursión, como descomponer 12345 en 5 + 4 + 3 + 2 + 1.",
        "Completa la recursión sumando el resultado de `sum-digits (quotient n 10)`, una expresión pura que reduce el número.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `sum-digits` con 12345, calculando 1 + 2 + 3 + 4 + 5 = 15, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_digits` para sumar los dígitos de `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como validar un número sumando sus partes.",
        "Inicia un condicional `if` con `n < 10` en notación infija, verificando el caso base con pureza.",
        "Si `n < 10`, retorna `n`, el caso base, como un solo dígito en un cálculo.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma el último dígito (`n mod 10`) con `sum_digits (n / 10)` en notación infija, iniciando la recursión pura.",
        "Completa la recursión con la suma, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_digits` con 12345, calculando 1 + 2 + 3 + 4 + 5 = 15, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar los dígitos de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n < 10` con pureza funcional. Diferencias: Racket usa notación prefija `(< n 10)`, OCaml usa infija `n < 10`, más matemática.",
        "Similitudes: Ambas retornan `n` como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión sumando el último dígito. Diferencias: Racket usa `remainder` y `quotient` en notación prefija, OCaml usa `mod` y `/` infijos, más concisos.",
        "Similitudes: Ambas completan la recursión sumando el resto del número. Diferencias: Racket divide la suma en dos líneas por formato prefijo, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la suma, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 12345, retornando 15. Diferencias: Racket usa `(sum-digits 12345)` con paréntesis, OCaml usa `sum_digits 12345`, más conciso."
      ]
    },
    "ejercicio-6": {
      "title": "Producto de los primeros n impares",
      "racket": {
        "lines": [
          "(define (product-odds n)",
          "  (if (<= n 0)",
          "      1",
          "      (* (+ (* 2 n) -1)",
          "         (product-odds (- n 1)))",
          "  )",
          ")",
          "(product-odds 3)"
        ],
        "recursion": [7, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2]
      },
      "ocaml": {
        "lines": [
          "let rec product_odds n =",
          "  if n <= 0 then",
          "    1",
          "  else",
          "    (2 * n - 1) *",
          "    product_odds (n - 1)",
          "in",
          "product_odds 3"
        ],
        "recursion": [7, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 3, 4, 5, 0, 1, 2]
      },
      "explanations_racket": [
        "Define una función recursiva `product-odds` para calcular el producto de los primeros n números impares (1, 3, 5, ...). La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el producto de valores alternados en un experimento matemático.",
        "Inicia un condicional `if` con `(<= n 0)`, verificando el caso base con notación prefija, una expresión pura para detener la recursión.",
        "Si `n <= 0`, retorna 1, el caso base, como el producto vacío (neutro para la multiplicación).",
        "Si `n > 0`, multiplica el n-ésimo impar `(+ (* 2 n) -1)` por `product-odds` de `n - 1`, iniciando la recursión, como calcular 1 * 3 * 5 para n = 3.",
        "Completa la recursión con la multiplicación, una expresión pura que reduce el problema.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `product-odds` con 3, calculando 1 * 3 * 5 = 15, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `product_odds` para calcular el producto de los primeros n impares, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como modelar un cálculo matemático.",
        "Inicia un condicional `if` con `n <= 0` en notación infija, verificando el caso base con pureza.",
        "Si `n <= 0`, retorna 1, el caso base, como un producto vacío.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Multiplica el n-ésimo impar `(2 * n - 1)` por `product_odds (n - 1)` en notación infija, iniciando la recursión pura.",
        "Completa la multiplicación recursiva, dividiendo la expresión por formato, pero manteniendo la lógica en una sola operación.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `product_odds` con 3, calculando 1 * 3 * 5 = 15, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para calcular el producto de impares, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n <= 0` con pureza funcional. Diferencias: Racket usa notación prefija `(<= n 0)`, OCaml usa infija `n <= 0`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas inician la recursión multiplicando el n-ésimo impar. Diferencias: Racket usa `(+ (* 2 n) -1)` en notación prefija, OCaml usa `(2 * n - 1)` infija, más concisa.",
        "Similitudes: Ambas completan la recursión con la multiplicación. Diferencias: Racket divide la expresión en dos líneas por formato prefijo, OCaml divide por formato, pero la lógica es idéntica.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra el `if`, OCaml cierra la multiplicación, equilibrando el conteo de líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 3, retornando 15. Diferencias: Racket usa `(product-odds 3)` con paréntesis, OCaml usa `product_odds 3`, más conciso."
      ]
    },
    "ejercicio-7": {
      "title": "Contar dígitos",
      "racket": {
        "lines": [
          "(define (count-digits n)",
          "  (if (< n 10)",
          "      1",
          "      (+ 1 (count-digits (quotient n 10))))",
          ")",
          "(count-digits 1234)"
        ],
        "recursion": [5, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 3, 0, 1, 2]
      },
      "ocaml": {
        "lines": [
          "let rec count_digits n =",
          "  if n < 10 then",
          "    1",
          "  else",
          "    1 + count_digits (n / 10)",
          "in",
          "count_digits 1234"
        ],
        "recursion": [
          6, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 0, 1, 2
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `count-digits` para contar los dígitos de `n`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como validar un número de teléfono contando sus cifras.",
        "Inicia un condicional `if` con `(< n 10)`, verificando si `n` es un solo dígito, una expresión pura para el caso base.",
        "Si `n < 10`, retorna 1, el caso base, como contar una sola cifra en un número.",
        "Si `n >= 10`, suma 1 al conteo de dígitos de `n` dividido por 10 (`quotient n 10`), una recursión pura, como contar cada cifra de 1234.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `count-digits` con 1234, calculando 4 dígitos, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `count_digits` para contar los dígitos de `n`, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, como validar un código contando sus partes.",
        "Inicia un condicional `if` con `n < 10` en notación infija, verificando el caso base con pureza.",
        "Si `n < 10`, retorna 1, el caso base, como una sola cifra en un número.",
        "Introduce la rama `else`, necesaria en OCaml para completar el condicional, preparando la recursión.",
        "Suma 1 a `count_digits (n / 10)` en notación infija, una recursión pura para contar los dígitos restantes.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `count_digits` con 1234, calculando 4 dígitos, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para contar los dígitos de un número, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere tipos enteros, Racket es dinámico.",
        "Similitudes: Ambas verifican `n < 10` con pureza funcional. Diferencias: Racket usa notación prefija `(< n 10)`, OCaml usa infija `n < 10`, más matemática.",
        "Similitudes: Ambas retornan 1 como caso base. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas manejan el caso recursivo sumando 1. Diferencias: Racket usa `quotient` en notación prefija, OCaml usa `/` infija, más concisa y matemática.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in` para la llamada.",
        "Similitudes: Ambas llaman la función con 1234, retornando 4. Diferencias: Racket usa `(count-digits 1234)` con paréntesis, OCaml usa `count_digits 1234`, más conciso."
      ]
    }
  },
  "listas": {
    "ejercicio-1": {
      "title": "Contar elementos de una lista",
      "racket": {
        "lines": [
          "(define (length lst)",
          "  (if (empty? lst)",
          "      0",
          "      (+ 1 (length (rest lst))))",
          ")",
          "(length '(1 2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec length lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    1 + length (List.tl lst)",
          "in",
          "length [1; 2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `length` que calcula la cantidad de elementos en una lista `lst`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como contar cuántas tareas hay en una agenda.",
        "Inicia un condicional `if` con `(empty? lst)`, verificando si la lista está vacía, una expresión pura para el caso base en el paradigma funcional.",
        "Si la lista está vacía, retorna 0, como una agenda sin tareas.",
        "Si la lista no está vacía, suma 1 a la longitud del resto de la lista (`rest lst`), usando recursión pura, como contar una tarea y seguir con las demás.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `length` con `'(1 2 3 4)`, dando 4, mostrando cómo la recursión cuenta los elementos."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `length` para contar los elementos de una lista, usando `let rec nombre params = cuerpo`. El `rec` habilita recursión, ideal para listas inmutables, como contar los ítems en un inventario.",
        "Inicia un condicional `if` con `lst = []`, verificando si la lista está vacía, una expresión pura para el caso base.",
        "Si la lista es vacía (`[]`), retorna 0, como un inventario sin ítems.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar la recursión en listas no vacías.",
        "Suma 1 a la longitud de la cola (`List.tl lst`), usando recursión pura, como contar un ítem y continuar con los demás.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `length` con `[1; 2; 3; 4]`, dando 4, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para contar elementos en una lista, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`, con `rec` explícito. OCaml infiere que `lst` es una lista, Racket es dinámico.",
        "Similitudes: Ambas verifican si la lista está vacía con pureza funcional. Diferencias: Racket usa `(empty? lst)` en notación prefija, OCaml usa `lst = []` infija, más matemática.",
        "Similitudes: Ambas retornan 0 para la lista vacía. Diferencias: Racket integra el caso base en el `if`, OCaml usa `then` explícitamente.",
        "Similitudes: Ambas suman 1 en la recursión. Diferencias: Racket usa `(rest lst)` para la cola, OCaml usa `List.tl lst`, que es más explícito al requerir el módulo `List`.",
        "Similitudes: Ambas son estructurales, sin lógica propia. Diferencias: Racket cierra la definición con `)`, OCaml usa `in`, aumentando el conteo de líneas en OCaml.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando 4. Diferencias: Racket usa `'(1 2 3 4)` con comillas, OCaml usa `[1; 2; 3; 4]` con punto y coma, reflejando sintaxis de listas distintas."
      ]
    },
    "ejercicio-2": {
      "title": "Obtener el primer elemento",
      "racket": {
        "lines": [
          "(define (first-element lst)",
          "  (if (empty? lst)",
          "      null",
          "      (first lst))",
          ")",
          "(first-element '(5 6 7))"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_element lst =",
          "  if lst = [] then",
          "    None",
          "  else",
          "    Some (List.hd lst)",
          "in",
          "first_element [5; 6; 7]"
        ]
      },
      "explanations_racket": [
        "Define una función `first-element` para obtener el primer elemento de una lista `lst`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como identificar la primera tarea en una lista de pendientes.",
        "Inicia un condicional `if` con `(empty? lst)`, verificando si la lista está vacía, una expresión pura para el caso base.",
        "Si la lista está vacía, retorna `null`, indicando que no hay primer elemento, como una lista de tareas vacía.",
        "Si la lista no está vacía, retorna el primer elemento con `(first lst)`, como tomar la primera tarea de la lista.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `first-element` con `'(5 6 7)`, dando 5, mostrando el acceso directo al primer elemento."
      ],
      "explanations_ocaml": [
        "Define una función `first_element` para obtener el primer elemento, usando `let nombre params = cuerpo`. Es funcional, como seleccionar el primer artículo en un inventario.",
        "Inicia un condicional `if` con `lst = []`, verificando si la lista está vacía, una expresión pura para el caso base.",
        "Si la lista es vacía (`[]`), retorna `None`, usando el tipo `option` para indicar que no hay elemento, como un inventario vacío.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar listas no vacías.",
        "Retorna `Some (List.hd lst)`, envolviendo el primer elemento en el constructor `Some`, como confirmar que hay un artículo disponible.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `first_element` con `[5; 6; 7]`, dando `Some 5`, mostrando el acceso al primer elemento."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para obtener el primer elemento de una lista, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` y no es recursiva, OCaml usa `let nombre params = cuerpo` sin `rec`. OCaml usa el tipo `option`, Racket es dinámico.",
        "Similitudes: Ambas verifican si la lista está vacía con pureza. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija.",
        "Similitudes: Ambas manejan el caso de la lista vacía. Diferencias: Racket retorna `null`, OCaml retorna `None`, reflejando el manejo de tipos en OCaml.",
        "Similitudes: Ambas retornan el primer elemento si la lista no está vacía. Diferencias: Racket usa `(first lst)`, OCaml usa `Some (List.hd lst)`, con `Some` para tipado seguro.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`, aumentando el conteo de líneas en OCaml.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, retornando el primer elemento. Diferencias: Racket usa `'(5 6 7)` y retorna 5, OCaml usa `[5; 6; 7]` y retorna `Some 5`, debido al tipo `option`."
      ]
    },
    "ejercicio-3": {
      "title": "Obtener el último elemento",
      "racket": {
        "lines": [
          "(define (last-element lst)",
          "  (if (empty? (rest lst))",
          "      (first lst)",
          "      (last-element (rest lst)))",
          ")",
          "(last-element '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec last_element lst =",
          "  if List.tl lst = [] then",
          "    List.hd lst",
          "  else",
          "    last_element (List.tl lst)",
          "in",
          "last_element [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `last-element` para obtener el último elemento de una lista. La sintaxis `(define (nombre params) cuerpo)` es funcional, como encontrar al último cliente en una cola.",
        "Inicia un condicional `if` con `(empty? (rest lst))`, verificando si la lista tiene un solo elemento (su resto es vacío), una expresión pura para el caso base.",
        "Si la lista tiene un solo elemento, retorna `(first lst)`, el último elemento, como el único cliente en la cola.",
        "Si la lista tiene más elementos, llama a `last-element` con el resto (`rest lst`), usando recursión pura, como avanzar al siguiente cliente en la cola.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `last-element` con `'(1 2 3)`, dando 3, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `last_element` para obtener el último elemento, usando `let rec nombre params = cuerpo`. Es funcional, como identificar la última tarea en una lista.",
        "Inicia un condicional `if` con `List.tl lst = []`, verificando si la lista tiene un solo elemento, una expresión pura para el caso base.",
        "Si la lista tiene un solo elemento, retorna `List.hd lst`, el último elemento, como la última tarea.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar la recursión en listas con más elementos.",
        "Llama a `last_element` con la cola (`List.tl lst`), usando recursión pura, como pasar a la siguiente tarea.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `last_element` con `[1; 2; 3]`, dando 3, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para obtener el último elemento, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`. OCaml infiere tipos, Racket asume listas no vacías.",
        "Similitudes: Ambas verifican si la lista tiene un solo elemento con pureza. Diferencias: Racket usa `(empty? (rest lst))` prefija, OCaml usa `List.tl lst = []` infija, más explícita con el módulo `List`.",
        "Similitudes: Ambas retornan el primer elemento como caso base. Diferencias: Racket usa `(first lst)`, OCaml usa `List.hd lst`, requiriendo el módulo `List`.",
        "Similitudes: Ambas manejan la recursión con la cola. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`, pero OCaml requiere `else` explícito, aumentando líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando 3. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]` con punto y coma."
      ]
    },
    "ejercicio-4": {
      "title": "Concatenar dos listas",
      "racket": {
        "lines": [
          "(define (append lst1 lst2)",
          "  (if (empty? lst1)",
          "      lst2",
          "      (cons (first lst1)",
          "            (append (rest lst1) lst2))",
          "  )",
          ")",
          "(append '(1 2) '(3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec append lst1 lst2 =",
          "  if lst1 = [] then",
          "    lst2",
          "  else",
          "    List.hd lst1 :: append (List.tl lst1) lst2",
          "in",
          "append [1; 2] [3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función recursiva `append` para concatenar dos listas `lst1` y `lst2`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como unir dos listas de productos en un mercado.",
        "Inicia un condicional `if` con `(empty? lst1)`, verificando si la primera lista está vacía, una expresión pura para el caso base.",
        "Si `lst1` está vacía, retorna `lst2`, como devolver la segunda lista si la primera no tiene productos.",
        "Si `lst1` no está vacía, construye una nueva lista con el primer elemento de `lst1` (`first lst1`) y la concatenación del resto (`append (rest lst1) lst2`), usando `cons` y recursión pura.",
        "Completa la construcción de la lista recursiva, como añadir un producto y continuar uniendo.",
        "Cierra el bloque `if`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `append` con `'(1 2)` y `'(3 4)`, dando `(1 2 3 4)`, mostrando la recursión."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `append` para concatenar dos listas, usando `let rec nombre params = cuerpo`. Es funcional, como combinar dos listas de tareas.",
        "Inicia un condicional `if` con `lst1 = []`, verificando si la primera lista está vacía, una expresión pura para el caso base.",
        "Si `lst1` es vacía (`[]`), retorna `lst2`, como devolver la segunda lista de tareas.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar la recursión.",
        "Construye una lista con el primer elemento de `lst1` (`List.hd lst1`) y la concatenación de la cola (`append (List.tl lst1) lst2`), usando `::` y recursión pura.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `append` con `[1; 2]` y `[3; 4]`, dando `[1; 2; 3; 4]`, demostrando la recursión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para concatenar dos listas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`. OCaml infiere tipos de lista, Racket es dinámico.",
        "Similitudes: Ambas verifican si la primera lista está vacía con pureza. Diferencias: Racket usa `(empty? lst1)` prefija, OCaml usa `lst1 = []` infija.",
        "Similitudes: Ambas retornan `lst2` para el caso base. Diferencias: Racket usa `lst2` directamente, OCaml usa `lst2` en el contexto de `if`.",
        "Similitudes: Ambas construyen una nueva lista con la cabeza de `lst1`. Diferencias: Racket usa `(cons (first lst1) ...)` prefija, OCaml usa `List.hd lst1 :: ...` infija, más concisa.",
        "Similitudes: Ambas completan la recursión con la cola de `lst1`. Diferencias: Racket usa `(rest lst1)`, OCaml usa `List.tl lst1`, requiriendo el módulo `List`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el `if`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con dos listas, dando `(1 2 3 4)`. Diferencias: Racket usa `'(1 2)` y `'(3 4)`, OCaml usa `[1; 2]` y `[3; 4]` con punto y coma."
      ]
    },
    "ejercicio-5": {
      "title": "Obtener el resto de la lista",
      "racket": {
        "lines": [
          "(define (rest-list lst)",
          "  (if (empty? lst)",
          "      null",
          "      (rest lst))",
          ")",
          "(rest-list '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rest_list lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    List.tl lst",
          "in",
          "rest_list [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función `rest-list` para obtener el resto de una lista (sin el primer elemento). La sintaxis `(define (nombre params) cuerpo)` es funcional, como eliminar la primera tarea completada de una lista.",
        "Inicia un condicional `if` con `(empty? lst)`, verificando si la lista está vacía, una expresión pura para el caso base.",
        "Si la lista está vacía, retorna `null`, como una lista de tareas vacía.",
        "Si la lista no está vacía, retorna el resto (`rest lst`), como eliminar la primera tarea y devolver las restantes.",
        "Cierra la definición de la función, necesaria para la sintaxis de Racket.",
        "Llama a `rest-list` con `'(1 2 3)`, dando `(2 3)`, mostrando la manipulación de la lista."
      ],
      "explanations_ocaml": [
        "Define una función `rest_list` para obtener el resto de una lista, usando `let nombre params = cuerpo`. Es funcional, como quitar el primer artículo de un inventario.",
        "Inicia un condicional `if` con `lst = []`, verificando si la lista está vacía, una expresión pura para el caso base.",
        "Si la lista es vacía (`[]`), retorna `[]`, como un inventario vacío.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar listas no vacías.",
        "Retorna la cola de la lista (`List.tl lst`), como devolver los artículos restantes.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `rest_list` con `[1; 2; 3]`, dando `[2; 3]`, mostrando la manipulación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para obtener el resto de una lista, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` y no es recursiva, OCaml usa `let nombre params = cuerpo` sin `rec`. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas verifican si la lista está vacía con pureza. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija.",
        "Similitudes: Ambas retornan la lista vacía para el caso base. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas retornan la cola si la lista no está vacía. Diferencias: Racket usa `(rest lst)`, OCaml usa `List.tl lst`, requiriendo el módulo `List`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`, aumentando líneas en OCaml.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(2 3)`. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]` con punto y coma."
      ]
    },
    "ejercicio-6": {
      "title": "Verificar si una lista está vacía",
      "racket": {
        "lines": [
          "(define (empty-list? lst)",
          "  (empty? lst))",
          "(empty-list? '())"
        ]
      },
      "ocaml": {
        "lines": ["let empty_list lst =", "  lst = []", "in", "empty_list []"]
      },
      "explanations_racket": [
        "Define una función `empty-list?` para verificar si una lista está vacía. La sintaxis `(define (nombre params) cuerpo)` es funcional, como comprobar si una bandeja de tareas está vacía.",
        "Usa `(empty? lst)` para retornar `#t` si la lista está vacía, o `#f` si no, una expresión pura sin recursión.",
        "Llama a `empty-list?` con `'()`, dando `#t`, mostrando la verificación directa."
      ],
      "explanations_ocaml": [
        "Define una función `empty_list` para verificar si una lista está vacía, usando `let nombre params = cuerpo`. Es funcional, como confirmar si un buzón está vacío.",
        "Compara `lst` con `[]` usando `lst = []`, retornando `true` si la lista está vacía, o `false` si no, una expresión pura sin recursión.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `empty_list` con `[]`, dando `true`, mostrando la verificación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si una lista está vacía, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. Racket usa nombres con `?` para predicados, OCaml no.",
        "Similitudes: Ambas verifican la lista vacía con pureza, sin recursión. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija, más matemática.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket no usa líneas adicionales, OCaml usa `in`, aumentando el conteo de líneas.",
        "Similitudes: Ambas llaman la función con una lista vacía, dando verdadero. Diferencias: Racket usa `'()` y retorna `#t`, OCaml usa `[]` y retorna `true`."
      ]
    },
    "ejercicio-7": {
      "title": "Añadir un elemento al inicio",
      "racket": {
        "lines": [
          "(define (cons-element x lst)",
          "  (cons x lst))",
          "(cons-element 0 '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let cons_element x lst =",
          "  x :: lst",
          "in",
          "cons_element 0 [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función `cons-element` para añadir un elemento `x` al inicio de una lista `lst`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como agregar una nueva tarea al principio de una lista.",
        "Usa `(cons x lst)` para construir una nueva lista con `x` como primer elemento seguido de `lst`, una operación pura sin recursión.",
        "Llama a `cons-element` con 0 y `'(1 2 3)`, dando `(0 1 2 3)`, mostrando la construcción de la lista."
      ],
      "explanations_ocaml": [
        "Define una función `cons_element` para añadir un elemento al inicio, usando `let nombre params = cuerpo`. Es funcional, como añadir un artículo al frente de un inventario.",
        "Usa `x :: lst` para construir una nueva lista con `x` como cabeza y `lst` como cola, una operación pura sin recursión.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `cons_element` con 0 y `[1; 2; 3]`, dando `[0; 1; 2; 3]`, mostrando la construcción."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para añadir un elemento al inicio de una lista, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere tipos, Racket es dinámico.",
        "Similitudes: Ambas construyen una nueva lista con el elemento y la lista original, sin recursión. Diferencias: Racket usa `(cons x lst)` prefija, OCaml usa `x :: lst` infija, más concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket no usa líneas adicionales, OCaml usa `in`, aumentando el conteo de líneas.",
        "Similitudes: Ambas llaman la función con 0 y una lista de 3 elementos, dando `(0 1 2 3)`. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]` con punto y coma."
      ]
    }
  },
  "funciones-orden-superior": {
    "ejercicio-1": {
      "title": "Duplicar elementos de una lista con map",
      "racket": {
        "lines": [
          "(define (double-list lst)",
          "  (map (lambda (x) (* x 2))",
          "       lst",
          "  )",
          ")",
          "(double-list '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let double_list lst =",
          "  List.map (fun x -> x * 2) lst",
          "in",
          "double_list [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `double-list` que toma una lista `lst` para duplicar cada elemento. La sintaxis `(define (nombre params) cuerpo)` es funcional, ideal para transformaciones puras, como duplicar precios en una tienda.",
        "Usa `map` para aplicar una función anónima `(lambda (x) (* x 2))` que multiplica cada elemento por 2, retornando una nueva lista. `map` es una función de alto orden pura, como un cajero que ajusta cada precio sin cambiar el original.",
        "Pasa la lista `lst` como argumento a `map`, asegurando que la transformación se aplique a todos los elementos.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `double-list` con `'(2 3 4)`, retornando `(4 6 8)`, mostrando cómo `map` transforma la lista."
      ],
      "explanations_ocaml": [
        "Define una función `double_list` para duplicar cada elemento de una lista, usando `let nombre params = cuerpo`. En OCaml, las listas son inmutables, ideales para transformaciones puras, como ajustar precios en un catálogo.",
        "Usa `List.map` para aplicar `(fun x -> x * 2)` a cada elemento, retornando una nueva lista. `List.map` es una función de alto orden pura, como un sistema que duplica valores sin alterar el original.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml que separa definición y uso.",
        "Llama a `double_list` con `[2; 3; 4]`, retornando `[4; 6; 8]`, demostrando la transformación funcional."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para duplicar elementos usando `map`, promoviendo abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere que `lst` es una lista de enteros, Racket es dinámico.",
        "Similitudes: Ambas usan una función de alto orden (`map`/`List.map`) para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (* x 2))` en notación prefija, OCaml usa `(fun x -> x * 2)` infija, más matemática. OCaml requiere `List.map` para el módulo `List`.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada por formato, OCaml integra `lst` en la línea de `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`, aumentando el conteo de líneas.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(4 6 8)`. Diferencias: Racket usa `'(2 3 4)` con comillas, OCaml usa `[2; 3; 4]` con punto y coma."
      ]
    },
    "ejercicio-2": {
      "title": "Filtrar números pares con filter",
      "racket": {
        "lines": [
          "(define (even-numbers lst)",
          "  (filter (lambda (x) (= (remainder x 2) 0))",
          "          lst",
          "  )",
          ")",
          "(even-numbers '(1 2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let even_numbers lst =",
          "  List.filter (fun x -> x mod 2 = 0) lst",
          "in",
          "even_numbers [1; 2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `even-numbers` para filtrar números pares de una lista. La sintaxis `(define (nombre params) cuerpo)` es funcional, como seleccionar tallas pares en un almacén.",
        "Usa `filter` para aplicar `(lambda (x) (= (remainder x 2) 0))`, que verifica si un número es par, retornando una nueva lista con solo los pares. `filter` es una función de alto orden pura, como un filtro que selecciona solo ciertos productos.",
        "Pasa la lista `lst` a `filter`, asegurando que se evalúe cada elemento.",
        "Cierra el bloque de `filter`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `even-numbers` con `'(1 2 3 4)`, retornando `(2 4)`, mostrando el filtrado funcional."
      ],
      "explanations_ocaml": [
        "Define una función `even_numbers` para filtrar números pares, usando `let nombre params = cuerpo`. Es una operación pura, como elegir solo los artículos en oferta de un catálogo.",
        "Usa `List.filter` para aplicar `(fun x -> x mod 2 = 0)`, seleccionando los pares. `List.filter` es una función de alto orden pura, como un tamiz que selecciona ciertos elementos.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `even_numbers` con `[1; 2; 3; 4]`, retornando `[2; 4]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar números pares usando `filter`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función de alto orden (`filter`/`List.filter`) para seleccionar elementos puros. Diferencias: Racket usa `(lambda (x) (= (remainder x 2) 0))` prefija, OCaml usa `(fun x -> x mod 2 = 0)` infija, más matemática. OCaml requiere `List.filter`.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml la integra en `List.filter`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `filter`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando `(2 4)`. Diferencias: Racket usa `'(1 2 3 4)`, OCaml usa `[1; 2; 3; 4]`."
      ]
    },
    "ejercicio-3": {
      "title": "Elevar al cuadrado con map",
      "racket": {
        "lines": [
          "(define (square-list lst)",
          "  (map (lambda (x) (* x x))",
          "       lst",
          "  )",
          ")",
          "(square-list '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let square_list lst =",
          "  List.map (fun x -> x * x) lst",
          "in",
          "square_list [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `square-list` para calcular el cuadrado de cada elemento de una lista. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular áreas de cuadrados a partir de sus lados.",
        "Usa `map` para aplicar `(lambda (x) (* x x))` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura, como transformar medidas en áreas sin modificar la lista.",
        "Pasa la lista `lst` a `map`, asegurando que todos los elementos se transformen.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `square-list` con `'(2 3 4)`, retornando `(4 9 16)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `square_list` para calcular el cuadrado de cada elemento, usando `let nombre params = cuerpo`. Es una operación pura, como calcular pesos al cuadrado en un inventario.",
        "Usa `List.map` para aplicar `(fun x -> x * x)` a cada elemento. `List.map` es una función de alto orden pura, como transformar valores en cálculos derivados.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `square_list` con `[2; 3; 4]`, retornando `[4; 9; 16]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular cuadrados usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (* x x))` prefija, OCaml usa `(fun x -> x * x)` infija, más matemática. OCaml requiere `List.map`.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml la integra en `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(4 9 16)`. Diferencias: Racket usa `'(2 3 4)`, OCaml usa `[2; 3; 4]`."
      ]
    },
    "ejercicio-4": {
      "title": "Filtrar números mayores a 10 con filter",
      "racket": {
        "lines": [
          "(define (greater-than-ten lst)",
          "  (filter (lambda (x) (> x 10))",
          "          lst",
          "  )",
          ")",
          "(greater-than-ten '(5 12 8 15))"
        ]
      },
      "ocaml": {
        "lines": [
          "let greater_than_ten lst =",
          "  List.filter (fun x -> x > 10) lst",
          "in",
          "greater_than_ten [5; 12; 8; 15]"
        ]
      },
      "explanations_racket": [
        "Define una función `greater-than-ten` para filtrar números mayores a 10. La sintaxis `(define (nombre params) cuerpo)` es funcional, como seleccionar asistentes mayores de 10 años para un evento.",
        "Usa `filter` para aplicar `(lambda (x) (> x 10))`, que verifica si un número es mayor a 10, retornando una nueva lista. `filter` es una función de alto orden pura, como un guardia que solo deja pasar a ciertos asistentes.",
        "Pasa la lista `lst` a `filter`, evaluando cada elemento.",
        "Cierra el bloque de `filter`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `greater-than-ten` con `'(5 12 8 15)`, retornando `(12 15)`, mostrando el filtrado."
      ],
      "explanations_ocaml": [
        "Define una función `greater_than_ten` para filtrar números mayores a 10, usando `let nombre params = cuerpo`. Es una operación pura, como elegir participantes con cierta edad mínima.",
        "Usa `List.filter` para aplicar `(fun x -> x > 10)`, seleccionando los números mayores a 10. `List.filter` es una función de alto orden pura, como un filtro que selecciona ciertos registros.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `greater_than_ten` con `[5; 12; 8; 15]`, retornando `[12; 15]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar números mayores a 10 usando `filter`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `filter`/`List.filter` para seleccionar elementos puros. Diferencias: Racket usa `(lambda (x) (> x 10))` prefija, OCaml usa `(fun x -> x > 10)` infija. OCaml requiere `List.filter`.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml la integra en `List.filter`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `filter`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando `(12 15)`. Diferencias: Racket usa `'(5 12 8 15)`, OCaml usa `[5; 12; 8; 15]`."
      ]
    },
    "ejercicio-5": {
      "title": "Transformar con map y condicional para valores absolutos",
      "racket": {
        "lines": [
          "(define (abs-list lst)",
          "  (map (lambda (x)",
          "         (if (< x 0)",
          "             (- x)",
          "             x))",
          "       lst",
          "  )",
          ")",
          "(abs-list '(-2 3 -4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let abs_list lst =",
          "  List.map (fun x ->",
          "              if x < 0 then",
          "                -x",
          "              else",
          "                x",
          "           ) lst",
          "in",
          "abs_list [-2; 3; -4]"
        ]
      },
      "explanations_racket": [
        "Define una función `abs-list` para transformar una lista tomando el valor absoluto de cada elemento. La sintaxis `(define (nombre params) cuerpo)` es funcional, como corregir errores en un reporte financiero.",
        "Usa `map` para aplicar una función anónima `(lambda (x) ...)` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura.",
        "Inicia un condicional `if` con `(< x 0)`, verificando si el elemento es negativo, una expresión pura para decidir la transformación.",
        "Si el elemento es negativo, retorna su opuesto `(- x)`, como corregir un valor negativo en el reporte.",
        "Si el elemento no es negativo, retorna el mismo valor `x`, manteniendo el valor original.",
        "Cierra el bloque de `if` y `lambda`, necesario para la sintaxis de Racket.",
        "Pasa la lista `lst` a `map`, aplicando la transformación a todos los elementos.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `abs-list` con `'(-2 3 -4)`, retornando `(2 3 4)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `abs_list` para calcular el valor absoluto de cada elemento, usando `let nombre params = cuerpo`. Es una operación pura, como ajustar valores en un informe.",
        "Usa `List.map` para aplicar una función anónima `(fun x -> ...)` a cada elemento. `List.map` es una función de alto orden pura.",
        "Inicia un condicional `if` con `x < 0`, verificando si el elemento es negativo, una expresión pura.",
        "Si el elemento es negativo, retorna `-x`, como corregir un valor en el informe.",
        "Introduce `else` para manejar el caso no negativo, una convención requerida en OCaml.",
        "Retorna `x` si no es negativo, manteniendo el valor original.",
        "Cierra el bloque de la función anónima, aplicando la transformación a `lst`.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `abs_list` con `[-2; 3; -4]`, retornando `[2; 3; 4]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular valores absolutos usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una función pura. Diferencias: Racket usa `(lambda (x) ...)` prefija, OCaml usa `(fun x -> ...)` infija. OCaml requiere `List.map`.",
        "Similitudes: Ambas verifican si el elemento es negativo con pureza. Diferencias: Racket usa `(< x 0)` prefija, OCaml usa `x < 0` infija.",
        "Similitudes: Ambas retornan el opuesto para negativos. Diferencias: Racket usa `(- x)` prefija, OCaml usa `-x` infija.",
        "Similitudes: Ambas retornan el valor original para no negativos. Diferencias: OCaml requiere `else` explícito, Racket lo integra en el `if`.",
        "Similitudes: Ambas cierran el condicional dentro de la función anónima. Diferencias: Racket usa paréntesis, OCaml usa indentación y `)`.",
        "Similitudes: Ambas pasan la lista a `map`/`List.map`. Diferencias: Racket usa `lst` en una línea separada, OCaml la integra.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(2 3 4)`. Diferencias: Racket usa `'(-2 3 -4)`, OCaml usa `[-2; 3; -4]`."
      ]
    },
    "ejercicio-6": {
      "title": "Filtrar números positivos con filter",
      "racket": {
        "lines": [
          "(define (positive-numbers lst)",
          "  (filter (lambda (x) (> x 0))",
          "          lst",
          "  )",
          ")",
          "(positive-numbers '(-1 2 -3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let positive_numbers lst =",
          "  List.filter (fun x -> x > 0) lst",
          "in",
          "positive_numbers [-1; 2; -3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `positive-numbers` para filtrar números positivos. La sintaxis `(define (nombre params) cuerpo)` es funcional, como seleccionar ganancias positivas en un reporte contable.",
        "Usa `filter` para aplicar `(lambda (x) (> x 0))`, que verifica si un número es positivo, retornando una nueva lista. `filter` es una función de alto orden pura, como elegir solo los ingresos positivos.",
        "Pasa la lista `lst` a `filter`, evaluando cada elemento.",
        "Cierra el bloque de `filter`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `positive-numbers` con `'(-1 2 -3 4)`, retornando `(2 4)`, mostrando el filtrado."
      ],
      "explanations_ocaml": [
        "Define una función `positive_numbers` para filtrar números positivos, usando `let nombre params = cuerpo`. Es una operación pura, como seleccionar valores positivos en un balance.",
        "Usa `List.filter` para aplicar `(fun x -> x > 0)`, seleccionando los positivos. `List.filter` es una función de alto orden pura, como un filtro que elige ciertos valores.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `positive_numbers` con `[-1; 2; -3; 4]`, retornando `[2; 4]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar números positivos usando `filter`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `filter`/`List.filter` para seleccionar elementos puros. Diferencias: Racket usa `(lambda (x) (> x 0))` prefija, OCaml usa `(fun x -> x > 0)` infija. OCaml requiere `List.filter`.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml la integra en `List.filter`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `filter`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando `(2 4)`. Diferencias: Racket usa `'(-1 2 -3 4)`, OCaml usa `[-1; 2; -3; 4]`."
      ]
    },
    "ejercicio-7": {
      "title": "Incrementar elementos con map",
      "racket": {
        "lines": [
          "(define (increment-list lst)",
          "  (map (lambda (x) (+ x 1))",
          "       lst",
          "  )",
          ")",
          "(increment-list '(10 11 12))"
        ]
      },
      "ocaml": {
        "lines": [
          "let increment_list lst =",
          "  List.map (fun x -> x + 1) lst",
          "in",
          "increment_list [10; 11; 12]"
        ]
      },
      "explanations_racket": [
        "Define una función `increment-list` para sumar 1 a cada elemento de una lista. La sintaxis `(define (nombre params) cuerpo)` es funcional, como incrementar las edades de estudiantes en una escuela.",
        "Usa `map` para aplicar `(lambda (x) (+ x 1))` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura, como un registro que actualiza edades sin modificar el original.",
        "Pasa la lista `lst` a `map`, aplicando la transformación a todos los elementos.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `increment-list` con `'(10 11 12)`, retornando `(11 12 13)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `increment_list` para sumar 1 a cada elemento, usando `let nombre params = cuerpo`. Es una operación pura, como actualizar edades en un sistema escolar.",
        "Usa `List.map` para aplicar `(fun x -> x + 1)` a cada elemento. `List.map` es una función de alto orden pura, como un programa que ajusta valores sin alterar la lista original.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `increment_list` con `[10; 11; 12]`, retornando `[11; 12; 13]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para incrementar elementos usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (+ x 1))` prefija, OCaml usa `(fun x -> x + 1)` infija. OCaml requiere `List.map`.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml la integra en `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(11 12 13)`. Diferencias: Racket usa `'(10 11 12)`, OCaml usa `[10; 11; 12]`."
      ]
    }
  },
  "tipos-datos-simples": {
    "ejercicio-1": {
      "title": "Suma de valores en una tupla",
      "racket": {
        "lines": [
          "(define (sum-tuple t)",
          "  (+ (car t) (cdr t))",
          ")",
          "(sum-tuple '(5 . 3))"
        ]
      },
      "ocaml": {
        "lines": ["let sum_tuple (a, b) =", "  a + b", "in", "sum_tuple (5, 3)"]
      },
      "explanations_racket": [
        "Define una función `sum-tuple` que toma una tupla `t` para sumar sus valores. La sintaxis `(define (nombre params) cuerpo)` es funcional, ideal para manejar estructuras simples como tuplas, como sumar horas de trabajo registradas.",
        "Suma el primer elemento (`car t`) con el segundo (`cdr t`) usando `+`, en notación prefija. La expresión es pura, siempre retorna el mismo resultado, como calcular el total de horas sin modificar el registro.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `sum-tuple` con `'(5 . 3)`, evaluando 5 + 3 = 8, mostrando cómo usar la función para un registro de horas."
      ],
      "explanations_ocaml": [
        "Define una función `sum_tuple` que desestructura una tupla `(a, b)` para sumar sus valores, usando `let nombre params = cuerpo`. En OCaml, las tuplas son inmutables, ideales para datos estructurados, como sumar horas en un informe.",
        "Suma `a` y `b` con `+`, en notación infija. La expresión es pura, como calcular el total de horas sin alterar el informe.",
        "Usa `in` para introducir el contexto de la llamada, una característica de OCaml que separa definición y uso.",
        "Llama a `sum_tuple` con `(5, 3)`, evaluando 5 + 3 = 8, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para sumar valores en una tupla, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml desestructura directamente en parámetros, Racket usa `car`/`cdr`.",
        "Similitudes: Ambas suman los dos valores, manteniendo pureza. Diferencias: Racket usa `+` en notación prefija con `car`/`cdr`, OCaml usa infija con `a + b`, más intuitiva.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una tupla (5, 3), dando 8. Diferencias: Racket usa '(5 . 3), OCaml (5, 3); Racket con paréntesis, OCaml sin."
      ]
    },
    "ejercicio-2": {
      "title": "Obtener primer elemento de tupla",
      "racket": {
        "lines": [
          "(define (first-of-tuple t)",
          "  (car t)",
          ")",
          "(first-of-tuple '(7 . 8))"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_of_tuple (a, _) =",
          "  a",
          "in",
          "first_of_tuple (7, 8)"
        ]
      },
      "explanations_racket": [
        "Define una función `first-of-tuple` para obtener el primer elemento de una tupla `t`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como extraer la coordenada x de un punto.",
        "Usa `car` para retornar el primer elemento de `t`, en notación prefija. La expresión es pura, como leer la latitud de un mapa sin cambiarlo.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `first-of-tuple` con '(7 . 8)', retornando 7, mostrando el acceso a la tupla."
      ],
      "explanations_ocaml": [
        "Define una función `first_of_tuple` que desestructura la tupla `(a, _)` para retornar `a`. En OCaml, el `_` ignora el segundo valor, ideal para acceso selectivo, como obtener la latitud de una coordenada.",
        "Retorna `a`, el primer elemento, en notación infija. La expresión es pura, como leer un valor sin alterar la estructura.",
        "Usa `in` para introducir la llamada, una característica de OCaml.",
        "Llama a `first_of_tuple` con (7, 8), retornando 7, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para obtener el primer elemento de una tupla, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml desestructura directamente.",
        "Similitudes: Ambas retornan el primer valor, con pureza. Diferencias: Racket usa `car` prefija, OCaml usa desestructura `a`, más explícita.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con tupla (7, 8), dando 7. Diferencias: Racket usa '(7 . 8), OCaml (7, 8)."
      ]
    },
    "ejercicio-3": {
      "title": "Extraer edad de registro",
      "racket": {
        "lines": [
          "(struct person (name age))",
          "(define (get-age p)",
          "  (person-age p)",
          ")",
          "(get-age (person \"Ana\" 20))"
        ]
      },
      "ocaml": {
        "lines": [
          "type person = { name: string; age: int }",
          "let get_age p =",
          "  p.age",
          "in",
          "get_age { name = \"Ana\"; age = 20 }"
        ]
      },
      "explanations_racket": [
        "Define una estructura `person` con campos `name` y `age` usando `struct`. En Racket, `struct` crea un tipo de dato inmutable, ideal para el paradigma funcional, como registrar detalles de una persona.",
        "Define una función `get-age` para extraer el campo `age` de `p`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como consultar la edad de un registro.",
        "Usa `person-age` (accesor generado por `struct`) para retornar la edad, una expresión pura.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `get-age` con un registro creado por `(person \"Ana\" 20)`, retornando 20, mostrando el acceso al campo."
      ],
      "explanations_ocaml": [
        "Define un tipo `person` con campos `name` y `age` usando `type`. En OCaml, los registros son inmutables, ideales para el paradigma funcional, como modelar datos de una persona.",
        "Define una función `get_age` para extraer `p.age`. La sintaxis `let nombre params = cuerpo` es funcional, como obtener la edad de un registro.",
        "Retorna `p.age`, el campo edad, en notación infija. La expresión es pura, como leer un dato sin cambiarlo.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `get_age` con `{ name = \"Ana\"; age = 20 }`, retornando 20, demostrando el acceso."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una estructura para una persona con nombre y edad, usando abstracción funcional. Diferencias: Racket usa `struct`, OCaml usa `type` con tipos explícitos, reflejando el tipado estático de OCaml.",
        "Similitudes: Ambas definen una función para obtener la edad. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas acceden al campo edad. Diferencias: Racket usa `person-age` como función, OCaml usa `p.age` directo, más conciso.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con un registro de \"Ana\" y 20, dando 20. Diferencias: Racket usa `(person \"Ana\" 20)`, OCaml usa `{ name = \"Ana\"; age = 20 }`."
      ]
    },
    "ejercicio-4": {
      "title": "Producto de valores en una tupla triple",
      "racket": {
        "lines": [
          "(define (product-triple t)",
          "  (* (car t) (* (cadr t) (caddr t)))",
          ")",
          "(product-triple '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let product_triple (a, b, c) =",
          "  a * b * c",
          "in",
          "product_triple (2, 3, 4)"
        ]
      },
      "explanations_racket": [
        "Define una función `product-triple` para multiplicar los valores de una tupla triple `t`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular el volumen de una caja con dimensiones en una tupla.",
        "Multiplica el primer (`car t`), segundo (`cadr t`) y tercero (`caddr t`) usando `*`, en notación prefija. La expresión es pura, como obtener el volumen sin cambiar las dimensiones.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `product-triple` con '(2 3 4)', evaluando 2 * 3 * 4 = 24, mostrando la multiplicación."
      ],
      "explanations_ocaml": [
        "Define una función `product_triple` que desestructura la tupla `(a, b, c)` para multiplicar sus valores, usando `let nombre params = cuerpo`. Es funcional, como calcular el volumen de una caja.",
        "Multiplica `a`, `b` y `c` con `*`, en notación infija. La expresión es pura, como obtener el volumen sin alterar la tupla.",
        "Usa `in` para introducir la llamada, una característica de OCaml.",
        "Llama a `product_triple` con (2, 3, 4), evaluando 2 * 3 * 4 = 24, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para multiplicar valores en una tupla triple, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml desestructura directamente en parámetros.",
        "Similitudes: Ambas calculan el producto de tres valores, con pureza. Diferencias: Racket usa `*` con `car`, `cadr`, `caddr` en notación prefija, OCaml usa `*` infija con `a`, `b`, `c`, más intuitiva.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con tupla (2, 3, 4), dando 24. Diferencias: Racket usa '(2 3 4), OCaml (2, 3, 4)."
      ]
    },
    "ejercicio-5": {
      "title": "Comparar tuplas",
      "racket": {
        "lines": [
          "(define (equal-tuples? t1 t2)",
          "  (and (= (car t1) (car t2))",
          "       (= (cdr t1) (cdr t2)))",
          ")",
          "(equal-tuples? '(1 . 2) '(1 . 2))"
        ]
      },
      "ocaml": {
        "lines": [
          "let equal_tuples (a1, b1) (a2, b2) =",
          "  a1 = a2 && b1 = b2",
          "in",
          "equal_tuples (1, 2) (1, 2)"
        ]
      },
      "explanations_racket": [
        "Define una función `equal-tuples?` para comparar dos tuplas `t1` y `t2`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como verificar si dos coordenadas son iguales.",
        "Usa `and` para comparar el primer y segundo elemento de cada tupla con `=`, `car` y `cdr`, en notación prefija. La expresión es pura, como confirmar si dos puntos son idénticos.",
        "Continúa la comparación del segundo elemento, retornando `#t` si ambos son iguales, `#f` si no.",
        "Cierra la definición de la función, requerida por Racket.",
        "Llama a `equal-tuples?` con '(1 . 2) y '(1 . 2)', dando `#t`, mostrando la comparación."
      ],
      "explanations_ocaml": [
        "Define una función `equal_tuples` que desestructura dos tuplas `(a1, b1)` y `(a2, b2)` para compararlas, usando `let nombre params = cuerpo`. Es funcional, como validar si dos registros son iguales.",
        "Compara `a1 = a2` y `b1 = b2` con `&&`, en notación infija. La expresión es pura, retornando `true` si las tuplas son iguales.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `equal_tuples` con (1, 2) y (1, 2), dando `true`, demostrando la comparación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para comparar tuplas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml desestructura directamente.",
        "Similitudes: Ambas comparan los elementos con operadores lógicos, con pureza. Diferencias: Racket usa `and` y `=` en notación prefija con `car`/`cdr`, OCaml usa `&&` y `=` infija con `a1`, `b1`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket divide la comparación en dos líneas por formato, OCaml integra en una línea.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con tuplas (1, 2), dando verdadero. Diferencias: Racket usa '(1 . 2), OCaml (1, 2)."
      ]
    },
    "ejercicio-6": {
      "title": "Extraer nombre de registro",
      "racket": {
        "lines": [
          "(struct person (name age))",
          "(define (get-name p)",
          "  (person-name p)",
          ")",
          "(get-name (person \"Bob\" 25))"
        ]
      },
      "ocaml": {
        "lines": [
          "type person = { name: string; age: int }",
          "let get_name p =",
          "  p.name",
          "in",
          "get_name { name = \"Bob\"; age = 25 }"
        ]
      },
      "explanations_racket": [
        "Define una estructura `person` con campos `name` y `age` usando `struct`. En Racket, `struct` crea un tipo de dato inmutable, ideal para el paradigma funcional, como registrar detalles de una persona en un censo.",
        "Define una función `get-name` para extraer el campo `name` de `p`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como consultar el nombre de un registro.",
        "Usa `person-name` (accesor generado por `struct`) para retornar el nombre, una expresión pura.",
        "Cierre la definición de la función, requerida por Racket.",
        "Llama a `get-name` con un registro creado por `(person \"Bob\" 25)`, retornando \"Bob\", mostrando el acceso al campo."
      ],
      "explanations_ocaml": [
        "Define un tipo `person` con campos `name` y `age` usando `type`. En OCaml, los registros son inmutables, ideales para el paradigma funcional, como modelar datos de una persona.",
        "Define una función `get_name` para extraer `p.name`. La sintaxis `let nombre params = cuerpo` es funcional, como obtener el nombre de un registro.",
        "Retorna `p.name`, el campo nombre, en notación infija. La expresión es pura, como leer un dato sin cambiarlo.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `get_name` con `{ name = \"Bob\"; age = 25 }`, retornando \"Bob\", demostrando el acceso."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una estructura para una persona con nombre y edad, usando abstracción funcional. Diferencias: Racket usa `struct` con campos nombrados, OCaml usa `type` con tipos explícitos.",
        "Similitudes: Ambas definen una función para obtener el nombre. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas acceden al campo nombre. Diferencias: Racket usa `person-name` como función, OCaml usa `p.name` directo, más conciso.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con un registro de \"Bob\" y 25, dando \"Bob\". Diferencias: Racket usa `(person \"Bob\" 25)`, OCaml usa `{ name = \"Bob\"; age = 25 }`."
      ]
    },
    "ejercicio-7": {
      "title": "Crear tupla con número y su cuadrado",
      "racket": {
        "lines": [
          "(define (number-square-tuple n)",
          "  (cons n (* n n))",
          ")",
          "(number-square-tuple 6)"
        ]
      },
      "ocaml": {
        "lines": [
          "let number_square_tuple n =",
          "  (n, n * n)",
          "in",
          "number_square_tuple 6"
        ]
      },
      "explanations_racket": [
        "Define una función `number-square-tuple` para crear una tupla con un número `n` y su cuadrado. La sintaxis `(define (nombre params) cuerpo)` es funcional, como generar pares para un profesor que calcula números y sus cuadrados.",
        "Usa `cons` para construir la tupla con `n` y `(* n n)`, en notación prefija. La expresión es pura, como crear un registro sin alterar valores.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `number-square-tuple` con 6, retornando '(6 . 36), mostrando la construcción de la tupla."
      ],
      "explanations_ocaml": [
        "Define una función `number_square_tuple` para crear una tupla con `n` y su cuadrado, usando `let nombre params = cuerpo`. Es funcional, como generar pares para cálculos matemáticos.",
        "Crea la tupla `(n, n * n)` en notación infija. La expresión es pura, como formar un par sin efectos secundarios.",
        "Usa `in` para introducir la llamada, una característica de OCaml.",
        "Llama a `number_square_tuple` con 6, retornando (6, 36), demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para crear una tupla con un número y su cuadrado, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas calculan el cuadrado y forman la tupla, con pureza. Diferencias: Racket usa `cons` y `*` prefija, OCaml usa `(,)` y `*` infija, más concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con 6, dando (6, 36). Diferencias: Racket usa '(6 . 36), OCaml (6, 36)."
      ]
    }
  },
  "cadenas-y-caracteres": {
    "ejercicio-1": {
      "title": "Longitud de una cadena",
      "racket": {
        "lines": [
          "(define (string-length str)",
          "  (string-length str)",
          ")",
          "(string-length \"admin\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let string_length str =",
          "  String.length str",
          "in",
          "string_length \"admin\""
        ]
      },
      "explanations_racket": [
        "Define una función `string-length` que toma un parámetro `str` para calcular la longitud de una cadena. La sintaxis `(define (nombre params) cuerpo)` es estándar en Racket, promoviendo abstracción funcional, como crear una herramienta reusable para contar caracteres, similar a medir la longitud de una cinta.",
        "Usa `string-length` (función primitiva de Racket) para retornar la longitud de `str`. La expresión es pura, siempre da el mismo resultado para la misma cadena, alineándose con el paradigma funcional, como contar las letras en un nombre sin cambiarlo.",
        "Cierra la definición de la función con un paréntesis, una convención estructural de Racket necesaria para completar la sintaxis.",
        "Llama a `string-length` con \"admin\", evaluando la longitud como 5, mostrando cómo usar la función para validar un usuario, como comprobar si un nombre de usuario tiene la longitud correcta."
      ],
      "explanations_ocaml": [
        "Define una función `string_length` con un parámetro `str` para calcular la longitud, usando `let nombre params = cuerpo`. En OCaml, las funciones son puras e inmutables, ideales para abstracción, como una herramienta para medir el tamaño de un texto, similar a contar palabras en una frase.",
        "Usa `String.length` (función del módulo `String`) para retornar la longitud de `str`. La expresión es pura, garantizando consistencia, como medir un mensaje sin alterarlo.",
        "Usa `in` para introducir el contexto de la llamada, una característica estructural de OCaml que separa la definición de su uso, sin lógica propia.",
        "Llama a `string_length` con \"admin\", dando 5, demostrando la función en un contexto práctico, como validar la longitud de una contraseña."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para calcular la longitud de una cadena, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml infiere que `str` es cadena, Racket es dinámico.",
        "Similitudes: Ambas usan una función primitiva para calcular longitud, manteniendo pureza. Diferencias: Racket usa `string-length` prefija, OCaml usa `String.length` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"admin\", dando 5. Diferencias: Racket usa `(string-length \"admin\")`, OCaml usa `string_length \"admin\"`, más simple."
      ]
    },
    "ejercicio-2": {
      "title": "Concatenar cadenas",
      "racket": {
        "lines": [
          "(define (concat-strings s1 s2)",
          "  (string-append s1 \" \" s2)",
          ")",
          "(concat-strings \"hola\" \"mundo\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let concat_strings s1 s2 =",
          "  s1 ^ \" \" ^ s2",
          "in",
          "concat_strings \"hola\" \"mundo\""
        ]
      },
      "explanations_racket": [
        "Define una función `concat-strings` que toma dos parámetros, `s1` y `s2`, para unir cadenas. La sintaxis `(define (nombre params) cuerpo)` es funcional, como crear un mensaje combinando palabras.",
        "Usa `string-append` para unir `s1`, un espacio, y `s2`, en notación prefija. La expresión es pura, como formar \"hola mundo\" sin alterar las palabras originales.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `concat-strings` con \"hola\" y \"mundo\", dando \"hola mundo\", mostrando cómo generar un saludo completo."
      ],
      "explanations_ocaml": [
        "Define una función `concat_strings` con dos parámetros para unir cadenas, usando `let nombre params = cuerpo`. Es funcional, como combinar textos en un documento.",
        "Usa el operador `^` para unir `s1`, un espacio, y `s2`, en notación infija. La expresión es pura, como formar un mensaje sin cambiar las partes.",
        "Usa `in` para introducir la llamada, una característica de OCaml.",
        "Llama a `concat_strings` con \"hola\" y \"mundo\", dando \"hola mundo\", demostrando la unión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para unir cadenas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas unen cadenas con un espacio, manteniendo pureza. Diferencias: Racket usa `string-append` prefija, OCaml usa `^` infijo, más conciso.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"hola\" y \"mundo\", dando \"hola mundo\". Diferencias: Racket usa `(concat-strings \"hola\" \"mundo\")`, OCaml usa `concat_strings \"hola\" \"mundo\"`."
      ]
    },
    "ejercicio-3": {
      "title": "Obtener primer carácter de cadena",
      "racket": {
        "lines": [
          "(define (first-char str)",
          "  (string-ref str 0)",
          ")",
          "(first-char \"gato\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let first_char str =",
          "  if str = \"\" then",
          "    None",
          "  else",
          "    Some (String.get str 0)",
          "in",
          "first_char \"gato\""
        ]
      },
      "explanations_racket": [
        "Define una función `first-char` para obtener el primer carácter de una cadena `str`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como extraer la inicial de una palabra para un monograma.",
        "Usa `string-ref` para acceder al carácter en posición 0 de `str`, en notación prefija. La expresión es pura, como leer la primera letra sin cambiar la palabra.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `first-char` con \"gato\", retornando #\\g, mostrando la extracción."
      ],
      "explanations_ocaml": [
        "Define una función `first_char` para obtener el primer carácter, usando `let nombre params = cuerpo`. Es funcional, como seleccionar la inicial de un nombre.",
        "Inicia un condicional `if` con `str = \"\"`, verificando si la cadena está vacía, una expresión pura para el caso base.",
        "Si la cadena está vacía, retorna `None`, usando el tipo `option` para indicar ausencia, como no hay inicial si no hay nombre.",
        "Introduce la rama `else`, necesaria en OCaml, para manejar cadenas no vacías.",
        "Retorna `Some (String.get str 0)`, envolviendo el primer carácter en `Some`, como confirmar que hay una inicial disponible.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `first_char` con \"gato\", dando `Some 'g'`, demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para obtener el primer carácter, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml maneja vacía con `option`.",
        "Similitudes: Ambas acceden al primer carácter con pureza. Diferencias: Racket usa `string-ref` prefija, OCaml usa `String.get` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket no maneja vacío, OCaml usa `if` para vacía, aumentando líneas.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"gato\", dando 'g'. Diferencias: Racket retorna #\\g, OCaml Some 'g'."
      ]
    },
    "ejercicio-4": {
      "title": "Convertir cadena a mayúsculas",
      "racket": {
        "lines": [
          "(define (to-upper str)",
          "  (string-upcase str)",
          ")",
          "(to-upper \"welcome\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let to_upper str =",
          "  String.uppercase_ascii str",
          "in",
          "to_upper \"welcome\""
        ]
      },
      "explanations_racket": [
        "Define una función `to-upper` para convertir una cadena a mayúsculas. La sintaxis `(define (nombre params) cuerpo)` es funcional, como transformar un cartel a letras grandes.",
        "Usa `string-upcase` para retornar la cadena en mayúsculas, en notación prefija. La expresión es pura, como gritar un mensaje sin cambiar el original.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `to-upper` con \"welcome\", retornando \"WELCOME\", mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `to_upper` para convertir a mayúsculas, usando `let nombre params = cuerpo`. Es funcional, como hacer un letrero en letras grandes.",
        "Usa `String.uppercase_ascii` para retornar la cadena en mayúsculas, en notación infija. La expresión es pura, específica para ASCII.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `to_upper` con \"welcome\", retornando \"WELCOME\", demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para convertir cadenas a mayúsculas, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función primitiva para mayúsculas, manteniendo pureza. Diferencias: Racket usa `string-upcase` prefija, OCaml usa `String.uppercase_ascii` infija, más modular.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"welcome\", dando \"WELCOME\". Diferencias: Racket usa `(to-upper \"welcome\")`, OCaml usa `to_upper \"welcome\"`."
      ]
    },
    "ejercicio-5": {
      "title": "Verificar si una cadena está vacía",
      "racket": {
        "lines": [
          "(define (empty-string? str)",
          "  (string=? str \"\")",
          ")",
          "(empty-string? \"\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let empty_string str =",
          "  str = \"\"",
          "in",
          "empty_string \"\""
        ]
      },
      "explanations_racket": [
        "Define una función `empty-string?` para verificar si una cadena `str` está vacía. La sintaxis `(define (nombre params) cuerpo)` es funcional, como comprobar si un formulario tiene texto.",
        "Usa `string=?` para comparar `str` con \"\", retornando #t si es vacía. La expresión es pura, como validar un campo vacío.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `empty-string?` con \"\", dando #t, mostrando la verificación."
      ],
      "explanations_ocaml": [
        "Define una función `empty_string` para verificar si una cadena está vacía, usando `let nombre params = cuerpo`. Es funcional, como validar un campo en un formulario.",
        "Compara `str` con \"\" usando `=`, retornando `true` si es vacía. La expresión es pura, como confirmar un texto vacío.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `empty_string` con \"\", dando `true`, demostrando la verificación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para verificar si una cadena está vacía, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas comparan con cadena vacía, con pureza. Diferencias: Racket usa `string=?` prefija, OCaml usa `=` infija, más concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"\", dando verdadero. Diferencias: Racket usa `(empty-string? \"\")`, OCaml usa `empty_string \"\"`."
      ]
    },
    "ejercicio-6": {
      "title": "Extraer subcadena",
      "racket": {
        "lines": [
          "(define (substring-from str start len)",
          "  (substring str start (+ start len))",
          ")",
          "(substring-from \"python\" 1 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let substring_from str start len =",
          "  String.sub str start len",
          "in",
          "substring_from \"python\" 1 3"
        ]
      },
      "explanations_racket": [
        "Define una función `substring-from` para extraer una subcadena desde `start` con longitud `len`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como cortar un trozo de una cuerda.",
        "Usa `substring` para retornar el segmento de `str` desde `start` hasta `start + len`. La expresión es pura, como extraer 'yth' de \"python\" sin alterar la cadena original.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `substring-from` con \"python\", 1, 3, dando \"yth\", mostrando la extracción."
      ],
      "explanations_ocaml": [
        "Define una función `substring_from` para extraer una subcadena, usando `let nombre params = cuerpo`. Es funcional, como recortar un fragmento de un texto.",
        "Usa `String.sub` para retornar el segmento de `str` desde `start` con `len`. La expresión es pura, como obtener 'yth' de \"python\" sin cambiar la cadena.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `substring_from` con \"python\", 1, 3, dando \"yth\", demostrando la función."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para extraer una subcadena, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan una función primitiva para subcadena, con pureza. Diferencias: Racket usa `substring` prefija con `(+ start len)`, OCaml usa `String.sub` infija, más modular y concisa.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con \"python\", 1, 3, dando \"yth\". Diferencias: Racket usa `(substring-from \"python\" 1 3)`, OCaml usa `substring_from \"python\" 1 3`."
      ]
    },
    "ejercicio-7": {
      "title": "Contar vocales en una cadena",
      "racket": {
        "lines": [
          "(define (count-vowels str)",
          "  (length",
          "    (filter (lambda (c)",
          "              (member c '(#\\a #\\e #\\i #\\o #\\u)))",
          "            (string->list str)))",
          ")",
          "(count-vowels \"hello\")"
        ]
      },
      "ocaml": {
        "lines": [
          "let count_vowels str =",
          "  String.fold_left",
          "    (fun acc c ->",
          "       if List.mem c ['a'; 'e'; 'i'; 'o'; 'u'] then",
          "         acc + 1",
          "       else",
          "         acc",
          "    ) 0 str",
          "in",
          "count_vowels \"hello\""
        ]
      },
      "explanations_racket": [
        "Define una función `count-vowels` para contar vocales en una cadena `str`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un juego que cuenta vocales para puntuar palabras.",
        "Usa `length` para contar elementos en la lista filtrada, una expresión pura para obtener el total de vocales.",
        "Usa `filter` con `lambda` para seleccionar caracteres vocales. `lambda` es una función anónima, como un juez que decide si una letra es vocal.",
        "Verifica si `c` está en la lista de vocales con `member`, en notación prefija. Es pura, como identificar vocales en \"hello\".",
        "Convierte `str` a lista de caracteres con `string->list`, preparando la cadena para filtrado, como descomponer una palabra en letras.",
        "Cierra los bloques de `filter` y `length`, necesario para la sintaxis de Racket.",
        "Llama a `count-vowels` con \"hello\", contando 2 vocales (e, o), mostrando el procesamiento."
      ],
      "explanations_ocaml": [
        "Define una función `count_vowels` para contar vocales en una cadena, usando `let nombre params = cuerpo`. Es funcional, como un juego que puntúa palabras por vocales.",
        "Usa `String.fold_left` para acumular un conteo, reduciendo la cadena a un número. `fold_left` es una función de alto orden pura, como un contador que suma por cada vocal.",
        "Usa `fun` para definir una función anónima que toma acumulador `acc` y carácter `c`. `fun` es como una regla para cada letra.",
        "Inicia un condicional `if` para verificar si `c` es vocal usando `List.mem`, en notación infija, una expresión pura.",
        "Si `c` es vocal, suma 1 a `acc`, incrementando el conteo, como puntuar una letra vocal.",
        "Introduce `else` para caracteres no vocales, retornando `acc` sin cambio, necesaria en OCaml.",
        "Retorna `acc` si no es vocal, completando la función anónima.",
        "Inicializa el acumulador en 0 y aplica a `str`, reduciendo la cadena.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `count_vowels` con \"hello\", contando 2 vocales (e, o), demostrando el procesamiento."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para contar vocales, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`. OCaml usa `String.fold_left`, Racket usa `filter` + `length`.",
        "Similitudes: Ambas usan alto orden para procesar la cadena, con pureza. Diferencias: Racket usa `length` para contar filtrados, OCaml usa `fold_left` para acumular, más eficiente para conteo.",
        "Similitudes: Ambas usan función anónima para verificar vocales. Diferencias: Racket usa `lambda` prefija, OCaml usa `fun` infija con ->.",
        "Similitudes: Ambas verifican si el carácter es vocal. Diferencias: Racket usa `member` prefija, OCaml usa `List.mem` infija, más modular.",
        "Similitudes: Ambas usan listas de vocales. Diferencias: Racket usa caracteres `#\\a`, OCaml usa `'a'`, con `List.mem`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra bloques, OCaml cierra `else`.",
        "Similitudes: Ambas convierten cadena a procesable. Diferencias: Racket usa `string->list` prefija, OCaml usa `fold_left` directo sobre cadena.",
        "Similitudes: Ambas llaman la función con \"hello\", dando 2. Diferencias: Racket usa `(count-vowels \"hello\")`, OCaml usa `count_vowels \"hello\"`."
      ]
    }
  },
  "composicion-de-funciones": {
    "ejercicio-1": {
      "title": "Componer suma y cuadrado",
      "racket": {
        "lines": [
          "(define (compose-square-plus-one x)",
          "  ((compose (lambda (x) (* x x))",
          "            (lambda (x) (+ x 1)))",
          "   x",
          "  )",
          ")",
          "(compose-square-plus-one 5)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_square_plus_one x =",
          "  (fun x -> x * x)",
          "  ((fun x -> x + 1) x)",
          "in",
          "compose_square_plus_one 5"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-square-plus-one` que toma un número `x` y aplica composición. La sintaxis `(define (nombre params) cuerpo)` es funcional, como procesar una edad sumando 1 y elevando al cuadrado para un análisis demográfico.",
        "Usa `compose` para combinar `(lambda (x) (* x x))` (elevar al cuadrado) con `(lambda (x) (+ x 1))` (sumar 1). `compose` aplica la segunda función primero, luego la primera, en notación prefija, pura y sin efectos secundarios.",
        "Completa la composición, especificando que ambas funciones se encadenan, como calcular (x+1)^2 en un solo paso.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-square-plus-one` con `5`, evaluando (5+1)^2 = 6^2 = 36, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_square_plus_one` para combinar suma y cuadrado, usando `let nombre params = cuerpo`. Es funcional, como procesar una edad para un demógrafo.",
        "Define `(fun x -> x * x)` para elevar al cuadrado, aplicada al resultado de la función interna. La expresión es pura, como calcular el cuadrado en un pipeline.",
        "Aplica `(fun x -> x + 1)` a `x` primero, sumando 1, luego pasa el resultado al cuadrado, en notación infija, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `compose_square_plus_one` con `5`, evaluando (5+1)^2 = 36, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer suma y cuadrado, usando abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con composición manual.",
        "Similitudes: Ambas aplican el cuadrado después de sumar 1, con pureza. Diferencias: Racket usa `(lambda (x) (* x x))` prefija con `compose`, OCaml usa `(fun x -> x * x)` infija, aplicada directamente.",
        "Similitudes: Ambas encadenan funciones para transformar `x`. Diferencias: Racket usa `compose` explícitamente, OCaml anida funciones manualmente, reflejando su enfoque más explícito.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada para `x`, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `5`, dando `36`. Diferencias: Racket usa `(compose-square-plus-one 5)`, OCaml usa `compose_square_plus_one 5`."
      ]
    },
    "ejercicio-2": {
      "title": "Componer resta y duplicación",
      "racket": {
        "lines": [
          "(define (compose-double-minus-three x)",
          "  ((compose (lambda (x) (* x 2))",
          "            (lambda (x) (- x 3)))",
          "   x",
          "  )",
          ")",
          "(compose-double-minus-three 10)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_double_minus_three x =",
          "  (fun x -> x * 2)",
          "  ((fun x -> x - 3) x)",
          "in",
          "compose_double_minus_three 10"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-double-minus-three` que toma un número `x` y aplica composición. La sintaxis `(define (nombre params) cuerpo)` es funcional, como ajustar un salario restando 3 y duplicando.",
        "Usa `compose` para combinar `(lambda (x) (* x 2))` (duplicar) con `(lambda (x) (- x 3))` (restar 3). `compose` aplica la resta primero, luego duplica, en notación prefija, pura.",
        "Completa la composición, encadenando ambas funciones, como calcular (x-3)*2.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-double-minus-three` con `10`, evaluando (10-3)*2 = 7*2 = 14, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_double_minus_three` para combinar resta y duplicación, usando `let nombre params = cuerpo`. Es funcional, como ajustar un salario en un sistema.",
        "Define `(fun x -> x * 2)` para duplicar, aplicada al resultado de la resta. La expresión es pura, como un cálculo en un pipeline.",
        "Aplica `(fun x -> x - 3)` a `x` primero, restando 3, luego pasa el resultado a duplicar, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_double_minus_three` con `10`, evaluando (10-3)*2 = 14, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer resta y duplicación, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con composición manual.",
        "Similitudes: Ambas aplican duplicar después de restar 3, con pureza. Diferencias: Racket usa `(lambda (x) (* x 2))` prefija, OCaml usa `(fun x -> x * 2)` infija.",
        "Similitudes: Ambas encadenan funciones. Diferencias: Racket usa `compose`, OCaml anida funciones manualmente.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `10`, dando `14`. Diferencias: Racket usa `(compose-double-minus-three 10)`, OCaml usa `compose_double_minus_three 10`."
      ]
    },
    "ejercicio-3": {
      "title": "Composición múltiple: duplicar, sumar 1, elevar al cuadrado",
      "racket": {
        "lines": [
          "(define (compose-three x)",
          "  ((compose (lambda (x) (* x x))",
          "            (compose (lambda (x) (+ x 1))",
          "                     (lambda (x) (* x 2))))",
          "   x",
          "  )",
          ")",
          "(compose-three 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_three x =",
          "  (fun x -> x * x)",
          "  ((fun x -> x + 1)",
          "   ((fun x -> x * 2) x))",
          "in",
          "compose_three 3"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-three` que toma un número `x` y aplica tres transformaciones. La sintaxis `(define (nombre params) cuerpo)` es funcional, como procesar un dato científico.",
        "Usa `compose` para combinar `(lambda (x) (* x x))` (elevar al cuadrado) con una composición interna. Es pura, como un pipeline de cálculos.",
        "Compone `(lambda (x) (+ x 1))` (sumar 1) con `(lambda (x) (* x 2))` (duplicar), aplicando primero duplicar, luego sumar 1, y finalmente elevar al cuadrado.",
        "Completa la composición anidada, calculando ((x*2)+1)^2.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-three` con `3`, evaluando ((3*2)+1)^2 = 7^2 = 49, mostrando la composición múltiple."
      ],
      "explanations_ocaml": [
        "Define una función `compose_three` para combinar tres transformaciones, usando `let nombre params = cuerpo`. Es funcional, como procesar un dato en un experimento.",
        "Define `(fun x -> x * x)` para elevar al cuadrado, aplicada al resultado de las funciones internas.",
        "Aplica `(fun x -> x + 1)` al resultado de duplicar, sumando 1 en el pipeline.",
        "Aplica `(fun x -> x * 2)` a `x` primero, duplicando, luego pasa por las otras funciones, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_three` con `3`, evaluando ((3*2)+1)^2 = 49, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer tres transformaciones, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas aplican el cuadrado al final, con pureza. Diferencias: Racket usa `(lambda (x) (* x x))` prefija, OCaml usa `(fun x -> x * x)` infija.",
        "Similitudes: Ambas suman 1 después de duplicar. Diferencias: Racket usa `compose` anidado, OCaml anida funciones manualmente.",
        "Similitudes: Ambas duplican primero. Diferencias: Racket integra en `compose`, OCaml usa anidamiento explícito.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `3`, dando `49`. Diferencias: Racket usa `(compose-three 3)`, OCaml usa `compose_three 3`."
      ]
    },
    "ejercicio-4": {
      "title": "Componer suma y valor absoluto",
      "racket": {
        "lines": [
          "(define (compose-abs-plus-five x)",
          "  ((compose (lambda (x)",
          "              (if (< x 0)",
          "                  (- x)",
          "                  x))",
          "            (lambda (x) (+ x 5)))",
          "   x",
          "  )",
          ")",
          "(compose-abs-plus-five -3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_abs_plus_five x =",
          "  (fun x ->",
          "     if x < 0 then",
          "       -x",
          "     else",
          "       x)",
          "  ((fun x -> x + 5) x)",
          "in",
          "compose_abs_plus_five (-3)"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-abs-plus-five` que combina suma y valor absoluto. La sintaxis `(define (nombre params) cuerpo)` es funcional, como corregir un error sumando 5 y tomando el valor absoluto.",
        "Usa `compose` para combinar una función anónima que calcula el valor absoluto con `(lambda (x) (+ x 5))`. Es pura, como un ajuste en un pipeline.",
        "Inicia un condicional `if` con `(< x 0)` para verificar si el valor es negativo.",
        "Si es negativo, retorna `(- x)`, como corregir un valor negativo.",
        "Si no es negativo, retorna `x`, manteniendo el valor original.",
        "Completa la función de valor absoluto y combina con sumar 5, aplicando suma primero.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-abs-plus-five` con `-3`, evaluando |(-3+5)| = |2| = 2, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_abs_plus_five` para combinar suma y valor absoluto, usando `let nombre params = cuerpo`. Es funcional, como corregir un error en un cálculo.",
        "Define `(fun x -> ...)` para calcular el valor absoluto, aplicada al resultado de sumar 5.",
        "Inicia un condicional `if` con `x < 0` para verificar si el valor es negativo.",
        "Si es negativo, retorna `-x`, como ajustar un valor negativo.",
        "Introduce `else` para el caso no negativo, requerido en OCaml.",
        "Retorna `x` si no es negativo, manteniendo el valor.",
        "Aplica `(fun x -> x + 5)` a `x` primero, sumando 5, luego pasa al valor absoluto.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_abs_plus_five` con `-3`, evaluando |(-3+5)| = 2, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer suma y valor absoluto, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas calculan el valor absoluto después de sumar 5, con pureza. Diferencias: Racket usa `(lambda (x) ...)` prefija, OCaml usa `(fun x -> ...)` infija.",
        "Similitudes: Ambas verifican si el valor es negativo. Diferencias: Racket usa `(< x 0)` prefija, OCaml usa `x < 0` infija.",
        "Similitudes: Ambas retornan el opuesto para negativos. Diferencias: Racket usa `(- x)`, OCaml usa `-x`.",
        "Similitudes: Ambas retornan el valor original para no negativos. Diferencias: OCaml requiere `else` explícito, Racket lo integra en `if`.",
        "Similitudes: Ambas completan el valor absoluto. Diferencias: Racket usa paréntesis, OCaml usa `)`.",
        "Similitudes: Ambas suman 5 primero. Diferencias: Racket usa `compose`, OCaml anida manualmente.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `-3`, dando `2`. Diferencias: Racket usa `(compose-abs-plus-five -3)`, OCaml usa `compose_abs_plus_five (-3)`."
      ]
    },
    "ejercicio-5": {
      "title": "Componer resta y triplicación",
      "racket": {
        "lines": [
          "(define (compose-triple-minus-one x)",
          "  ((compose (lambda (x) (* x 3))",
          "            (lambda (x) (- x 1)))",
          "   x",
          "  )",
          ")",
          "(compose-triple-minus-one 4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_triple_minus_one x =",
          "  (fun x -> x * 3)",
          "  ((fun x -> x - 1) x)",
          "in",
          "compose_triple_minus_one 4"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-triple-minus-one` que combina resta y triplicación. La sintaxis `(define (nombre params) cuerpo)` es funcional, como calcular un bono restando 1 y triplicando.",
        "Usa `compose` para combinar `(lambda (x) (* x 3))` (triplicar) con `(lambda (x) (- x 1))` (restar 1). Aplica la resta primero, luego triplica, en notación prefija, pura.",
        "Completa la composición, calculando (x-1)*3.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-triple-minus-one` con `4`, evaluando (4-1)*3 = 3*3 = 9, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_triple_minus_one` para combinar resta y triplicación, usando `let nombre params = cuerpo`. Es funcional, como ajustar un bono en un sistema.",
        "Define `(fun x -> x * 3)` para triplicar, aplicada al resultado de restar 1.",
        "Aplica `(fun x -> x - 1)` a `x` primero, restando 1, luego pasa a triplicar, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_triple_minus_one` con `4`, evaluando (4-1)*3 = 9, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer resta y triplicación, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas triplican después de restar 1, con pureza. Diferencias: Racket usa `(lambda (x) (* x 3))` prefija, OCaml usa `(fun x -> x * 3)` infija.",
        "Similitudes: Ambas restan 1 primero. Diferencias: Racket usa `compose`, OCaml anida manualmente.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `4`, dando `9`. Diferencias: Racket usa `(compose-triple-minus-one 4)`, OCaml usa `compose_triple_minus_one 4`."
      ]
    },
    "ejercicio-6": {
      "title": "Componer cuadrado y paridad",
      "racket": {
        "lines": [
          "(define (compose-square-even x)",
          "  ((compose (lambda (x) (= (remainder x 2) 0))",
          "            (lambda (x) (* x x)))",
          "   x",
          "  )",
          ")",
          "(compose-square-even 3)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_square_even x =",
          "  (fun x -> x mod 2 = 0)",
          "  ((fun x -> x * x) x)",
          "in",
          "compose_square_even 3"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-square-even` que verifica si el cuadrado de un número es par. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un matemático verificando propiedades.",
        "Usa `compose` para combinar `(lambda (x) (= (remainder x 2) 0))` (verificar paridad) con `(lambda (x) (* x x))` (elevar al cuadrado). Aplica el cuadrado primero, luego verifica paridad, en notación prefija, pura.",
        "Completa la composición, calculando si x^2 es par.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-square-even` con `3`, evaluando 3^2 = 9, que no es par, dando `#f`, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_square_even` para verificar si el cuadrado es par, usando `let nombre params = cuerpo`. Es funcional, como analizar propiedades matemáticas.",
        "Define `(fun x -> x mod 2 = 0)` para verificar paridad, aplicada al resultado del cuadrado.",
        "Aplica `(fun x -> x * x)` a `x` primero, elevando al cuadrado, luego pasa a verificar paridad, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_square_even` con `3`, evaluando 3^2 = 9, que no es par, dando `false`, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer cuadrado y paridad, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas verifican paridad después de elevar al cuadrado, con pureza. Diferencias: Racket usa `(lambda (x) (= (remainder x 2) 0))` prefija, OCaml usa `(fun x -> x mod 2 = 0)` infija.",
        "Similitudes: Ambas elevan al cuadrado primero. Diferencias: Racket usa `compose`, OCaml anida manualmente.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `3`, dando `#f`/`false`. Diferencias: Racket usa `(compose-square-even 3)`, OCaml usa `compose_square_even 3`."
      ]
    },
    "ejercicio-7": {
      "title": "Componer valor absoluto y duplicación",
      "racket": {
        "lines": [
          "(define (compose-double-abs x)",
          "  ((compose (lambda (x) (* x 2))",
          "            (lambda (x)",
          "              (if (< x 0)",
          "                  (- x)",
          "                  x)))",
          "   x",
          "  )",
          ")",
          "(compose-double-abs -4)"
        ]
      },
      "ocaml": {
        "lines": [
          "let compose_double_abs x =",
          "  (fun x -> x * 2)",
          "  ((fun x ->",
          "      if x < 0 then",
          "        -x",
          "      else",
          "        x) x)",
          "in",
          "compose_double_abs (-4)"
        ]
      },
      "explanations_racket": [
        "Define una función `compose-double-abs` que combina valor absoluto y duplicación. La sintaxis `(define (nombre params) cuerpo)` es funcional, como corregir un error y duplicarlo.",
        "Usa `compose` para combinar `(lambda (x) (* x 2))` (duplicar) con una función de valor absoluto. Aplica el valor absoluto primero, luego duplica, en notación prefija, pura.",
        "Define la función anónima para valor absoluto, iniciando con `(lambda (x) ...)`",
        "Inicia un condicional `if` con `(< x 0)` para verificar si el valor es negativo.",
        "Si es negativo, retorna `(- x)`, como corregir un valor negativo.",
        "Si no es negativo, retorna `x`, manteniendo el valor original.",
        "Completa la composición, aplicando valor absoluto y luego duplicando.",
        "Aplica la función compuesta a `x`, el argumento de entrada.",
        "Cierra el bloque de la función compuesta, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `compose-double-abs` con `-4`, evaluando |-4|*2 = 4*2 = 8, mostrando la composición."
      ],
      "explanations_ocaml": [
        "Define una función `compose_double_abs` para combinar valor absoluto y duplicación, usando `let nombre params = cuerpo`. Es funcional, como ajustar un valor en un sistema.",
        "Define `(fun x -> x * 2)` para duplicar, aplicada al resultado del valor absoluto.",
        "Define `(fun x -> ...)` para calcular el valor absoluto, aplicada a `x`.",
        "Inicia un condicional `if` con `x < 0` para verificar si el valor es negativo.",
        "Si es negativo, retorna `-x`, como corregir un valor negativo.",
        "Introduce `else` para el caso no negativo, requerido en OCaml.",
        "Retorna `x` si no es negativo, manteniendo el valor.",
        "Aplica el valor absoluto a `x` primero, luego pasa a duplicar, simulando composición manual.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `compose_double_abs` con `-4`, evaluando |-4|*2 = 8, demostrando la composición."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para componer valor absoluto y duplicación, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)` con `compose`, OCaml usa `let nombre params = cuerpo` con anidamiento manual.",
        "Similitudes: Ambas duplican después del valor absoluto, con pureza. Diferencias: Racket usa `(lambda (x) (* x 2))` prefija, OCaml usa `(fun x -> x * 2)` infija.",
        "Similitudes: Ambas calculan el valor absoluto. Diferencias: Racket usa `(lambda (x) ...)` prefija, OCaml usa `(fun x -> ...)` infija.",
        "Similitudes: Ambas verifican si el valor es negativo. Diferencias: Racket usa `(< x 0)`, OCaml usa `x < 0`.",
        "Similitudes: Ambas retornan el opuesto para negativos. Diferencias: Racket usa `(- x)`, OCaml usa `-x`.",
        "Similitudes: Ambas retornan el valor original para no negativos. Diferencias: OCaml requiere `else`, Racket lo integra en `if`.",
        "Similitudes: Ambas completan el valor absoluto. Diferencias: Racket usa paréntesis, OCaml usa `)`.",
        "Similitudes: Ambas aplican la función compuesta a `x`. Diferencias: Racket usa una línea separada, OCaml integra en la composición.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `compose`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con `-4`, dando `8`. Diferencias: Racket usa `(compose-double-abs -4)`, OCaml usa `compose_double_abs (-4)`."
      ]
    }
  },
  "procesamiento-listas": {
    "ejercicio-1": {
      "title": "Sumar elementos de una lista recursivamente",
      "racket": {
        "lines": [
          "(define (sum-list lst)",
          "  (if (empty? lst)",
          "      0",
          "      (+ (first lst)",
          "         (sum-list (rest lst))))",
          "  )",
          ")",
          "(sum-list '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec sum_list lst =",
          "  if lst = [] then",
          "    0",
          "  else",
          "    List.hd lst + sum_list (List.tl lst)",
          "in",
          "sum_list [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-list` que suma los elementos de una lista recursivamente. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un comerciante sumando ventas diarias.",
        "Usa `if` para verificar si la lista está vacía con `(empty? lst)`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `0`, como el total de ventas cuando no hay transacciones.",
        "Si la lista no está vacía, suma el primer elemento `(first lst)` con el resultado de la recursión, en notación prefija.",
        "Llama recursivamente a `sum-list` con `(rest lst)`, procesando el resto de la lista, manteniendo la pureza.",
        "Cierra el bloque `if` y la función, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `sum-list` con `'(2 3 4)`, evaluando 2 + 3 + 4 = 9, mostrando la suma recursiva."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `sum_list` con `let rec` para sumar elementos de una lista, usando `let nombre params = cuerpo`. Es funcional, como sumar ventas en un registro.",
        "Usa `if` para verificar si la lista es vacía con `lst = []`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `0`, como un total nulo sin ventas.",
        "Introduce `else` para el caso no vacío, requerido en OCaml, para manejar la recursión.",
        "Suma el primer elemento (`List.hd lst`) con la recursión sobre el resto (`sum_list (List.tl lst)`), en notación infija, pura.",
        "Usa `in` para introducir la llamada, una convención estructural de OCaml.",
        "Llama a `sum_list` con `[2; 3; 4]`, evaluando 2 + 3 + 4 = 9, demostrando la suma recursiva."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para sumar listas, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo` con tipado estático implícito.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija.",
        "Similitudes: Ambas retornan `0` para el caso base, con pureza. Diferencias: Racket usa una línea directa, OCaml usa `then` explícito.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket usa paréntesis, OCaml requiere `else` explícito.",
        "Similitudes: Ambas suman el primer elemento con la recursión del resto, con pureza. Diferencias: Racket usa `(first lst)` y `(rest lst)` prefija, OCaml usa `List.hd lst` y `List.tl lst` con módulo `List`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `if`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `9`. Diferencias: Racket usa `'(2 3 4)`, OCaml usa `[2; 3; 4]` con punto y coma."
      ]
    },
    "ejercicio-2": {
      "title": "Triplicar elementos con map",
      "racket": {
        "lines": [
          "(define (triple-list lst)",
          "  (map (lambda (x) (* x 3))",
          "       lst",
          "  )",
          ")",
          "(triple-list '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let triple_list lst =",
          "  List.map (fun x -> x * 3) lst",
          "in",
          "triple_list [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función `triple-list` para multiplicar cada elemento de una lista por 3. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un chef triplicando cantidades de ingredientes.",
        "Usa `map` para aplicar `(lambda (x) (* x 3))` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura, como ajustar un inventario sin modificar el original.",
        "Pasa la lista `lst` a `map`, aplicando la transformación a todos los elementos.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `triple-list` con `'(1 2 3)`, retornando `(3 6 9)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `triple_list` para triplicar elementos, usando `let nombre params = cuerpo`. Es funcional, como ajustar cantidades en una receta.",
        "Usa `List.map` para aplicar `(fun x -> x * 3)` a cada elemento, retornando una nueva lista. `List.map` es una función de alto orden pura, como escalar un inventario.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `triple_list` con `[1; 2; 3]`, retornando `[3; 6; 9]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para triplicar elementos usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (* x 3))` prefija, OCaml usa `(fun x -> x * 3)` infija, con `List.map` explícito.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml integra en `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(3 6 9)`. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]`."
      ]
    },
    "ejercicio-3": {
      "title": "Filtrar números impares con filter",
      "racket": {
        "lines": [
          "(define (odd-numbers lst)",
          "  (filter (lambda (x) (= (remainder x 2) 1))",
          "          lst",
          "  )",
          ")",
          "(odd-numbers '(1 2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let odd_numbers lst =",
          "  List.filter (fun x -> x mod 2 = 1) lst",
          "in",
          "odd_numbers [1; 2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `odd-numbers` para filtrar números impares. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un sorteo seleccionando números impares.",
        "Usa `filter` para aplicar `(lambda (x) (= (remainder x 2) 1))`, verificando si un número es impar, retornando una nueva lista. `filter` es una función de alto orden pura, como elegir boletos específicos.",
        "Pasa la lista `lst` a `filter`, evaluando cada elemento.",
        "Cierra el bloque de `filter`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `odd-numbers` con `'(1 2 3 4)`, retornando `(1 3)`, mostrando el filtrado."
      ],
      "explanations_ocaml": [
        "Define una función `odd_numbers` para filtrar números impares, usando `let nombre params = cuerpo`. Es funcional, como seleccionar valores en un sorteo.",
        "Usa `List.filter` para aplicar `(fun x -> x mod 2 = 1)`, seleccionando impares. `List.filter` es una función de alto orden pura, como un tamiz para datos.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `odd_numbers` con `[1; 2; 3; 4]`, retornando `[1; 3]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar impares usando `filter`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `filter`/`List.filter` para seleccionar elementos puros. Diferencias: Racket usa `(lambda (x) (= (remainder x 2) 1))` prefija, OCaml usa `(fun x -> x mod 2 = 1)` infija, con `List.filter` explícito.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml integra en `List.filter`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `filter`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 4 elementos, dando `(1 3)`. Diferencias: Racket usa `'(1 2 3 4)`, OCaml usa `[1; 2; 3; 4]`."
      ]
    },
    "ejercicio-4": {
      "title": "Invertir lista recursivamente",
      "racket": {
        "lines": [
          "(define (reverse-list lst)",
          "  (if (empty? lst)",
          "      null",
          "      (append (reverse-list (rest lst))",
          "              (list (first lst))))",
          "  )",
          ")",
          "(reverse-list '(1 2 3))"
        ]
      },
      "ocaml": {
        "lines": [
          "let rec reverse_list lst =",
          "  if lst = [] then",
          "    []",
          "  else",
          "    reverse_list (List.tl lst) @ [List.hd lst]",
          "in",
          "reverse_list [1; 2; 3]"
        ]
      },
      "explanations_racket": [
        "Define una función `reverse-list` que invierte una lista recursivamente. La sintaxis `(define (nombre params) cuerpo)` es funcional, como priorizar tareas recientes en un sistema.",
        "Usa `if` para verificar si la lista está vacía con `(empty? lst)`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `null`, como una lista vacía de tareas.",
        "Si no está vacía, concatena la recursión del resto con el primer elemento. `(append ...)` combina listas, en notación prefija.",
        "Llama recursivamente a `reverse-list` con `(rest lst)`, invirtiendo el resto, y pone `(first lst)` al final usando `(list ...)`, manteniendo pureza.",
        "Cierra el bloque `if` y la función, necesario para Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `reverse-list` con `'(1 2 3)`, retornando `(3 2 1)`, mostrando la inversión recursiva."
      ],
      "explanations_ocaml": [
        "Define una función recursiva `reverse_list` con `let rec` para invertir una lista, usando `let nombre params = cuerpo`. Es funcional, como reordenar tareas en un sistema.",
        "Usa `if` para verificar si la lista es vacía con `lst = []`, una condición pura para el caso base.",
        "Si la lista está vacía, retorna `[]`, como una lista vacía de tareas.",
        "Introduce `else` para el caso no vacío, requerido en OCaml, para manejar la recursión.",
        "Concatena la recursión de `reverse_list (List.tl lst)` con `[List.hd lst]` usando `@`, poniendo el primer elemento al final, en notación infija, pura.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `reverse_list` con `[1; 2; 3]`, retornando `[3; 2; 1]`, demostrando la inversión."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función recursiva para invertir listas, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let rec nombre params = cuerpo`.",
        "Similitudes: Ambas verifican si la lista está vacía. Diferencias: Racket usa `(empty? lst)` prefija, OCaml usa `lst = []` infija.",
        "Similitudes: Ambas retornan una lista vacía para el caso base, con pureza. Diferencias: Racket usa `null`, OCaml usa `[]`.",
        "Similitudes: Ambas manejan el caso no vacío. Diferencias: Racket usa paréntesis, OCaml requiere `else` explícito.",
        "Similitudes: Ambas concatenan la recursión del resto con el primer elemento. Diferencias: Racket usa `(append ... (list (first lst)))` prefija, OCaml usa `@ [List.hd lst]` infija con módulo `List`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `if`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(3 2 1)`. Diferencias: Racket usa `'(1 2 3)`, OCaml usa `[1; 2; 3]`."
      ]
    },
    "ejercicio-5": {
      "title": "Sumar con foldl",
      "racket": {
        "lines": [
          "(define (sum-fold lst)",
          "  (foldl + 0 lst)",
          ")",
          "(sum-fold '(10 20 30))"
        ]
      },
      "ocaml": {
        "lines": [
          "let sum_fold lst =",
          "  List.fold_left (+) 0 lst",
          "in",
          "sum_fold [10; 20; 30]"
        ]
      },
      "explanations_racket": [
        "Define una función `sum-fold` para sumar elementos usando `foldl`. La sintaxis `(define (nombre params) cuerpo)` es funcional, como una tienda sumando ventas totales.",
        "Usa `foldl` para aplicar la función `+` con un acumulador inicial `0` a la lista `lst`, retornando la suma total. `foldl` es una función de alto orden pura, como un contador acumulando ventas.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `sum-fold` con `'(10 20 30)`, evaluando 10 + 20 + 30 = 60, mostrando la acumulación."
      ],
      "explanations_ocaml": [
        "Define una función `sum_fold` para sumar elementos con `List.fold_left`, usando `let nombre params = cuerpo`. Es funcional, como un sistema sumando ingresos.",
        "Usa `List.fold_left` para aplicar el operador `(+)`, con acumulador inicial `0`, a `lst`. Es una función de alto orden pura, como un registro acumulando valores.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `sum_fold` con `[10; 20; 30]`, evaluando 10 + 20 + 30 = 60, demostrando la acumulación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para sumar con fold, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `foldl`/`List.fold_left` para acumular con `+` y `0`, con pureza. Diferencias: Racket usa `+` prefija, OCaml usa `(+)`, con `List.fold_left` explícito.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `60`. Diferencias: Racket usa `'(10 20 30)`, OCaml usa `[10; 20; 30]`."
      ]
    },
    "ejercicio-6": {
      "title": "Filtrar valores true con filter",
      "racket": {
        "lines": [
          "(define (true-values lst)",
          "  (filter (lambda (x) x) lst)",
          ")",
          "(true-values '(#t #f #t))"
        ]
      },
      "ocaml": {
        "lines": [
          "let true_values lst =",
          "  List.filter (fun x -> x) lst",
          "in",
          "true_values [true; false; true]"
        ]
      },
      "explanations_racket": [
        "Define una función `true-values` para filtrar valores `#t` de una lista. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un organizador seleccionando tareas completadas.",
        "Usa `filter` para aplicar `(lambda (x) x)`, que selecciona solo los valores `#t`, retornando una nueva lista. `filter` es una función de alto orden pura, como elegir tareas marcadas como hechas.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `true-values` con `'(#t #f #t)`, retornando `(#t #t)`, mostrando el filtrado."
      ],
      "explanations_ocaml": [
        "Define una función `true_values` para filtrar valores `true`, usando `let nombre params = cuerpo`. Es funcional, como seleccionar tareas completadas en un sistema.",
        "Usa `List.filter` para aplicar `(fun x -> x)`, seleccionando solo `true`. `List.filter` es una función de alto orden pura, como un filtro de tareas finalizadas.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `true_values` con `[true; false; true]`, retornando `[true; true]`, demostrando el filtrado."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para filtrar valores `true`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `filter`/`List.filter` para seleccionar `true`, con pureza. Diferencias: Racket usa `(lambda (x) x)` prefija, OCaml usa `(fun x -> x)` infija, con `List.filter` explícito.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 booleanos, dando `(true true)`. Diferencias: Racket usa `'(#t #f #t)`, OCaml usa `[true; false; true]`."
      ]
    },
    "ejercicio-7": {
      "title": "Multiplicar por 10 con map",
      "racket": {
        "lines": [
          "(define (times-ten lst)",
          "  (map (lambda (x) (* x 10))",
          "       lst",
          "  )",
          ")",
          "(times-ten '(2 3 4))"
        ]
      },
      "ocaml": {
        "lines": [
          "let times_ten lst =",
          "  List.map (fun x -> x * 10) lst",
          "in",
          "times_ten [2; 3; 4]"
        ]
      },
      "explanations_racket": [
        "Define una función `times-ten` para multiplicar cada elemento por 10. La sintaxis `(define (nombre params) cuerpo)` es funcional, como un analista ajustando precios en una tienda.",
        "Usa `map` para aplicar `(lambda (x) (* x 10))` a cada elemento, retornando una nueva lista. `map` es una función de alto orden pura, como escalar costos sin modificar originales.",
        "Pasa la lista `lst` a `map`, aplicando la transformación a todos los elementos.",
        "Cierra el bloque de `map`, necesario para la sintaxis de Racket.",
        "Cierra la definición de la función, una convención estructural de Racket.",
        "Llama a `times-ten` con `'(2 3 4)`, retornando `(20 30 40)`, mostrando la transformación."
      ],
      "explanations_ocaml": [
        "Define una función `times_ten` para multiplicar por 10, usando `let nombre params = cuerpo`. Es funcional, como ajustar precios en un sistema.",
        "Usa `List.map` para aplicar `(fun x -> x * 10)` a cada elemento. `List.map` es una función de alto orden pura, como escalar valores en un catálogo.",
        "Usa `in` para introducir la llamada, una convención de OCaml.",
        "Llama a `times_ten` con `[2; 3; 4]`, retornando `[20; 30; 40]`, demostrando la transformación."
      ],
      "comparisons": [
        "Similitudes: Ambas definen una función para multiplicar por 10 usando `map`, con abstracción funcional. Diferencias: Racket usa `(define (nombre params) cuerpo)`, OCaml usa `let nombre params = cuerpo`.",
        "Similitudes: Ambas usan `map`/`List.map` para aplicar una transformación pura. Diferencias: Racket usa `(lambda (x) (* x 10))` prefija, OCaml usa `(fun x -> x * 10)` infija, con `List.map` explícito.",
        "Similitudes: Ambas pasan la lista como argumento, con pureza. Diferencias: Racket usa `lst` en una línea separada, OCaml integra en `List.map`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra el bloque `map`, OCaml usa `in`.",
        "Similitudes: Ambas son estructurales. Diferencias: Racket cierra con `)`, OCaml usa `in`.",
        "Similitudes: Ambas llaman la función con una lista de 3 elementos, dando `(20 30 40)`. Diferencias: Racket usa `'(2 3 4)`, OCaml usa `[2; 3; 4]`."
      ]
    }
  }
}
