{
  "paradigma-funcional": {
    "ejercicio-1": {
      "description": "¡Bienvenido al paradigma funcional! Nos enfocamos en expresiones puras que siempre dan el mismo resultado. Imagina que Ana planifica varios viajes, sumando distancias recorridas en diferentes tramos, como 5 km + 3 km, 2 km + 7 km, o 10 km + 4 km. Usa la operación primitiva de suma para calcular las distancias totales, mostrando cómo el funcional resuelve problemas cotidianos, como combinar tramos de caminatas, con cálculos predecibles y sin modificar estado.",
      "racket": {
        "code": "(+ 5 3)\n(+ 2 7)\n(+ 10 4)\n(+ 1 6)\n(+ 8 2)"
      },
      "ocaml": {
        "code": "5 + 3\n2 + 7\n10 + 4\n1 + 6\n8 + 2"
      },
      "answer": "8\n9\n14\n7\n10"
    },
    "ejercicio-2": {
      "description": "En programación funcional, las expresiones son clave. Carlos organiza eventos y verifica si cantidades de sillas, como 7, 4, 9, 6 o 3, son impares para decidir si añadir una extra. Usa el módulo (resto de dividir por 2) para determinar paridad, obteniendo 1 para impares y 0 para pares. Esta operación primitiva muestra cómo evaluar condiciones simples, como organizar asientos, de forma pura y determinista.",
      "racket": {
        "code": "(remainder 7 2)\n(remainder 4 2)\n(remainder 9 2)\n(remainder 6 2)\n(remainder 3 2)"
      },
      "ocaml": {
        "code": "7 mod 2\n4 mod 2\n9 mod 2\n6 mod 2\n3 mod 2"
      },
      "answer": "1\n0\n1\n0\n1"
    },
    "ejercicio-3": {
      "description": "Las expresiones funcionales son deterministas. Sofía gestiona una tienda y compara si el inventario total, después de sumar nuevas unidades, es mayor que el de la competencia, como 12 + 4 > 15, 5 + 5 > 12, o 15 + 3 > 10. Usa la comparación mayor que en expresiones compuestas, que retorna true si el resultado es mayor, o false si no. Esta operación primitiva muestra cómo el funcional toma decisiones puras en escenarios más elaborados, como gestionar inventarios con adiciones, sin alterar nada.",
      "racket": {
        "code": "(> (+ 12 4) 15)\n(> (+ 5 5) 12)\n(> (+ 15 3) 10)\n(> (+ 3 3) 6)\n(> (+ 9 6) 8)"
      },
      "ocaml": {
        "code": "12 + 4 > 15\n5 + 5 > 12\n15 + 3 > 10\n3 + 3 > 6\n9 + 6 > 8"
      },
      "answer": "#t\n#f\n#t\n#f\n#t"
    },
    "ejercicio-4": {
      "description": "El funcional resuelve problemas prácticos. Luis reparte ganancias netas, calculadas restando costos de las brutas, entre equipos, como (20 - 10) / 2, (15 - 3) / 4, o (18 - 10) / 2. Usa la operación primitiva de división en expresiones con sumas y restas para calcular cuánto recibe cada uno, obteniendo resultados como 5, 3, o 4. Esto muestra cómo el funcional realiza cálculos directos para distribuciones equitativas en escenarios más complejos, manteniendo todo inmutable y predecible.",
      "racket": {
        "code": "(/ (- 20 10) 2)\n(/ (- 15 3) 4)\n(/ (- 18 10) 2)\n(/ (- 12 3) 3)\n(/ (- 24 4) 5)"
      },
      "ocaml": {
        "code": "(20 - 10) / 2\n(15 - 3) / 4\n(18 - 10) / 2\n(12 - 3) / 3\n(24 - 4) / 5"
      },
      "answer": "5\n3\n4\n3\n4"
    },
    "ejercicio-5": {
      "description": "Las comparaciones son esenciales en el funcional. Marta verifica si el resultado de cálculos más elaborados, involucrando sumas, restas y multiplicaciones, es igual a un valor esperado, como (5 + 3 - 1) = 7, (2 * 3) = 7, o ((4 * 2) + 1) = 9. Usa la operación de igualdad en expresiones compuestas, que retorna true si son iguales, o false si no. Esta expresión pura muestra cómo validar equivalencias en escenarios complejos, como en inventarios con operaciones múltiples, con cálculos que no alteran el estado.",
      "racket": {
        "code": "(= (- (+ 5 3) 1) 7)\n(= (* 2 3) 7)\n(= (+ (* 4 2) 1) 9)\n(= (- 10 3) 6)\n(= (* 5 1) 5)"
      },
      "ocaml": {
        "code": "(5 + 3 - 1) = 7\n(2 * 3) = 7\n((4 * 2) + 1) = 9\n(10 - 3) = 6\n(5 * 1) = 5"
      },
      "answer": "#t\n#f\n#t\n#f\n#t"
    },
    "ejercicio-6": {
      "description": "Exploramos funciones matemáticas. Un excursionista mide desviaciones complejas respecto a un punto base, involucrando sumas, restas y multiplicaciones, como abs(5 + 3 - 10), abs(-2 * 3), o abs(4 - (1 + 6)), y necesita distancias absolutas. Usa el valor absoluto en expresiones anidadas para obtener valores positivos, como 2, 6, o 3. Esta operación primitiva enseña cómo el funcional maneja números negativos en mediciones más elaboradas, como en mapas con cálculos compuestos, con resultados predecibles y sin efectos secundarios.",
      "racket": {
        "code": "(abs (- (+ 5 3) 10))\n(abs (* -2 3))\n(abs (- 4 (+ 1 6)))\n(abs (abs (- (* 3 4) 15)))\n(abs (- (abs (- 12 18)) 2))"
      },
      "ocaml": {
        "code": "abs (5 + 3 - 10)\nabs (-2 * 3)\nabs (4 - (1 + 6))\nabs (abs ((3 * 4) - 15))\nabs ((abs (12 - 18)) - 2)"
      },
      "answer": "2\n6\n3\n3\n4"
    },
    "ejercicio-7": {
      "description": "El funcional aborda cálculos avanzados. Un ingeniero diseña estructuras y calcula la hipotenusa en triángulos rectángulos con lados como 3 y 4, 5 y 12, o 8 y 6 metros, usando expresiones aún más complejas con raíces cuadradas anidadas, sumas y multiplicaciones. Usa la raíz cuadrada en composiciones anidadas con operaciones intermedias para obtener valores como 5, 13 o 10. Esta operación primitiva muestra cómo resolver problemas reales y desafiantes, como diseño estructural con teorema de Pitágoras, empleando expresiones puras, precisas y deterministas.",
      "racket": {
        "code": "(sqrt (+ (* 3 3) (* 4 4)))\n(sqrt (+ (sqrt (+ (* 5 5) (* 12 12))) 1))\n(sqrt (+ (* (sqrt 8) (sqrt 8)) (* 6 6)))\n(sqrt (+ (* 7 7) (sqrt (+ (* 24 24) 1))))\n(sqrt (sqrt (+ (* 20 20) (* 21 21))))"
      },
      "ocaml": {
        "code": "sqrt (3.0 *. 3.0 +. 4.0 *. 4.0)\nsqrt (sqrt (5.0 *. 5.0 +. 12.0 *. 12.0) +. 1.0)\nsqrt ((sqrt 8.0) *. (sqrt 8.0) +. 6.0 *. 6.0)\nsqrt (7.0 *. 7.0 +. sqrt (24.0 *. 24.0 +. 1.0))\nsqrt (sqrt (20.0 *. 20.0 +. 21.0 *. 21.0)))"
      },
      "answer": "5\n≈13.03\n10\n≈25.02\n≈29.00"
    }
  },
  "expresiones": {
    "ejercicio-1": {
      "description": "¡Bienvenidos al paradigma funcional! Las expresiones puras siempre producen el mismo resultado sin alterar estado. Clara verifica si varios paquetes tienen el mismo número de galletas, como 8 vs. 8, 5 vs. 6, o 7 vs. 7. Usa la operación primitiva de igualdad para obtener resultados booleanos, mostrando cómo validar equivalencias en inventarios con cálculos simples y deterministas.",
      "racket": {
        "code": "(= 8 8)\n(= 5 6)\n(= 7 7)\n(= 3 3)\n(= 9 10)"
      },
      "ocaml": {
        "code": "8 = 8\n5 = 6\n7 = 7\n3 = 3\n9 = 10"
      },
      "answer": "#t\n#f\n#t\n#t\n#f"
    },
    "ejercicio-2": {
      "description": "Las comparaciones son esenciales en el funcional. Jorge revisa si varios presupuestos, como 15, 8, 12, 10, o 20 dólares, superan diferentes límites, como 10, 9, 5, 10, o 15 dólares. Usa la operación mayor que para obtener resultados booleanos, mostrando cómo evaluar condiciones en planificación financiera con expresiones puras y predecibles.",
      "racket": {
        "code": "(> 15 10)\n(> 8 9)\n(> 12 5)\n(> 10 10)\n(> 20 15)"
      },
      "ocaml": {
        "code": "15 > 10\n8 > 9\n12 > 5\n10 > 10\n20 > 15"
      },
      "answer": "#t\n#f\n#t\n#f\n#t"
    },
    "ejercicio-3": {
      "description": "La suma resuelve problemas cotidianos. Lucía calcula distancias totales de caminatas combinando tramos, como 7 km + 5 km, 3 km + 4 km, o 6 km + 8 km. Usa la operación primitiva de suma para obtener las distancias, mostrando cómo el funcional realiza cálculos aritméticos simples para viajes, manteniendo resultados consistentes y sin efectos secundarios.",
      "racket": {
        "code": "(+ 7 5)\n(+ 3 4)\n(+ 6 8)\n(+ 2 9)\n(+ 10 3)"
      },
      "ocaml": {
        "code": "7 + 5\n3 + 4\n6 + 8\n2 + 9\n10 + 3"
      },
      "answer": "12\n7\n14\n11\n13"
    },
    "ejercicio-4": {
      "description": "La resta calcula sobrantes. Raúl distribuye caramelos, empezando con cantidades como 20, 15, 12, 8, o 10, y da 6, 4, 3, 2, o 5 respectivamente. Usa la operación primitiva de resta para determinar cuántos caramelos quedan, mostrando cómo el funcional maneja diferencias en distribución de recursos con pureza y determinismo.",
      "racket": {
        "code": "(- 20 6)\n(- 15 4)\n(- 12 3)\n(- 8 2)\n(- 10 5)"
      },
      "ocaml": {
        "code": "20 - 6\n15 - 4\n12 - 3\n8 - 2\n10 - 5"
      },
      "answer": "14\n11\n9\n6\n5"
    },
    "ejercicio-5": {
      "description": "El módulo verifica patrones. Ana organiza libros en grupos de diferentes tamaños, como 10 libros en grupos de 3, 8 en grupos de 2, o 7 en grupos de 4. Calcula el resto con el módulo para saber cuántos libros sobran, mostrando cómo el funcional evalúa restos en organización de objetos con resultados fijos y sin efectos secundarios.",
      "racket": {
        "code": "(remainder 10 3)\n(remainder 8 2)\n(remainder 7 4)\n(remainder 12 5)\n(remainder 9 3)"
      },
      "ocaml": {
        "code": "10 mod 3\n8 mod 2\n7 mod 4\n12 mod 5\n9 mod 3"
      },
      "answer": "1\n0\n3\n2\n0"
    },
    "ejercicio-6": {
      "description": "La división reparte recursos, pero ahora combinamos divisiones con raíces y redondeos para explorar cálculos más ricos. Un chef divide ingredientes en proporciones más precisas, usando divisiones puras y anidadas para representar exactitud y balance.",
      "racket": {
        "code": "(/ 12 3)\n(/ (sqrt 81) 3)\n(/ (round 15.6) 5)\n(/ 6 (sqrt 4))\n(/ (+ 9 3) 3)"
      },
      "ocaml": {
        "code": "12 / 3\nint_of_float ((sqrt 81.0) /. 3.0)\nint_of_float ((Float.round 15.6) /. 5.0)\nint_of_float (6.0 /. (sqrt 4.0))\nint_of_float ((9.0 +. 3.0) /. 3.0)"
      },
      "answer": "4\n3\n3\n3\n4"
    },
    "ejercicio-7": {
      "description": "Combinamos operaciones con trigonometría, potencias, raíces, y redondeos para modelar comparaciones estructurales complejas. Un arquitecto evalúa longitudes ajustadas mediante 'sqrt', 'tan', 'sin', 'round' y 'remainder', mostrando cómo el razonamiento funcional combina cálculos precisos y puros.",
      "racket": {
        "code": "(> (- (sqrt (+ (* 3 3) (* 4 4))) 2) 5)\n(> (- (round (sqrt (+ (* 4 4) (* 12 12)))) 1) 7)\n(> (- (expt 2 2) (remainder 3 2)) 1)\n(> (- (round (* (tan 1.5) 5)) 5) 10)\n(> (- (expt 6 2) (round (sin 2))) 15)"
      },
      "ocaml": {
        "code": "((sqrt (3.0 *. 3.0 +. 4.0 *. 4.0) -. 2.0) >. 5.0)\n((Float.round (sqrt (4.0 *. 4.0 +. 12.0 *. 12.0)) -. 1.0) >. 7.0)\n(((2.0 ** 2.0) -. float_of_int (3 mod 2)) >. 1.0)\n((Float.round (Float.tan 1.5 *. 5.0) -. 5.0) >. 10.0)\n((6.0 ** 2.0 -. Float.round (Float.sin 2.0)) >. 15.0)"
      },
      "answer": "#f\n#t\n#t\n#t\n#t"
    }
  },
  "funciones": {
    "ejercicio-1": {
      "description": "Un agricultor mide un terreno rectangular de 10 metros de largo por 7 metros de ancho para instalar un sistema de riego. Define una función que calcule el área multiplicando base por altura. Evalúa con 10 y 7. Este ejercicio introduce funciones básicas para cálculos geométricos simples, esenciales en planificación agrícola. La fórmula es base * altura. Paso a paso: 10 * 7 = 70 metros cuadrados, que representa el área a regar. El resultado esperado es 70, útil para estimar la cantidad de tuberías necesarias.",
      "racket": {
        "code": "(define (rectangle-area base height)\n  (* base height)\n)\n(rectangle-area 10 7)"
      },
      "ocaml": {
        "code": "let rectangle_area base height =\n  base * height\nin\nrectangle_area 10 7"
      },
      "answer": "70"
    },
    "ejercicio-2": {
      "description": "Un organizador de eventos calcula cuántas veces se repite un espectáculo de luces cada 5 segundos en un período de 25 segundos, ajustando el resultado con un margen de 2 segundos por retrasos técnicos. Define una función que divida el tiempo total entre el intervalo y reste el margen. Evalúa con 25 y 5. Este ejercicio introduce división y resta, aumentando la complejidad al combinar dos operaciones. Paso a paso: 25 / 5 = 5 repeticiones, menos 2 segundos de margen da 5 - 2 = 3 repeticiones ajustadas. El resultado esperado es 3, útil para planificar cronogramas.",
      "racket": {
        "code": "(define (adjusted-event-count total-time interval)\n  (let ((count (/ total-time interval))\n        (margin 2))\n    (- count margin))\n)\n(adjusted-event-count 25 5)"
      },
      "ocaml": {
        "code": "let adjusted_event_count total_time interval =\n  let count = total_time / interval in\n  let margin = 2 in\n  count - margin\nin\nadjusted_event_count 25 5"
      },
      "answer": "3"
    },
    "ejercicio-3": {
      "description": "Un diseñador de videojuegos calcula el daño de un ataque basado en el nivel del personaje (nivel 8), usando la fórmula nivel^2 + 2 * nivel. Define una función que compute el cuadrado del nivel y sume el doble del nivel. Evalúa con 8. Este ejercicio añade exponentes y suma, aumentando la robustez con dos términos. Paso a paso: nivel = 8, cuadrado = 8 * 8 = 64, doble = 2 * 8 = 16, total = 64 + 16 = 80. El resultado esperado es 80, modelando un daño que crece no linealmente, común en mecánicas de juegos.",
      "racket": {
        "code": "(define (damage level)\n  (let ((square (* level level))\n        (double (* 2 level)))\n    (+ square double))\n)\n(damage 8)"
      },
      "ocaml": {
        "code": "let damage level =\n  let square = level * level in\n  let double = 2 * level in\n  square + double\nin\ndamage 8"
      },
      "answer": "80"
    },
    "ejercicio-4": {
      "description": "Un ingeniero diseña un soporte triangular con catetos de 6 y 8 metros. Calcula la hipotenusa usando la fórmula de Pitágoras: sqrt(a^2 + b^2). Define una función que eleve al cuadrado ambos catetos, los sume y tome la raíz cuadrada. Evalúa con 6 y 8. Este ejercicio combina multiplicaciones, suma y raíz cuadrada, usando más operaciones que los anteriores. Paso a paso: a = 6, b = 8, a^2 = 36, b^2 = 64, suma = 36 + 64 = 100, raíz = sqrt(100) = 10. El resultado esperado es 10, crucial para diseño estructural.",
      "racket": {
        "code": "(define (hypotenuse a b)\n  (let ((a-square (* a a))\n        (b-square (* b b)))\n    (sqrt (+ a-square b-square)))\n)\n(hypotenuse 6 8)"
      },
      "ocaml": {
        "code": "let hypotenuse a b =\n  let a_square = a *. a in\n  let b_square = b *. b in\n  sqrt (a_square +. b_square)\nin\nhypotenuse 6.0 8.0"
      },
      "answer": "10"
    },
    "ejercicio-5": {
      "description": "Un chef diseña una olla esférica de radio 0.3 metros, calculando su volumen con la fórmula (4/3) * pi * r^3, donde pi = 3.14159. Define una función que compute el cubo del radio, lo multiplique por pi, y ajuste por la fracción 4/3. Evalúa con 0.3. Este ejercicio aumenta la complejidad con exponentes cúbicos, constantes y fracciones. Paso a paso: r = 0.3, r^3 = 0.3 * 0.3 * 0.3 = 0.027, pi * r^3 = 3.14159 * 0.027 ≈ 0.08482293, (4/3) * 0.08482293 ≈ 0.11309724. El resultado esperado es aproximadamente 0.11309724 metros cúbicos, útil para determinar capacidad.",
      "racket": {
        "code": "(define (sphere-volume r)\n  (let ((cube (* r r r))\n        (pi 3.14159)\n        (fraction (/ 4 3)))\n    (* fraction pi cube))\n)\n(sphere-volume 0.3)"
      },
      "ocaml": {
        "code": "let sphere_volume r =\n  let cube = r *. r *. r in\n  let pi = 3.14159 in\n  let fraction = 4.0 /. 3.0 in\n  fraction *. pi *. cube\nin\nsphere_volume 0.3"
      },
      "answer": "0.11309724"
    },
    "ejercicio-6": {
      "description": "Un financiero calcula el valor futuro de 1000 dólares con una tasa de interés compuesto del 4% anual, aplicada mensualmente durante 3 años, ajustada por una tarifa fija de 50 dólares, usando la fórmula p * (1 + r/n)^(n*t) - fee. Define una función que compute el factor de interés, eleve al número de períodos, multiplique por el principal y reste la tarifa. Evalúa con 1000, 0.04, 12, 3. Este ejercicio combina exponentes, divisiones, multiplicaciones y resta, con cuatro parámetros. Paso a paso: p = 1000, r = 0.04, n = 12, t = 3, factor = 1 + 0.04/12 ≈ 1.00333333, períodos = 12 * 3 = 36, factor^36 ≈ 1.12749786, valor = 1000 * 1.12749786 ≈ 1127.49786, menos 50 = 1077.49786. El resultado esperado es aproximadamente 1077.49786 dólares.",
      "racket": {
        "code": "(define (compound-interest p r n t)\n  (let ((rate-factor (+ 1 (/ r n)))\n        (periods (* n t))\n        (fee 50))\n    (- (* p (expt rate-factor periods)) fee))\n)\n(compound-interest 1000 0.04 12 3)"
      },
      "ocaml": {
        "code": "let compound_interest p r n t =\n  let rate_factor = 1.0 +. (r /. n) in\n  let periods = n *. t in\n  let fee = 50.0 in\n  (p *. (rate_factor ** periods)) -. fee\nin\ncompound_interest 1000.0 0.04 12.0 3.0"
      },
      "answer": "1077.49786"
    },
    "ejercicio-7": {
      "description": "Un astrónomo calcula la distancia entre dos puntos estelares en un sistema tridimensional con coordenadas (x1, y1, z1) = (2, 3, 4) y (x2, y2, z2) = (5, 7, 8), usando la fórmula de distancia euclidiana 3D: sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2). Define una función que compute las diferencias, sus cuadrados, la suma y la raíz cuadrada. Evalúa con 2, 3, 4, 5, 7, 8. Este ejercicio es el más robusto, con seis parámetros, múltiples restas, cuadrados, suma y raíz cuadrada, modelando geometría espacial avanzada. Paso a paso: x2 - x1 = 5 - 2 = 3, y2 - y1 = 7 - 3 = 4, z2 - z1 = 8 - 4 = 4, cuadrados: 3^2 = 9, 4^2 = 16, 4^2 = 16, suma = 9 + 16 + 16 = 41, raíz = sqrt(41) ≈ 6.403124237. El resultado esperado es aproximadamente 6.403124237, útil en astronomía y navegación.",
      "racket": {
        "code": "(define (distance-3d x1 y1 z1 x2 y2 z2)\n  (let ((dx (- x2 x1))\n        (dy (- y2 y1))\n        (dz (- z2 z1)))\n    (let ((dx-square (* dx dx))\n          (dy-square (* dy dy))\n          (dz-square (* dz dz)))\n      (sqrt (+ dx-square dy-square dz-square))))\n)\n(distance-3d 2 3 4 5 7 8)"
      },
      "ocaml": {
        "code": "let distance_3d x1 y1 z1 x2 y2 z2 =\n  let dx = x2 -. x1 in\n  let dy = y2 -. y1 in\n  let dz = z2 -. z1 in\n  let dx_square = dx *. dx in\n  let dy_square = dy *. dy in\n  let dz_square = dz *. dz in\n  sqrt (dx_square +. dy_square +. dz_square)\nin\ndistance_3d 2.0 3.0 4.0 5.0 7.0 8.0"
      },
      "answer": "6.403124237"
    }
  },
  "funciones-multiples": {
    "ejercicio-1": {
      "description": "Un artista pinta un mural triangular con base 8 metros y altura 5 metros. Define una función que calcule el área (base * altura / 2). Evalúa con 8 y 5. Esto introduce funciones con múltiples parámetros para cálculos geométricos simples.",
      "racket": {
        "code": "(define (triangle-area base height)\n  (/ (* base height) 2)\n)\n(triangle-area 8 5)"
      },
      "ocaml": {
        "code": "let triangle_area base height =\n  (base *. height) /. 2.0\nin\ntriangle_area 8.0 5.0"
      },
      "answer": "20"
    },
    "ejercicio-2": {
      "description": "Tres tareas toman 2, 3 y 4 minutos. Define una función que verifique si están en orden ascendente estricto. Usa pasos intermedios para comparar los tiempos. Evalúa con 2, 3 y 4. Esto muestra cómo combinar comparaciones lógicas con múltiples parámetros.",
      "racket": {
        "code": "(define (ascending? a b c)\n  (let ((ab (< a b))\n        (bc (< b c)))\n    (and ab bc))\n)\n(ascending? 2 3 4)"
      },
      "ocaml": {
        "code": "let ascending a b c =\n  let ab = a < b in\n  let bc = b < c in\n  ab && bc\nin\nascending 2 3 4"
      },
      "answer": "true"
    },
    "ejercicio-3": {
      "description": "Un estudiante camina de (1,2) a (4,6). Define una función para la distancia euclidiana: raíz de ((x2-x1)^2 + (y2-y1)^2). Evalúa con (1,2) y (4,6). Esto introduce cálculos geométricos complejos con cuatro parámetros.",
      "racket": {
        "code": "(define (distance x1 y1 x2 y2)\n  (sqrt (+ (expt (- x2 x1) 2)\n           (expt (- y2 y1) 2))\n  )\n)\n(distance 1 2 4 6)"
      },
      "ocaml": {
        "code": "let distance x1 y1 x2 y2 =\n  sqrt ((x2 -. x1) ** 2.0 +.\n        (y2 -. y1) ** 2.0)\nin\ndistance 1.0 2.0 4.0 6.0"
      },
      "answer": "5"
    },
    "ejercicio-4": {
      "description": "En un torneo, los puntajes son 6, 8 y 4. Define una función que encuentre el máximo de tres valores, usando pasos intermedios para comparar. Evalúa con 6, 8 y 4. Esto muestra cómo manejar selecciones complejas con múltiples parámetros.",
      "racket": {
        "code": "(define (max-of-three a b c)\n  (let ((bc (max b c))\n        (max-abc (max a bc)))\n    max-abc)\n)\n(max-of-three 6 8 4)"
      },
      "ocaml": {
        "code": "let max_of_three a b c =\n  let bc = max b c in\n  let max_abc = max a bc in\n  max_abc\nin\nmax_of_three 6 8 4"
      },
      "answer": "8"
    },
    "ejercicio-5": {
      "description": "Tres amigos gastan 10, 15 y 20 dólares. Define una función que calcule el promedio de tres valores, desglosando la suma y la división en pasos intermedios. Evalúa con 10, 15 y 20. Esto extiende los cálculos con múltiples parámetros para promedios robustos.",
      "racket": {
        "code": "(define (average-three a b c)\n  (let ((sum (+ a b c))\n        (avg (/ sum 3)))\n    avg)\n)\n(average-three 10 15 20)"
      },
      "ocaml": {
        "code": "let average_three a b c =\n  let sum = a + b + c in\n  let avg = sum / 3 in\n  avg\nin\naverage_three 10 15 20"
      },
      "answer": "15"
    },
    "ejercicio-6": {
      "description": "Un laboratorio mide presiones de 2, 3 y 4 kPa. Define una función que verifique si todas son positivas y están en orden ascendente, usando pasos intermedios para las validaciones. Evalúa con 2, 3 y 4. Esto combina múltiples validaciones lógicas con tres parámetros.",
      "racket": {
        "code": "(define (positive-and-ascending? a b c)\n  (let ((pos-a (> a 0))\n        (pos-b (> b 0))\n        (pos-c (> c 0))\n        (asc-ab (< a b))\n        (asc-bc (< b c)))\n    (and pos-a pos-b pos-c asc-ab asc-bc))\n)\n(positive-and-ascending? 2 3 4)"
      },
      "ocaml": {
        "code": "let positive_and_ascending a b c =\n  let pos_a = a > 0 in\n  let pos_b = b > 0 in\n  let pos_c = c > 0 in\n  let asc_ab = a < b in\n  let asc_bc = b < c in\n  pos_a && pos_b && pos_c && asc_ab && asc_bc\nin\npositive_and_ascending 2 3 4"
      },
      "answer": "true"
    },
    "ejercicio-7": {
      "description": "Una empresa calcula el volumen útil de una caja con dimensiones 3, 2, 4 metros y un margen de 0.1 metros en cada lado. Define una función que calcule el volumen útil (largo - 2*margen) * (ancho - 2*margen) * (alto - 2*margen). Evalúa con 3, 2, 4 y 0.1. Esto combina múltiples parámetros y pasos para cálculos prácticos avanzados.",
      "racket": {
        "code": "(define (useful-cuboid-volume l w h margin)\n  (let ((adj-l (- l (* 2 margin)))\n        (adj-w (- w (* 2 margin)))\n        (adj-h (- h (* 2 margin)))\n        (lw (* adj-l adj-w))\n        (volume (* lw adj-h)))\n    volume)\n)\n(useful-cuboid-volume 3 2 4 0.1)"
      },
      "ocaml": {
        "code": "let useful_cuboid_volume l w h margin =\n  let adj_l = l -. (2.0 *. margin) in\n  let adj_w = w -. (2.0 *. margin) in\n  let adj_h = h -. (2.0 *. margin) in\n  let lw = adj_l *. adj_w in\n  let volume = lw *. adj_h in\n  volume\nin\nuseful_cuboid_volume 3.0 2.0 4.0 0.1"
      },
      "answer": "19.008"
    }
  },
  "condicionales": {
    "ejercicio-1": {
      "description": "Las condicionales permiten decisiones. En una subasta, las ofertas son 10 y 7 dólares. Define una función que seleccione el mayor. Evalúa con 10 y 7. Esto introduce `if` para elegir valores basados en condiciones, manteniendo la pureza funcional.",
      "racket": {
        "code": "(define (max-two a b)\n  (if (> a b)\n      a\n      b\n  )\n)\n(max-two 10 7)"
      },
      "ocaml": {
        "code": "let max_two a b =\n  if a > b then\n    a\n  else\n    b\nin\nmax_two 10 7"
      },
      "answer": "10"
    },
    "ejercicio-2": {
      "description": "Clasificación con condicionales. Un sensor mide 3 grados Celsius. Define una función que clasifique como positivo, negativo o cero. Evalúa con 3. Esto muestra cómo usamos `cond` o `if-else` para categorizar valores.",
      "racket": {
        "code": "(define (classify-number x)\n  (cond\n    [(> x 0) 'positive]\n    [(< x 0) 'negative]\n    [else 'zero]\n  )\n)\n(classify-number 3)"
      },
      "ocaml": {
        "code": "let classify_number x =\n  if x > 0 then\n    \"positive\"\n  else if x < 0 then\n    \"negative\"\n  else\n    \"zero\"\nin\nclassify_number 3"
      },
      "answer": "positive"
    },
    "ejercicio-3": {
      "description": "Condiciones complejas. Para 2024, verifica si es bisiesto (divisible por 4, no por 100, salvo por 400). Define una función y evalúa con 2024. Esto muestra cómo anidamos condicionales para lógica avanzada.",
      "racket": {
        "code": "(define (leap-year? year)\n  (cond\n    [(= (remainder year 400) 0) #t]\n    [(= (remainder year 100) 0) #f]\n    [(= (remainder year 4) 0) #t]\n    [else #f]\n  )\n)\n(leap-year? 2024)"
      },
      "ocaml": {
        "code": "let leap_year year =\n  if year mod 400 = 0 then\n    true\n  else if year mod 100 = 0 then\n    false\n  else if year mod 4 = 0 then\n    true\n  else\n    false\nin\nleap_year 2024"
      },
      "answer": "true"
    },
    "ejercicio-4": {
      "description": "Clasificación numérica. Una reseña tiene puntuación -2. Define una función que devuelva el signo (1, -1, 0). Evalúa con -2. Esto refuerza cómo las condicionales producen valores basados en casos.",
      "racket": {
        "code": "(define (sign x)\n  (cond\n    [(> x 0) 1]\n    [(< x 0) -1]\n    [else 0]\n  )\n)\n(sign -2)"
      },
      "ocaml": {
        "code": "let sign x =\n  if x > 0 then\n    1\n  else if x < 0 then\n    -1\n  else\n    0\nin\nsign (-2)"
      },
      "answer": "-1"
    },
    "ejercicio-5": {
      "description": "Sistemas de calificación con anidación. Una estudiante obtiene 92.3. Define una función que primero clasifique según rangos, y dentro de cada rango, indique si está cerca del límite superior ('+') o inferior ('-'). Evalúa con 92.3. Esto muestra condicionales anidados con varias decisiones internas.",
      "racket": {
        "code": "(define (grade score)\n  (let ((rounded (round score)))\n    (cond\n      [(>= rounded 90)\n       (if (>= rounded 95)\n           'A+\n           'A-)]\n      [(>= rounded 80)\n       (if (>= rounded 85)\n           'B+\n           'B-)]\n      [(>= rounded 70)\n       (if (>= rounded 75)\n           'C+\n           'C-)]\n      [(>= rounded 60)\n       (if (>= rounded 65)\n           'D+\n           'D-)]\n      [else 'F]\n    )\n  )\n)\n(grade 92.3)"
      },
      "ocaml": {
        "code": "let grade score =\n  let rounded = int_of_float (Float.round score) in\n  if rounded >= 90 then\n    if rounded >= 95 then \"A+\" else \"A-\"\n  else if rounded >= 80 then\n    if rounded >= 85 then \"B+\" else \"B-\"\n  else if rounded >= 70 then\n    if rounded >= 75 then \"C+\" else \"C-\"\n  else if rounded >= 60 then\n    if rounded >= 65 then \"D+\" else \"D-\"\n  else\n    \"F\"\nin\ngrade 92.3"
      },
      "answer": "A-"
    },
    "ejercicio-6": {
      "description": "Condiciones lógicas anidadas. Una alarma se activa si el número es divisible por 2 y 3. Si no lo es, verifica si la raíz cuadrada redondeada es divisible por 5 o 7. Evalúa con 12. Esto muestra anidación de 'if' y uso mixto de 'and' y 'or'.",
      "racket": {
        "code": "(define (activate-alarm? x)\n  (if (and (= (remainder x 2) 0)\n           (= (remainder x 3) 0))\n      #t\n      (if (or (= (remainder (round (sqrt x)) 5) 0)\n              (= (remainder (round (sqrt x)) 7) 0))\n          #t\n          #f)))\n(activate-alarm? 12)"
      },
      "ocaml": {
        "code": "let activate_alarm x =\n  if x mod 2 = 0 && x mod 3 = 0 then\n    true\n  else if ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 5 = 0)\n       || ((int_of_float (Float.round (sqrt (float_of_int x)))) mod 7 = 0) then\n    true\n  else\n    false\nin\nactivate_alarm 12"
      },
      "answer": "true"
    },
    "ejercicio-7": {
      "description": "Clasificación geométrica compleja. Un triángulo tiene lados 3, 3, 3. La función primero valida si los lados forman un triángulo. Si es válido, anida otra evaluación para clasificarlo en equilátero, isósceles o escaleno, y además indica si es pequeño (todos los lados < 5). Evalúa con 3, 3, 3. Esto muestra condicionales múltiples y anidados.",
      "racket": {
        "code": "(define (triangle-type a b c)\n  (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n      (cond\n        [(and (= a b) (= b c))\n         (if (< a 5)\n             'small-equilateral\n             'equilateral)]\n        [(or (= a b) (= b c) (= a c))\n         (if (< a 5)\n             'small-isosceles\n             'isosceles)]\n        [else\n         (if (< a 5)\n             'small-scalene\n             'scalene)])\n      'invalid))\n(triangle-type 3 3 3)"
      },
      "ocaml": {
        "code": "let triangle_type a b c =\n  if a + b > c && a + c > b && b + c > a then\n    if a = b && b = c then\n      if a < 5 then \"small-equilateral\" else \"equilateral\"\n    else if a = b || b = c || a = c then\n      if a < 5 then \"small-isosceles\" else \"isosceles\"\n    else\n      if a < 5 then \"small-scalene\" else \"scalene\"\n  else\n    \"invalid\"\nin\ntriangle_type 3 3 3"
      },
      "answer": "small-equilateral"
    }
  },
  "recursion": {
    "ejercicio-1": {
      "description": "La recursión reemplaza bucles. Un comerciante suma ventas de 1 a 4 dólares en 4 días. Define una función recursiva para sumar los primeros n números. Evalúa con 4. Esto muestra cómo la recursión acumula resultados sin estado.",
      "racket": {
        "code": "(define (sum-n n)\n  (if (<= n 0)\n      0\n      (+ n (sum-n (- n 1)))\n  )\n)\n(sum-n 4)"
      },
      "ocaml": {
        "code": "let rec sum_n n =\n  if n <= 0 then\n    0\n  else\n    n + sum_n (n - 1)\nin\nsum_n 4"
      },
      "answer": "10"
    },
    "ejercicio-2": {
      "description": "Recursión para potencias. Una inversión de 2 dólares se duplica 4 veces. Define una función recursiva para calcular 2^4. Evalúa con 2 y 4. Esto refuerza cómo la recursión maneja cálculos repetitivos.",
      "racket": {
        "code": "(define (power base exp)\n  (if (= exp 0)\n      1\n      (* base (power base (- exp 1)))\n  )\n)\n(power 2 4)"
      },
      "ocaml": {
        "code": "let rec power base exp =\n  if exp = 0 then\n    1\n  else\n    base * power base (exp - 1)\nin\npower 2 4"
      },
      "answer": "16"
    },
    "ejercicio-3": {
      "description": "Factoriales con recursión. Un gerente calcula formas de organizar 4 cajas (4!). Define una función recursiva para el factorial. Evalúa con 4. Esto muestra cómo la recursión resuelve problemas combinatorios.",
      "racket": {
        "code": "(define (factorial n)\n  (if (<= n 1)\n      1\n      (* n (factorial (- n 1)))\n  )\n)\n(factorial 4)"
      },
      "ocaml": {
        "code": "let rec factorial n =\n  if n <= 1 then\n    1\n  else\n    n * factorial (n - 1)\nin\nfactorial 4"
      },
      "answer": "24"
    },
    "ejercicio-4": {
      "description": "Secuencias recursivas. Un biólogo calcula el número de Fibonacci para el mes 6. Define una función recursiva para Fibonacci. Evalúa con 6. Esto introduce recursión doble para secuencias naturales.",
      "racket": {
        "code": "(define (fibonacci n)\n  (if (<= n 1)\n      n\n      (+ (fibonacci (- n 1))\n         (fibonacci (- n 2))\n      )\n  )\n)\n(fibonacci 6)"
      },
      "ocaml": {
        "code": "let rec fibonacci n =\n  if n <= 1 then\n    n\n  else\n    fibonacci (n - 1) +\n    fibonacci (n - 2)\nin\nfibonacci 6"
      },
      "answer": "8"
    },
    "ejercicio-5": {
      "description": "Procesamiento numérico. Un código postal 12345 se valida sumando sus dígitos. Define una función recursiva para sumar dígitos. Evalúa con 12345. Esto muestra cómo la recursión descompone números.",
      "racket": {
        "code": "(define (sum-digits n)\n  (if (< n 10)\n      n\n      (+ (remainder n 10)\n         (sum-digits (quotient n 10))\n      )\n  )\n)\n(sum-digits 12345)"
      },
      "ocaml": {
        "code": "let rec sum_digits n =\n  if n < 10 then\n    n\n  else\n    (n mod 10) +\n    sum_digits (n / 10)\nin\nsum_digits 12345"
      },
      "answer": "15"
    },
    "ejercicio-6": {
      "description": "Productos recursivos. Un matemático calcula el producto de los primeros 3 impares (1, 3, 5). Define una función recursiva para esto. Evalúa con 3. Esto extiende la recursión a productos específicos.",
      "racket": {
        "code": "(define (product-odds n)\n  (if (<= n 0)\n      1\n      (* (+ (* 2 n) -1)\n         (product-odds (- n 1))\n      )\n  )\n)\n(product-odds 3)"
      },
      "ocaml": {
        "code": "let rec product_odds n =\n  if n <= 0 then\n    1\n  else\n    (2 * n - 1) *\n    product_odds (n - 1)\nin\nproduct_odds 3"
      },
      "answer": "15"
    },
    "ejercicio-7": {
      "description": "Contar dígitos. Un número de teléfono 1234 se valida contando sus dígitos. Define una función recursiva para contar dígitos. Evalúa con 1234. Esto muestra cómo la recursión maneja descomposición numérica.",
      "racket": {
        "code": "(define (count-digits n)\n  (if (< n 10)\n      1\n      (+ 1 (count-digits (quotient n 10)))\n  )\n)\n(count-digits 1234)"
      },
      "ocaml": {
        "code": "let rec count_digits n =\n  if n < 10 then\n    1\n  else\n    1 + count_digits (n / 10)\nin\ncount_digits 1234"
      },
      "answer": "4"
    }
  },
  "listas": {
    "ejercicio-1": {
      "description": "Una organizadora tiene tareas (1 2 3 4). Define una función recursiva para contar elementos en una lista. Evalúa con (1 2 3 4). Esto introduce listas y recursión básica para procesarlas, ideal para principiantes.",
      "racket": {
        "code": "(define (length lst)\n  (if (empty? lst)\n      0\n      (+ 1 (length (rest lst)))\n  )\n)\n(length '(1 2 3 4))"
      },
      "ocaml": {
        "code": "let rec length lst =\n  if lst = [] then\n    0\n  else\n    1 + length (List.tl lst)\nin\nlength [1; 2; 3; 4]"
      },
      "answer": "4"
    },
    "ejercicio-2": {
      "description": "Un gerente prioriza las dos primeras tareas de (5 6 7 8 9). Define una función recursiva para obtener los dos primeros elementos de una lista, usando pasos intermedios para manejar casos vacíos y longitud. Evalúa con (5 6 7 8 9). Esto muestra cómo extraer múltiples datos con robustez.",
      "racket": {
        "code": "(define (first-two-elements lst)\n  (let ((len (length lst)))\n    (if (< len 1)\n        null\n        (let ((first-el (first lst))\n              (rest-lst (rest lst)))\n          (if (empty? rest-lst)\n              (list first-el)\n              (list first-el (first rest-lst))))))\n)\n(first-two-elements '(5 6 7 8 9))"
      },
      "ocaml": {
        "code": "let rec first_two_elements lst =\n  let len = List.length lst in\n  if len < 1 then\n    []\n  else\n    let first_el = List.hd lst in\n    let rest_lst = List.tl lst in\n    if rest_lst = [] then\n      [first_el]\n    else\n      [first_el; List.hd rest_lst]\nin\nfirst_two_elements [5; 6; 7; 8; 9]"
      },
      "answer": "(5 6)"
    },
    "ejercicio-3": {
      "description": "En una cola (1 2 3 4 5), el último cliente espera más. Define una función recursiva para obtener el último elemento, con pasos intermedios para verificar la longitud y manejar sublistas. Evalúa con (1 2 3 4 5). Esto introduce recursión más robusta para navegar listas largas.",
      "racket": {
        "code": "(define (last-element lst)\n  (let ((len (length lst)))\n    (if (< len 1)\n        null\n        (let ((rest-lst (rest lst))\n              (len-rest (length rest-lst)))\n          (if (= len-rest 0)\n              (first lst)\n              (last-element rest-lst)))))\n)\n(last-element '(1 2 3 4 5))"
      },
      "ocaml": {
        "code": "let rec last_element lst =\n  let len = List.length lst in\n  if len < 1 then\n    None\n  else\n    let rest_lst = List.tl lst in\n    let len_rest = List.length rest_lst in\n    if len_rest = 0 then\n      Some (List.hd lst)\n    else\n      last_element rest_lst\nin\nlast_element [1; 2; 3; 4; 5]"
      },
      "answer": "5"
    },
    "ejercicio-4": {
      "description": "Un mercado une frutas (1 2), verduras (3 4), y lácteos (5 6). Define una función recursiva para concatenar tres listas, con pasos intermedios para verificar longitud y combinar listas. Evalúa con (1 2), (3 4), (5 6). Esto aumenta la complejidad al manejar múltiples listas.",
      "racket": {
        "code": "(define (append-three lst1 lst2 lst3)\n  (let ((len1 (length lst1))\n        (append12 (if (empty? lst1)\n                      lst2\n                      (cons (first lst1)\n                            (append-three (rest lst1) lst2 lst3)))))\n    (if (empty? append12)\n        lst3\n        (let ((first-12 (first append12))\n              (rest-12 (rest append12)))\n          (cons first-12 (append-three rest-12 lst3 '())))))\n)\n(append-three '(1 2) '(3 4) '(5 6))"
      },
      "ocaml": {
        "code": "let rec append_three lst1 lst2 lst3 =\n  let len1 = List.length lst1 in\n  let append12 = if lst1 = [] then\n                   lst2\n                 else\n                   List.hd lst1 :: append_three (List.tl lst1) lst2 lst3 in\n  if append12 = [] then\n    lst3\n  else\n    let first_12 = List.hd append12 in\n    let rest_12 = List.tl append12 in\n    first_12 :: append_three rest_12 lst3 []\nin\nappend_three [1; 2] [3; 4] [5; 6]"
      },
      "answer": "(1 2 3 4 5 6)"
    },
    "ejercicio-5": {
      "description": "Un estudiante completa la primera y última tarea de (1 2 3 4 5 6). Define una función recursiva para obtener los elementos intermedios (sin el primero ni el último), con pasos intermedios para longitud y sublistas. Evalúa con (1 2 3 4 5 6). Esto aumenta la robustez al manipular listas largas.",
      "racket": {
        "code": "(define (middle-elements lst)\n  (let ((len (length lst))\n        (rest-lst (if (empty? lst) null (rest lst))))\n    (if (< len 2)\n        null\n        (let ((len-rest (length rest-lst))\n              (middle-rest (if (empty? rest-lst) null (rest rest-lst))))\n          (if (<= len-rest 1)\n              null\n              (cons (first rest-lst) (middle-elements rest-lst))))))\n)\n(middle-elements '(1 2 3 4 5 6))"
      },
      "ocaml": {
        "code": "let rec middle_elements lst =\n  let len = List.length lst in\n  let rest_lst = if lst = [] then [] else List.tl lst in\n  if len < 2 then\n    []\n  else\n    let len_rest = List.length rest_lst in\n    let middle_rest = if rest_lst = [] then [] else List.tl rest_lst in\n    if len_rest <= 1 then\n      []\n    else\n      List.hd rest_lst :: middle_elements rest_lst\nin\nmiddle_elements [1; 2; 3; 4; 5; 6]"
      },
      "answer": "(2 3 4 5)"
    },
    "ejercicio-6": {
      "description": "Una aplicación verifica si todas las sublistas en ((1 2) () (3 4) ()) son vacías, con pasos intermedios para contar elementos y manejar sublistas recursivamente. Evalúa con ((1 2) () (3 4) ()). Esto combina recursión anidada y verificaciones complejas en listas de listas.",
      "racket": {
        "code": "(define (all-empty? lst)\n  (let ((len (length lst))\n        (first-sublist (if (empty? lst) null (first lst)))\n        (rest-sublists (if (empty? lst) null (rest lst))))\n    (if (= len 0)\n        true\n        (let ((len-first (length first-sublist))\n              (rest-empty (all-empty? rest-sublists)))\n          (and (= len-first 0) rest-empty))))\n)\n(all-empty? '((1 2) () (3 4) ()))"
      },
      "ocaml": {
        "code": "let rec all_empty lst =\n  let len = List.length lst in\n  let first_sublist = if lst = [] then [] else List.hd lst in\n  let rest_sublists = if lst = [] then [] else List.tl lst in\n  if len = 0 then\n    true\n  else\n    let len_first = List.length first_sublist in\n    let rest_empty = all_empty rest_sublists in\n    len_first = 0 && rest_empty\nin\nall_empty [[1; 2]; []; [3; 4]; []]"
      },
      "answer": "false"
    },
    "ejercicio-7": {
      "description": "Un programador transforma un elemento y lo añade a (1 2 3 4), multiplicándolo por 2 (0*2=0), con pasos intermedios para transformar, verificar longitud, y construir la lista recursivamente usando una función auxiliar. Evalúa con 0 y (1 2 3 4). Esto combina transformación, recursión y construcción de listas dinámicas.",
      "racket": {
        "code": "(define (cons-transformed-aux x lst acc)\n  (let ((transformed (* x 2))\n        (len (length lst))\n        (new-lst (cons transformed lst)))\n    (if (empty? new-lst)\n        acc\n        (let ((first-el (first new-lst))\n              (rest-el (rest new-lst))\n              (len-rest (length rest-el)))\n          (cons-transformed-aux 0 rest-el (cons first-el acc))))\n)\n(define (cons-transformed x lst)\n  (cons-transformed-aux x lst null)\n)\n(cons-transformed 0 '(1 2 3 4))"
      },
      "ocaml": {
        "code": "let rec cons_transformed_aux x lst acc =\n  let transformed = x * 2 in\n  let len = List.length lst in\n  let new_lst = transformed :: lst in\n  if new_lst = [] then\n    List.rev acc\n  else\n    let first_el = List.hd new_lst in\n    let rest_el = List.tl new_lst in\n    let len_rest = List.length rest_el in\n    cons_transformed_aux 0 rest_el (first_el :: acc)\nlet cons_transformed x lst =\n  cons_transformed_aux x lst []\nin\ncons_transformed 0 [1; 2; 3; 4]"
      },
      "answer": "(0 1 2 3 4)"
    }
  },
  "funciones-orden-superior": {
    "ejercicio-1": {
      "description": "Introducción a funciones de orden superior con transformaciones simples. Una tienda aplica un descuento del 15% a una lista de precios de productos: (100 200 300). Define una función que use 'map' para aplicar el descuento multiplicando cada precio por 0.85. Maneja listas vacías devolviendo una lista vacía. Evalúa con (100 200 300). Este ejercicio introduce el paso de funciones como argumentos para transformaciones básicas.",
      "racket": {
        "code": "(define (apply-discount lst)\n  (if (empty? lst)\n      '()\n      (map (lambda (x) (* x 0.85)) lst)\n  )\n)\n(apply-discount '(100 200 300))"
      },
      "ocaml": {
        "code": "let apply_discount lst =\n  if lst = [] then\n    []\n  else\n    List.map (fun x -> x *. 0.85) lst\nin\napply_discount [100; 200; 300]"
      },
      "answer": "(85.0 170.0 255.0)"
    },
    "ejercicio-2": {
      "description": "Filtrado con condiciones compuestas. Un inventario filtra productos con stock mayor a 5 y precio menor a 50: (10 60 30 40 70). Define una función que use 'filter' con un predicado compuesto para seleccionar elementos que cumplan ambas condiciones. Asegura manejo de listas vacías. Evalúa con la lista dada. Este ejercicio avanza en el uso de predicados funcionales para filtrado selectivo.",
      "racket": {
        "code": "(define (filter-stock lst)\n  (if (empty? lst)\n      '()\n      (filter (lambda (x) (and (> x 5) (< x 50))) lst)\n  )\n)\n(filter-stock '(10 60 30 40 70))"
      },
      "ocaml": {
        "code": "let filter_stock lst =\n  if lst = [] then\n    []\n  else\n    List.filter (fun x -> x > 5 && x < 50) lst\nin\nfilter_stock [10; 60; 30; 40; 70]"
      },
      "answer": "(10 30 40)"
    },
    "ejercicio-3": {
      "description": "Transformación y filtrado combinados. Una empresa calcula costos de producción: (2 3 -4 5 -6). Filtra valores absolutos mayores a 3 y luego eleva al cuadrado los resultados. Usa 'filter' para seleccionar y 'map' para transformar. Maneja listas vacías y valores negativos. Evalúa con la lista dada. Este ejercicio introduce pipelines funcionales con múltiples transformaciones.",
      "racket": {
        "code": "(define (process-costs lst)\n  (if (empty? lst)\n      '()\n      (let ((filtered (filter (lambda (x) (> (abs x) 3)) lst)))\n        (map (lambda (x) (* (abs x) (abs x))) filtered)\n      )\n  )\n)\n(process-costs '(2 3 -4 5 -6))"
      },
      "ocaml": {
        "code": "let process_costs lst =\n  if lst = [] then\n    []\n  else\n    let filtered = List.filter (fun x -> abs x > 3) lst in\n    List.map (fun x -> (abs x) * (abs x)) filtered\nin\nprocess_costs [2; 3; -4; 5; -6]"
      },
      "answer": "(16 25 36)"
    },
    "ejercicio-4": {
      "description": "Acumulación con funciones de orden superior. Un sistema registra transacciones: (100 -50 200 -30 150). Calcula la suma de transacciones positivas mayores a 100 usando 'filter' y 'foldl' (o fold_left). Parametriza el umbral y la operación de acumulación. Maneja listas vacías devolviendo 0. Evalúa con la lista dada. Este ejercicio introduce acumuladores funcionales para procesar datos filtrados.",
      "racket": {
        "code": "(define (sum-transactions threshold lst)\n  (if (empty? lst)\n      0\n      (foldl + 0 (filter (lambda (x) (> x threshold)) lst))\n  )\n)\n(sum-transactions 100 '(100 -50 200 -30 150))"
      },
      "ocaml": {
        "code": "let sum_transactions threshold lst =\n  if lst = [] then\n    0\n  else\n    List.fold_left (+) 0 (List.filter (fun x -> x > threshold) lst)\nin\nsum_transactions 100 [100; -50; 200; -30; 150]"
      },
      "answer": "350"
    },
    "ejercicio-5": {
      "description": "Currying y funciones devueltas. Un sistema financiero procesa valores: (-200 300 -100 400), aplicando valor absoluto, filtrando mayores a 150, y sumándolos. Define una función de orden superior que tome un umbral y devuelva una función que realice el procesamiento (map para absoluto, filter para umbral, fold para suma). Maneja listas vacías devolviendo 0. Evalúa con umbral 150 y la lista dada. Este ejercicio explora cierres y configuraciones dinámicas.",
      "racket": {
        "code": "(define (make-financial-processor threshold)\n  (lambda (lst)\n    (if (empty? lst)\n        0\n        (foldl + 0\n               (filter (lambda (x) (> x threshold))\n                       (map abs lst)\n               )\n        )\n    )\n  )\n)\n((make-financial-processor 150) '(-200 300 -100 400))"
      },
      "ocaml": {
        "code": "let make_financial_processor threshold =\n  fun lst ->\n    if lst = [] then\n      0\n    else\n      List.fold_left (+) 0\n        (List.filter (fun x -> x > threshold)\n           (List.map abs lst)\n        )\nin\nmake_financial_processor 150 [-200; 300; -100; 400]"
      },
      "answer": "700"
    },
    "ejercicio-6": {
      "description": "Procesamiento de datos estructurados. Una base de datos almacena registros de ventas como parejas (monto . tipo): ((200 . \"venta\") (-50 . \"devolucion\") (300 . \"venta\") (-20 . \"devolucion\")). Filtra ventas positivas, extrae montos y calcula la suma total. Define una función que acepte un predicado y una función extractora, usando 'filter', 'map' y 'fold'. Maneja listas vacías devolviendo 0. Evalúa con la lista dada. Este ejercicio trabaja con estructuras complejas y abstracciones funcionales.",
      "racket": {
        "code": "(define (process-sales pred extractor lst)\n  (if (empty? lst)\n      0\n      (foldl + 0\n             (map extractor\n                  (filter pred lst)\n             )\n      )\n  )\n)\n(process-sales\n  (lambda (p) (and (string=? (cdr p) \"venta\") (> (car p) 0)))\n  car\n  '((200 . \"venta\") (-50 . \"devolucion\") (300 . \"venta\") (-20 . \"devolucion\"))\n)"
      },
      "ocaml": {
        "code": "let process_sales pred extractor lst =\n  if lst = [] then\n    0\n  else\n    List.fold_left (+) 0\n      (List.map extractor\n         (List.filter pred lst)\n      )\nin\nprocess_sales\n  (fun (m, t) -> t = \"venta\" && m > 0)\n  fst\n  [(200, \"venta\"); (-50, \"devolucion\"); (300, \"venta\"); (-20, \"devolucion\")]\n"
      },
      "answer": "500"
    },
    "ejercicio-7": {
      "description": "Pipelines complejos con datos anidados. Una escuela gestiona calificaciones en listas anidadas: ((70 80 90) (60 85 95) (50 60)). Filtra calificaciones aprobadas (>70) por estudiante, calcula el promedio por estudiante, y selecciona estudiantes con promedio mayor a 80. Usa 'map', 'filter' y 'fold' anidados, manejando listas vacías y sublistas vacías devolviendo resultados apropiados (0 para promedios vacíos, lista vacía para resultado final). Evalúa con la lista dada. Este ejercicio demuestra composición avanzada y manejo de datos multinivel.",
      "racket": {
        "code": "(define (process-grades lst)\n  (if (empty? lst)\n      '()\n      (filter (lambda (avg) (> avg 80))\n              (map (lambda (sublst)\n                     (if (empty? sublst)\n                         0\n                         (let ((approved (filter (lambda (g) (> g 70)) sublst)))\n                           (if (empty? approved)\n                               0\n                               (/ (foldl + 0 approved) (length approved))\n                           )\n                         )\n                     )\n                   lst\n              )\n      )\n  )\n)\n(process-grades '((70 80 90) (60 85 95) (50 60)))"
      },
      "ocaml": {
        "code": "let process_grades lst =\n  if lst = [] then\n    []\n  else\n    List.filter (fun avg -> avg > 80)\n      (List.map (fun sublst ->\n                   if sublst = [] then\n                     0\n                   else\n                     let approved = List.filter (fun g -> g > 70) sublst in\n                     if approved = [] then\n                       0\n                     else\n                       (List.fold_left (+) 0 approved) / (List.length approved)\n                ) lst\n      )\nin\nprocess_grades [[70; 80; 90]; [60; 85; 95]; [50; 60]]"
      },
      "answer": "(85 90)"
    }
  },
  "tipos-datos-simples": {
    "ejercicio-1": {
      "description": "Suma de tuplas con validación. Una empresa registra horas trabajadas como una tupla (5, 3). Define una función que sume los valores de una tupla, verificando que ambos sean números. Evalúa con (5, 3). Este ejercicio introduce el manejo de datos estructurados y validación básica en programación funcional.",
      "racket": {
        "code": "(define (sum-tuple t)\n  (if (and (pair? t) (number? (car t)) (number? (cdr t)))\n      (+ (car t) (cdr t))\n      (error \"Input must be a pair of numbers\"))\n)\n(sum-tuple '(5 . 3))"
      },
      "ocaml": {
        "code": "let sum_tuple (a, b) =\n  if (is_int a && is_int b) || (is_float a && is_float b) then\n    a +. (float_of_int b)\n  else\n    failwith \"Input must be a pair of numbers\"\nin\nsum_tuple (5, 3)"
      },
      "answer": "8"
    },
    "ejercicio-2": {
      "description": "Extracción segura de coordenadas. Una coordenada se representa como (7, 8). Define una función que extraiga el primer elemento, verificando que la entrada sea una tupla válida. Evalúa con (7, 8). Este ejercicio refuerza el acceso a datos estructurados con manejo de errores.",
      "racket": {
        "code": "(define (first-of-tuple t)\n  (if (pair? t)\n      (car t)\n      (error \"Input must be a pair\"))\n)\n(first-of-tuple '(7 . 8))"
      },
      "ocaml": {
        "code": "let first_of_tuple (a, _) =\n  a\nin\nfirst_of_tuple (7, 8)"
      },
      "answer": "7"
    },
    "ejercicio-3": {
      "description": "Registros personalizados con validación. Un registro de persona es ('Ana', 20). Define una función que extraiga la edad, asegurando que la entrada sea un registro válido y la edad un número positivo. Evalúa con ('Ana', 20). Este ejercicio introduce estructuras definidas por el usuario con robustez.",
      "racket": {
        "code": "(struct person (name age))\n(define (get-age p)\n  (if (and (person? p) (number? (person-age p)) (> (person-age p) 0))\n      (person-age p)\n      (error \"Invalid person or age\"))\n)\n(get-age (person \"Ana\" 20))"
      },
      "ocaml": {
        "code": "type person = { name: string; age: int }\nlet get_age p =\n  if p.age > 0 then\n    p.age\n  else\n    failwith \"Age must be positive\"\nin\nget_age { name = \"Ana\"; age = 20 }"
      },
      "answer": "20"
    },
    "ejercicio-4": {
      "description": "Volumen de una caja con tupla triple. Una caja tiene dimensiones (2, 3, 4). Define una función que calcule el volumen multiplicando los valores, verificando que sean números positivos. Evalúa con (2, 3, 4). Este ejercicio extiende el uso de tuplas con cálculos más complejos y validación.",
      "racket": {
        "code": "(define (product-triple t)\n  (if (and (list? t) (= (length t) 3)\n           (andmap number? t) (andmap positive? t))\n      (* (car t) (cadr t) (caddr t))\n      (error \"Input must be a list of three positive numbers\"))\n)\n(product-triple '(2 3 4))"
      },
      "ocaml": {
        "code": "let product_triple (a, b, c) =\n  if a > 0 && b > 0 && c > 0 then\n    a * b * c\n  else\n    failwith \"Dimensions must be positive\"\nin\nproduct_triple (2, 3, 4)"
      },
      "answer": "24"
    },
    "ejercicio-5": {
      "description": "Comparación robusta de tuplas. Un sistema compara coordenadas (1, 2) y (1, 2). Define una función que verifique si dos tuplas son iguales, asegurando que ambas sean tuplas válidas de números. Evalúa con (1, 2) y (1, 2). Este ejercicio introduce comparación de estructuras con validación.",
      "racket": {
        "code": "(define (equal-tuples? t1 t2)\n  (if (and (pair? t1) (pair? t2)\n           (number? (car t1)) (number? (cdr t1))\n           (number? (car t2)) (number? (cdr t2)))\n      (and (= (car t1) (car t2)) (= (cdr t1) (cdr t2)))\n      (error \"Inputs must be pairs of numbers\"))\n)\n(equal-tuples? '(1 . 2) '(1 . 2))"
      },
      "ocaml": {
        "code": "let equal_tuples (a1, b1) (a2, b2) =\n  if (is_int a1 && is_int b1 && is_int a2 && is_int b2) ||\n     (is_float a1 && is_float b1 && is_float a2 && is_float b2) then\n    a1 = a2 && b1 = b2\n  else\n    failwith \"Inputs must be pairs of numbers\"\nin\nequal_tuples (1, 2) (1, 2)"
      },
      "answer": "true"
    },
    "ejercicio-6": {
      "description": "Extracción avanzada de registros. Un censo registra personas con nombre, edad y ciudad ('Bob', 25, 'Paris'). Define una función que extraiga el nombre, verificando que sea un registro válido y el nombre no esté vacío. Evalúa con ('Bob', 25, 'Paris'). Este ejercicio refuerza el manejo de estructuras complejas con validación estricta.",
      "racket": {
        "code": "(struct person (name age city))\n(define (get-name p)\n  (if (and (person? p) (string? (person-name p)) (not (string=? (person-name p) \"\")))\n      (person-name p)\n      (error \"Invalid person or empty name\"))\n)\n(get-name (person \"Bob\" 25 \"Paris\"))"
      },
      "ocaml": {
        "code": "type person = { name: string; age: int; city: string }\nlet get_name p =\n  if p.name <> \"\" then\n    p.name\n  else\n    failwith \"Name must not be empty\"\nin\nget_name { name = \"Bob\"; age = 25; city = \"Paris\" }"
      },
      "answer": "Bob"
    },
    "ejercicio-7": {
      "description": "Construcción y procesamiento de registros anidados. Un sistema registra un estudiante con nombre, edad y notas ('Carlos', 22, (90, 85)). Define una función que cree un registro y devuelva una tupla con el nombre y el promedio de notas, validando que las notas sean números positivos. Evalúa con 'Carlos', 22, (90, 85). Este ejercicio combina creación de estructuras, cálculos y validación avanzada.",
      "racket": {
        "code": "(struct student (name age grades))\n(define (student-info name age grades)\n  (if (and (string? name) (not (string=? name \"\"))\n           (number? age) (> age 0)\n           (list? grades) (not (empty? grades)) (andmap positive? grades))\n      (let ((s (student name age grades)))\n        (cons (student-name s)\n              (/ (foldl + 0 grades) (length grades))))\n      (error \"Invalid input: name, age, or grades\"))\n)\n(student-info \"Carlos\" 22 '(90 85))"
      },
      "ocaml": {
        "code": "type student = { name: string; age: int; grades: int list }\nlet student_info name age grades =\n  if name <> \"\" && age > 0 && grades <> [] &&\n     List.for_all (fun x -> x > 0) grades then\n    let s = { name; age; grades } in\n    (s.name, (List.fold_left (+) 0 grades) / (List.length grades))\n  else\n    failwith \"Invalid input: name, age, or grades\"\nin\nstudent_info \"Carlos\" 22 [90; 85]"
      },
      "answer": "(Carlos 87)"
    }
  },
  "cadenas-y-caracteres": {
    "ejercicio-1": {
      "description": "Longitud de cadenas con validación anidada. Una app de login verifica la longitud de 'admin', pero con chequeos anidados para cadenas vacías, con espacios o unicode (ej. 'admín'). Define una función que cuente la longitud, limpiando primero y manejando errores. Evalúa con 'admin'. Este ejercicio introduce cadenas con robustez básica, como en sistemas de seguridad que evitan inyecciones.",
      "racket": {
        "code": "(define (string-length-safe str)\n  (if (string? str)\n      (if (> (string-length str) 0)\n          (if (regexp-match? #rx\"^[a-zA-Z0-9]+$\" str)\n              (string-length (string-trim str))\n              (error \"Invalid characters in string\"))\n          0)\n      (error \"Input must be a string\"))\n)\n(string-length-safe \"admin\")"
      },
      "ocaml": {
        "code": "let string_length_safe str =\n  if str = \"\" then\n    0\n  else if String.length str > 0 then\n    if String.contains str ' ' then\n      String.length (String.trim str)\n    else\n      String.length str\n  else\n    failwith \"Input must be a string\"\nin\nstring_length_safe \"admin\""
      },
      "answer": "5"
    },
    "ejercicio-2": {
      "description": "Concatenación con limpieza y chequeos anidados. Un chatbot une 'hola ' y ' mundo', limpiando espacios, verificando longitud mínima y si contienen vocales (para evitar spam). Define una función con if anidados. Evalúa con 'hola ' y ' mundo'. Este ejercicio avanza con validaciones anidadas, como en bots que procesan mensajes seguros.",
      "racket": {
        "code": "(define (concat-strings-safe s1 s2)\n  (if (and (string? s1) (string? s2))\n      (if (and (> (string-length s1) 0) (> (string-length s2) 0))\n          (if (or (string-contains? s1 \"a\") (string-contains? s2 \"e\"))\n              (string-append (string-trim s1) \" \" (string-trim s2))\n              (error \"Strings must contain vowels\"))\n          \"\")\n      (error \"Inputs must be strings\"))\n)\n(concat-strings-safe \"hola \" \" mundo\")"
      },
      "ocaml": {
        "code": "let concat_strings_safe s1 s2 =\n  if s1 = \"\" || s2 = \"\" then\n    \"\"\n  else if String.length s1 > 0 && String.length s2 > 0 then\n    if String.contains s1 'a' || String.contains s2 'e' then\n      String.trim s1 ^ \" \" ^ String.trim s2\n    else\n      failwith \"Strings must contain vowels\"\n  else\n    failwith \"Inputs must be strings\"\nin\nconcat_strings_safe \"hola \" \" mundo\""
      },
      "answer": "hola mundo"
    },
    "ejercicio-3": {
      "description": "Extracción de caracteres con anidamiento y defaults. Un diseñador extrae la inicial de 'gato', con chequeos anidados para vacío, longitud y si es letra (no número). Si falla, devuelve '?'. Define una función robusta. Evalúa con 'gato'. Este ejercicio introduce caracteres con lógica anidada, como en generadores de avatares que manejan entradas malas.",
      "racket": {
        "code": "(define (first-char-safe str)\n  (if (string? str)\n      (if (> (string-length str) 0)\n          (if (char-alphabetic? (string-ref str 0))\n              (string-ref str 0)\n              #\\?)\n          #\\?)\n      (error \"Input must be a string\"))\n)\n(first-char-safe \"gato\")"
      },
      "ocaml": {
        "code": "let first_char_safe str =\n  if String.length str > 0 then\n    if Char.is_alpha (String.get str 0) then\n      String.get str 0\n    else\n      '?' \n  else\n    '?' \nin\nfirst_char_safe \"gato\""
      },
      "answer": "g"
    },
    "ejercicio-4": {
      "description": "Mayúsculas con normalización y chequeos anidados. Un cartel convierte 'welcome' a mayúsculas, con chequeos para acentos, longitud mínima y si contiene letras (no solo números). Define una función con anidamiento. Evalúa con 'welcome'. Este ejercicio añade complejidad con unicode, como en apps globales.",
      "racket": {
        "code": "(define (to-upper-safe str)\n  (if (string? str)\n      (if (> (string-length str) 5)\n          (if (regexp-match? #rx\"[a-zA-Z]\" str)\n              (string-upcase (string-normalize-nfd str))\n              (error \"String must contain letters\"))\n          (error \"String too short\"))\n      (error \"Input must be a string\"))\n)\n(to-upper-safe \"welcome\")"
      },
      "ocaml": {
        "code": "let to_upper_safe str =\n  if str = \"\" then\n    \"\"\n  else if String.length str > 5 then\n    if String.exists (fun c -> Char.is_alpha c) str then\n      String.uppercase_ascii str\n    else\n      failwith \"String must contain letters\"\n  else\n    failwith \"String too short\"\nin\nto_upper_safe \"welcome\""
      },
      "answer": "WELCOME"
    },
    "ejercicio-5": {
      "description": "Verificación de vacío con trim y anidamiento avanzado. Un formulario chequea '  ', limpiando y verificando si es email válido (con @ y .). Define una función con chequeos anidados para vacío y formato. Evalúa con '  '. Este ejercicio robustece con regex-like, como en validadores de login.",
      "racket": {
        "code": "(define (empty-string-safe? str)\n  (if (string? str)\n      (let ((trimmed (string-trim str)))\n        (if (string=? trimmed \"\")\n            #t\n            (if (regexp-match? #rx\"@\" trimmed)\n                #f\n                (error \"Invalid format\"))))\n      (error \"Input must be a string\"))\n)\n(empty-string-safe? \"  \")"
      },
      "ocaml": {
        "code": "let empty_string_safe str =\n  let trimmed = String.trim str in\n  if trimmed = \"\" then\n    true\n  else if String.contains trimmed '@' then\n    false\n  else\n    failwith \"Invalid format\"\nin\nempty_string_safe \"  \""
      },
      "answer": "true"
    },
    "ejercicio-6": {
      "description": "Subcadenas con chequeos anidados y unicode. Extrae 'yth' de 'p🐍thon', con validaciones para límites, unicode y si la subcadena contiene emojis. Define una función con anidamiento y normalización. Evalúa con 'python', 1, 3. Este ejercicio es innovador con emojis, como en apps de chat.",
      "racket": {
        "code": "(define (substring-safe str start len)\n  (if (string? str)\n      (if (>= start 0)\n          (if (<= (+ start len) (string-length str))\n              (let ((sub (substring str start (+ start len))))\n                (if (regexp-match? #rx\"[\\U0001F000-\\U0001FFFF]\" sub)\n                    (string-append sub \" (emoji detected)\")\n                    sub))\n              (error \"Length exceeds bounds\"))\n          (error \"Start must be non-negative\"))\n      (error \"Input must be a string\"))\n)\n(substring-safe \"python\" 1 3)"
      },
      "ocaml": {
        "code": "let substring_safe str start len =\n  if start >= 0 then\n    if (start + len) <= String.length str then\n      let sub = String.sub str start len in\n      if String.contains sub '\\xF0' then\n        sub ^ \" (emoji detected)\"\n      else\n        sub\n    else\n      failwith \"Length exceeds bounds\"\n  else\n    failwith \"Start must be non-negative\"\nin\nsubstring_safe \"python\" 1 3"
      },
      "answer": "yth"
    },
    "ejercicio-7": {
      "description": "Conteo de vocales con normalización, recursión y análisis sentimental. Cuenta vocales en 'Héllo Wørld', con recursión para procesar, insensibilidad a mayúsculas/acentos, y un bonus: si hay >5 vocales, agrega 'positivo' (sentimental simple). Define una función compleja. Evalúa con 'hello'. Este ejercicio es nuevo con 'sentimental' básico, como en AI de texto para llamar la atención.",
      "racket": {
        "code": "(define (count-vowels-safe str)\n  (if (string? str)\n      (letrec ((normalized (string-downcase (string-normalize-nfd str)))\n               (vowels '(#\\a #\\e #\\i #\\o #\\u))\n               (count-rec (lambda (lst acc)\n                            (if (empty? lst)\n                                acc\n                                (if (member (car lst) vowels)\n                                    (count-rec (cdr lst) (+ acc 1))\n                                    (count-rec (cdr lst) acc))))))\n        (let ((count (count-rec (string->list normalized) 0)))\n          (if (> count 5)\n              (string-append (number->string count) \" (positivo)\")\n              count)))\n      (error \"Input must be a string\"))\n)\n(count-vowels-safe \"hello\")"
      },
      "ocaml": {
        "code": "let rec count_vowels_safe str =\n  if str = \"\" then\n    0\n  else\n    let normalized = String.lowercase_ascii str in\n    let vowels = ['a'; 'e'; 'i'; 'o'; 'u'] in\n    let rec count_rec acc s =\n      if String.length s = 0 then\n        acc\n      else\n        let c = String.get s 0 in\n        let new_acc = if List.mem c vowels then acc + 1 else acc in\n        count_rec new_acc (String.sub s 1 (String.length s - 1))\n    in\n    let count = count_rec 0 normalized in\n    if count > 5 then\n      string_of_int count ^ \" (positivo)\"\n    else\n      count\nin\ncount_vowels_safe \"hello\""
      },
      "answer": "2"
    }
  },
  "composicion-de-funciones": {
    "ejercicio-1": {
      "description": "En un laboratorio de alquimia digital, un inventor prepara un elixir básico: toma un ingrediente como cadena, lo convierte a minúsculas para purificarlo, y luego añade un prefijo 'elixir-' para activarlo. Define dos funciones: una para minúsculas y otra para prefijo. Compónelas para formar el elixir. Evalúa con 'Magia' para crear el primer brebaje, demostrando cómo composiciones transforman elementos simples en pociones poderosas.",
      "racket": {
        "code": "(define (a-minusculas s)\n  (string-downcase s))\n\n(define (añadir-prefijo s)\n  (string-append \"elixir-\" s))\n\n(define (compuesta-uno s)\n  (añadir-prefijo (a-minusculas s)))\n\n(compuesta-uno \"Magia\")"
      },
      "ocaml": {
        "code": "let a_minusculas s =\n  String.lowercase_ascii s\n;;\n\nlet añadir_prefijo s =\n  \"elixir-\" ^ s\n;;\n\nlet compuesta_uno s =\n  añadir_prefijo (a_minusculas s)\n;;\n\ncompuesta_uno \"Magia\""
      },
      "answer": "elixir-magia"
    },
    "ejercicio-2": {
      "description": "Un decodificador de runas antiguas procesa inscripciones: primero revierte la cadena para leer el mensaje oculto, luego filtra solo consonantes usando condicional para cada carácter (excluyendo vocales). Define funciones para revertir y filtrar consonantes. Compónelas para revelar la runa. Prueba con 'anigam' para desentrañar el enigma, mostrando composiciones que desvelan secretos lingüísticos con lógica condicional básica.",
      "racket": {
        "code": "(define (revertir s)\n  (list->string (reverse (string->list s))))\n\n(define (filtrar-consonantes s)\n  (list->string\n   (filter (lambda (c)\n             (not (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))))\n           (string->list s))))\n\n(define (compuesta-dos s)\n  (filtrar-consonantes (revertir s)))\n\n(compuesta-dos \"anigam\")"
      },
      "ocaml": {
        "code": "let revertir s =\n  let len = String.length s in\n  String.init len (fun i -> s.[len - 1 - i])\n;;\n\nlet filtrar_consonantes s =\n  let buf = Buffer.create (String.length s) in\n  String.iter (fun c ->\n    if not (List.mem (Char.lowercase_ascii c) ['a'; 'e'; 'i'; 'o'; 'u']) then\n      Buffer.add_char buf c\n  ) s;\n  Buffer.contents buf\n;;\n\nlet compuesta_dos s =\n  filtrar_consonantes (revertir s)\n;;\n\ncompuesta_dos \"anigam\""
      },
      "answer": "mgn"
    },
    "ejercicio-3": {
      "description": "En una simulación de ecosistema virtual, un biólogo procesa datos de especies: toma una lista de tamaños, mapea multiplicando por 2 para crecimiento, filtra solo mayores que 5 con condicional, y suma los restantes para biomasa total. Define funciones para map multiplicar, filtrar mayores, y fold suma. Compónelas para calcular biomasa. Evalúa con '(2 3 4)' para predecir el equilibrio ecológico, introduciendo manejo de listas en composiciones.",
      "racket": {
        "code": "(define (multiplicar-por-dos lst)\n  (map (lambda (x) (* x 2)) lst))\n\n(define (filtrar-mayores-cinco lst)\n  (filter (lambda (x) (> x 5)) lst))\n\n(define (sumar-lista lst)\n  (foldl + 0 lst))\n\n(define (compuesta-tres lst)\n  (sumar-lista (filtrar-mayores-cinco (multiplicar-por-dos lst))))\n\n(compuesta-tres '(2 3 4))"
      },
      "ocaml": {
        "code": "let multiplicar_por_dos lst =\n  List.map (fun x -> x * 2) lst\n;;\n\nlet filtrar_mayores_cinco lst =\n  List.filter (fun x -> x > 5) lst\n;;\n\nlet sumar_lista lst =\n  List.fold_left (+) 0 lst\n;;\n\nlet compuesta_tres lst =\n  sumar_lista (filtrar_mayores_cinco (multiplicar_por_dos lst))\n;;\n\ncompuesta_tres [2; 3; 4]"
      },
      "answer": "8"
    },
    "ejercicio-4": {
      "description": "Un lingüista en un mundo de idiomas perdidos analiza textos: revierte la cadena, convierte a mayúsculas, filtra caracteres alfabéticos con condicional anidado (si es letra y no vocal si cond extra), y cuenta longitud para complejidad. Define funciones para revertir, mayúsculas, filtrar anidado, y longitud. Compónelas para medir antigüedad. Prueba con 'txet1' para descifrar un fragmento, añadiendo condicionales anidados para variedad.",
      "racket": {
        "code": "(define (revertir s)\n  (list->string (reverse (string->list s))))\n\n(define (a-mayusculas s)\n  (string-upcase s))\n\n(define (filtrar-alfabeticos-no-vocales s)\n  (list->string\n   (filter (lambda (c)\n             (if (char-alphabetic? c)\n                 (if (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))\n                     #f\n                     #t)\n                 #f))\n           (string->list s))))\n\n(define (contar-longitud s)\n  (string-length s))\n\n(define (compuesta-cuatro s)\n  (contar-longitud (filtrar-alfabeticos-no-vocales (a-mayusculas (revertir s)))))\n\n(compuesta-cuatro \"txet1\")"
      },
      "ocaml": {
        "code": "let revertir s =\n  let len = String.length s in\n  String.init len (fun i -> s.[len - 1 - i])\n;;\n\nlet a_mayusculas s =\n  String.uppercase_ascii s\n;;\n\nlet filtrar_alfabeticos_no_vocales s =\n  let buf = Buffer.create (String.length s) in\n  String.iter (fun c ->\n    if Char.is_alpha c then\n      if not (List.mem (Char.lowercase_ascii c) ['a'; 'e'; 'i'; 'o'; 'u']) then\n        Buffer.add_char buf c\n  ) s;\n  Buffer.contents buf\n;;\n\nlet contar_longitud s =\n  String.length s\n;;\n\nlet compuesta_cuatro s =\n  contar_longitud (filtrar_alfabeticos_no_vocales (a_mayusculas (revertir s)))\n;;\n\ncompuesta_cuatro \"txet1\""
      },
      "answer": "2"
    },
    "ejercicio-5": {
      "description": "En un taller de invenciones steampunk, un mecánico procesa partes: lista de tuplas (nombre, valor), filtra si valor >3 con cond, mapea agregando 'mk-' a nombre y duplicando valor, fold sumando valores con cond anidado (si par suma doble), y ajusta final si >10 resta 5. Define funciones con cond anidados. Compónelas para ensamblar máquina. Evalúa con '((\"gear\" . 4) (\"bolt\" . 2))' para calcular potencia.",
      "racket": {
        "code": "(define (filtrar-mayor-tres lst)\n  (filter (lambda (p) (> (cdr p) 3)) lst))\n\n(define (mapear-mk-duplicar lst)\n  (map (lambda (p)\n         (cons (string-append \"mk-\" (car p))\n               (* (cdr p) 2)))\n       lst))\n\n(define (fold-suma-cond-anidada lst)\n  (foldl (lambda (p acc)\n           (let ([val (cdr p)])\n             (if (even? val)\n                 (if (> val 4)\n                     (+ acc (* val 2))\n                     (+ acc val))\n                 (+ acc val))))\n         0 lst))\n\n(define (ajustar-si-mayor-diez n)\n  (if (> n 10)\n      (- n 5)\n      n))\n\n(define (compuesta-cinco lst)\n  (ajustar-si-mayor-diez (fold-suma-cond-anidada (mapear-mk-duplicar (filtrar-mayor-tres lst)))))\n\n(compuesta-cinco '((\"gear\" . 4) (\"bolt\" . 2)))"
      },
      "ocaml": {
        "code": "let filtrar_mayor_tres lst =\n  List.filter (fun (_, v) -> v > 3) lst\n;;\n\nlet mapear_mk_duplicar lst =\n  List.map (fun (n, v) -> (\"mk-\" ^ n, v * 2)) lst\n;;\n\nlet fold_suma_cond_anidada lst =\n  List.fold_left (fun acc (_, val_) ->\n    if val_ mod 2 = 0 then\n      if val_ > 4 then\n        acc + (val_ * 2)\n      else\n        acc + val_\n    else\n      acc + val_\n  ) 0 lst\n;;\n\nlet ajustar_si_mayor_diez n =\n  if n > 10 then n - 5 else n\n;;\n\nlet compuesta_cinco lst =\n  ajustar_si_mayor_diez (fold_suma_cond_anidada (mapear_mk_duplicar (filtrar_mayor_tres lst)))\n;;\n\ncompuesta_cinco [(\"gear\", 4); (\"bolt\", 2)]"
      },
      "answer": "11"
    },
    "ejercicio-6": {
      "description": "Un cartógrafo de mundos fantásticos mapea territorios: lista de coordenadas (x y), filtra si x+y even con cond, mapea a regiones con cond anidado (si x>0 'este' else 'oeste', y si y>0 'norte' else 'sur'), fold contando 'este' con cond anidado extra (si 'norte' cuenta doble), y clasifica final si total >5 'vasto' else 'pequeño'. Compónelas para dibujar mapa. Evalúa con '((1 . 1) (2 . 2) (3 . 3))'.",
      "racket": {
        "code": "(define (filtrar-suma-par lst)\n  (filter (lambda (p) (even? (+ (car p) (cdr p)))) lst))\n\n(define (mapear-regiones lst)\n  (map (lambda (p)\n         (let ([x (car p)] [y (cdr p)])\n           (string-append (if (> x 0) \"este-\" \"oeste-\")\n                          (if (> y 0) \"norte\" \"sur\"))))\n       lst))\n\n(define (fold-contar-este lst)\n  (foldl (lambda (s acc)\n           (if (string-prefix? s \"este\")\n               (if (string-suffix? s \"norte\")\n                   (+ acc 2)\n                   (+ acc 1))\n               acc))\n         0 lst))\n\n(define (clasificar-total n)\n  (if (> n 5)\n      \"vasto\"\n      \"pequeño\"))\n\n(define (compuesta-seis lst)\n  (clasificar-total (fold-contar-este (mapear-regiones (filtrar-suma-par lst)))))\n\n(compuesta-seis '((1 . 1) (2 . 2) (3 . 3)))"
      },
      "ocaml": {
        "code": "let filtrar_suma_par lst =\n  List.filter (fun (x, y) -> (x + y) mod 2 = 0) lst\n;;\n\nlet mapear_regiones lst =\n  List.map (fun (x, y) ->\n    (if x > 0 then \"este-\" else \"oeste-\") ^ (if y > 0 then \"norte\" else \"sur\")\n  ) lst\n;;\n\nlet fold_contar_este lst =\n  List.fold_left (fun acc s ->\n    if String.starts_with ~prefix:\"este\" s then\n      if String.ends_with ~suffix:\"norte\" s then\n        acc + 2\n      else\n        acc + 1\n    else\n      acc\n  ) 0 lst\n;;\n\nlet clasificar_total n =\n  if n > 5 then \"vasto\" else \"pequeño\"\n;;\n\nlet compuesta_seis lst =\n  clasificar_total (fold_contar_este (mapear_regiones (filtrar_suma_par lst)))\n;;\n\ncompuesta_seis [(1, 1); (2, 2); (3, 3)]"
      },
      "answer": "pequeño"
    },
    "ejercicio-7": {
      "description": "En una academia de hechicería cuántica, un mago computa encantamientos: lista de triples (hechizo, potencia, tipo), filtra si potencia >2 y tipo 'fuego' o 'agua' con cond anidado, mapea aumentando potencia si 'fuego' doble else triple con cond, fold calculando energía con cond anidado múltiple (si potencia par suma, si impar multiplica por 1.5, si >10 ajusta), ajusta final si total impar suma 1 else resta 1, y categoriza en niveles con cond anidado (si >20 'epico' else si >10 'avanzado' else 'basico'). Compónelas para invocar. Evalúa con '((\"rayo\" . 3 . \"fuego\") (\"ola\" . 1 . \"agua\") (\"viento\" . 4 . \"aire\"))'.",
      "racket": {
        "code": "(define (filtrar-potencia-tipo lst)\n  (filter (lambda (t)\n            (let ([pot (cadr t)] [tip (caddr t)])\n              (and (> pot 2)\n                   (or (string=? tip \"fuego\")\n                       (string=? tip \"agua\")))))\n          lst))\n\n(define (mapear-aumentar-potencia lst)\n  (map (lambda (t)\n         (let ([hec (car t)] [pot (cadr t)] [tip (caddr t)])\n           (list hec\n                 (if (string=? tip \"fuego\")\n                     (* pot 2)\n                     (* pot 3))\n                 tip)))\n       lst))\n\n(define (fold-energia-cond-mult lst)\n  (foldl (lambda (t acc)\n           (let ([pot (cadr t)])\n             (if (even? pot)\n                 (+ acc pot)\n                 (let ([mult (* pot 1.5)])\n                   (if (> mult 10)\n                       (+ acc (- mult 5))\n                       (+ acc mult))))))\n         0 lst))\n\n(define (ajustar-impar n)\n  (if (odd? n)\n      (+ n 1)\n      (- n 1)))\n\n(define (categorizar-nivel n)\n  (cond [(> n 20) \"epico\"]\n        [(> n 10) \"avanzado\"]\n        [else \"basico\"]))\n\n(define (compuesta-siete lst)\n  (categorizar-nivel (ajustar-impar (fold-energia-cond-mult (mapear-aumentar-potencia (filtrar-potencia-tipo lst))))))\n\n(compuesta-siete '((\"rayo\" 3 \"fuego\") (\"ola\" 1 \"agua\") (\"viento\" 4 \"aire\")))"
      },
      "ocaml": {
        "code": "let filtrar_potencia_tipo lst =\n  List.filter (fun (_, pot, tip) ->\n    pot > 2 && (tip = \"fuego\" || tip = \"agua\")\n  ) lst\n;;\n\nlet mapear_aumentar_potencia lst =\n  List.map (fun (hec, pot, tip) ->\n    (hec, if tip = \"fuego\" then pot * 2 else pot * 3, tip)\n  ) lst\n;;\n\nlet fold_energia_cond_mult lst =\n  List.fold_left (fun acc (_, pot, _) ->\n    if pot mod 2 = 0 then\n      acc + pot\n    else\n      let mult = int_of_float (float_of_int pot *. 1.5) in\n      if mult > 10 then\n        acc + (mult - 5)\n      else\n        acc + mult\n  ) 0 lst\n;;\n\nlet ajustar_impar n =\n  if n mod 2 = 1 then n + 1 else n - 1\n;;\n\nlet categorizar_nivel n =\n  if n > 20 then \"epico\"\n  else if n > 10 then \"avanzado\"\n  else \"basico\"\n;;\n\nlet compuesta_siete lst =\n  categorizar_nivel (ajustar_impar (fold_energia_cond_mult (mapear_aumentar_potencia (filtrar_potencia_tipo lst))))\n;;\n\ncompuesta_siete [(\"rayo\", 3, \"fuego\"); (\"ola\", 1, \"agua\"); (\"viento\", 4, \"aire\")]"
      },
      "answer": "basico"
    }
  },
  "procesamiento-listas": {
    "ejercicio-1": {
      "description": "En un mundo de criaturas míticas, un guardián filtra nombres de bestias con longitud par para invocar aliados (\"dragon\" \"elfo\" \"goblin\"). Define una función con filter para mantener nombres con longitud par. Evalúa con (\"dragon\" \"elfo\" \"goblin\"). Esto introduce filtrado básico de listas de cadenas para seleccionar elementos según propiedades, como en un juego donde solo ciertas criaturas pueden unirse a tu equipo, haciendo el procesamiento de datos más engaging y relatable a escenarios fantásticos.",
      "racket": {
        "code": "(define (filtrar-longitud-par lst)\n  (filter (lambda (s) (even? (string-length s))) lst))\n\n(filtrar-longitud-par '(\"dragon\" \"elfo\" \"goblin\"))"
      },
      "ocaml": {
        "code": "let filtrar_longitud_par lst =\n  List.filter (fun s -> String.length s mod 2 = 0) lst\nin\nfiltrar_longitud_par [\"dragon\"; \"elfo\"; \"goblin\"]"
      },
      "answer": "(\"elfo\" \"goblin\")"
    },
    "ejercicio-2": {
      "description": "En una aventura espacial, un piloto transforma códigos de navegación a mayúsculas para activar protocolos de emergencia (\"warp\" \"nebula\" \"star\"). Define una función con map para convertir cada cadena a mayúsculas. Evalúa con (\"warp\" \"nebula\" \"star\"). Esto muestra cómo map aplica transformaciones uniformes a listas de cadenas, como en un juego de ciencia ficción donde actualizas nombres de planetas o naves para sistemas de navegación, agregando un toque inmersivo y didáctico al manejo de texto.",
      "racket": {
        "code": "(define (mayusculas-lista lst)\n  (map string-upcase lst))\n\n(mayusculas-lista '(\"warp\" \"nebula\" \"star\"))"
      },
      "ocaml": {
        "code": "let mayusculas_lista lst =\n  List.map String.uppercase_ascii lst\nin\nmayusculas_lista [\"warp\"; \"nebula\"; \"star\"]"
      },
      "answer": "(\"WARP\" \"NEBULA\" \"STAR\")"
    },
    "ejercicio-3": {
      "description": "En un laberinto encantado, un explorador filtra y mapea pistas de acertijos para encontrar salidas, filtrando palabras con vocales iniciales y agregando 'clue-' (\"apple\" \"banana\" \"cherry\"). Define funciones separadas para filter (vocal inicial) y map (añadir prefijo), luego compónelas. Evalúa con (\"apple\" \"banana\" \"cherry\"). Esto combina filter y map para procesamiento secuencial de listas de cadenas, como en un juego de puzzles donde manipulas pistas para resolver misterios, fomentando creatividad y lógica no convencional.",
      "racket": {
        "code": "(define (vocal-inicial? s)\n  (member (string-ref (string-downcase s) 0) '(#\\a #\\e #\\i #\\o #\\u)))\n\n(define (filtrar-vocal-inicial lst)\n  (filter vocal-inicial? lst))\n\n(define (añadir-prefijo-clue lst)\n  (map (lambda (s) (string-append \"clue-\" s)) lst))\n\n(define (compuesta-tres lst)\n  (añadir-prefijo-clue (filtrar-vocal-inicial lst)))\n\n(compuesta-tres '(\"apple\" \"banana\" \"cherry\"))"
      },
      "ocaml": {
        "code": "let vocal_inicial s =\n  List.mem (Char.lowercase_ascii s.[0]) ['a'; 'e'; 'i'; 'o'; 'u']\n;;\n\nlet filtrar_vocal_inicial lst =\n  List.filter vocal_inicial lst\n;;\n\nlet añadir_prefijo_clue lst =\n  List.map (fun s -> \"clue-\" ^ s) lst\n;;\n\nlet compuesta_tres lst =\n  añadir_prefijo_clue (filtrar_vocal_inicial lst)\n;;\n\ncompuesta_tres [\"apple\"; \"banana\"; \"cherry\"]"
      },
      "answer": "(\"clue-apple\" \"clue-cherry\")"
    },
    "ejercicio-4": {
      "description": "En un reino de sueños lúcidos, un soñador filtra colores vibrantes (\"red\" \"green\" \"blue\" \"yellow\") con longitud impar y luego mapea a códigos hexadecimales usando una función auxiliar, combinando con filter anidado para colores primarios. Define funciones para filter longitud impar, map a hex (con cond para primarios), y compónelas con una función intermedia. Evalúa con (\"red\" \"green\" \"blue\" \"yellow\"). Esto enseña anidamiento de map y filter para manipulación creativa de listas de cadenas, como en un juego de realidad virtual donde transformas colores de sueños en códigos para construir mundos, saliendo de lo convencional con temas oníricos.",
      "racket": {
        "code": "(define (longitud-impar? s)\n  (odd? (string-length s)))\n\n(define (filtrar-longitud-impar lst)\n  (filter longitud-impar? lst))\n\n(define (es-primario? s)\n  (member (string-downcase s) '(\"red\" \"green\" \"blue\")))\n\n(define (filtrar-primarios lst)\n  (filter es-primario? lst))\n\n(define (mapear-hex lst)\n  (map (lambda (s)\n         (cond [(string=? (string-downcase s) \"red\") \"#FF0000\"]\n               [(string=? (string-downcase s) \"green\") \"#00FF00\"]\n               [(string=? (string-downcase s) \"blue\") \"#0000FF\"]\n               [else \"#000000\"]))\n       lst))\n\n(define (compuesta-cuatro lst)\n  (mapear-hex (filtrar-primarios (filtrar-longitud-impar lst))))\n\n(compuesta-cuatro '(\"red\" \"green\" \"blue\" \"yellow\"))"
      },
      "ocaml": {
        "code": "let longitud_impar s =\n  String.length s mod 2 = 1\n;;\n\nlet filtrar_longitud_impar lst =\n  List.filter longitud_impar lst\n;;\n\nlet es_primario s =\n  List.mem (String.lowercase_ascii s) [\"red\"; \"green\"; \"blue\"]\n;;\n\nlet filtrar_primarios lst =\n  List.filter es_primario lst\n;;\n\nlet mapear_hex lst =\n  List.map (fun s ->\n    match String.lowercase_ascii s with\n    | \"red\" -> \"#FF0000\"\n    | \"green\" -> \"#00FF00\"\n    | \"blue\" -> \"#0000FF\"\n    | _ -> \"#000000\"\n  ) lst\n;;\n\nlet compuesta_cuatro lst =\n  mapear_hex (filtrar_primarios (filtrar_longitud_impar lst))\n;;\n\ncompuesta_cuatro [\"red\"; \"green\"; \"blue\"; \"yellow\"]"
      },
      "answer": "(\"#FF0000\" \"#00FF00\" \"#0000FF\")"
    },
    "ejercicio-5": {
      "description": "En un circo de curiosidades victorianas, un ilusionista filtra actos misteriosos con nombres que contienen 'm' y mapea a horarios usando fold para acumular tiempos, con condiciones anidadas para actos largos. Define funciones para filter (contiene 'm'), map a tiempos (con cond para longitud), fold para sumar tiempos, y compónelas. Evalúa con (\"magia\" \"misterio\" \"truco\" \"ilusión\"). Esto integra map, filter y fold para procesamiento avanzado de listas mixtas, como en un juego de gestión de eventos donde manejas actos de circo con tiempos dinámicos, añadiendo un toque histórico y peculiar.",
      "racket": {
        "code": "(define (contiene-m? s)\n  (string-contains? (string-downcase s) \"m\"))\n\n(define (filtrar-contiene-m lst)\n  (filter contiene-m? lst))\n\n(define (asignar-tiempo s)\n  (let ([len (string-length s)])\n    (if (> len 5)\n        20\n        10)))\n\n(define (mapear-tiempos lst)\n  (map asignar-tiempo lst))\n\n(define (sumar-tiempos lst)\n  (foldl + 0 lst))\n\n(define (compuesta-cinco lst)\n  (sumar-tiempos (mapear-tiempos (filtrar-contiene-m lst))))\n\n(compuesta-cinco '(\"magia\" \"misterio\" \"truco\" \"ilusión\"))"
      },
      "ocaml": {
        "code": "let contiene_m s =\n  String.contains (String.lowercase_ascii s) 'm'\n;;\n\nlet filtrar_contiene_m lst =\n  List.filter contiene_m lst\n;;\n\nlet asignar_tiempo s =\n  let len = String.length s in\n  if len > 5 then 20 else 10\n;;\n\nlet mapear_tiempos lst =\n  List.map asignar_tiempo lst\n;;\n\nlet sumar_tiempos lst =\n  List.fold_left (+) 0 lst\n;;\n\nlet compuesta_cinco lst =\n  sumar_tiempos (mapear_tiempos (filtrar_contiene_m lst))\n;;\n\ncompuesta_cinco [\"magia\"; \"misterio\"; \"truco\"; \"ilusión\"]"
      },
      "answer": "70"
    },
    "ejercicio-6": {
      "description": "En una biblioteca de mitos olvidados, un archivero filtra libros con títulos que comienzan con vocal y mapea a resúmenes usando cond anidadas para géneros, luego filtra resúmenes largos con filter adicional, y usa fold para contar palabras. Define múltiples funciones con map y filter anidados para procesar listas de títulos y géneros. Evalúa con ((\"Odisea\" . \"epica\") (\"Iliada\" . \"epica\") (\"Beowulf\" . \"leyenda\") (\"Gilgamesh\" . \"mito\")). Esto explora manejo avanzado de listas mixtas con temas mitológicos, como en un juego de rol donde gestionas artefactos y relatos, con un enfoque didáctico en narrativas extrañas.",
      "racket": {
        "code": "(define (vocal-inicio? s)\n  (member (char-downcase (string-ref s 0)) '(#\\a #\\e #\\i #\\o #\\u)))\n\n(define (filtrar-vocal-inicio lst)\n  (filter (lambda (p) (vocal-inicio? (car p))) lst))\n\n(define (generar-resumen p)\n  (let ([titulo (car p)] [genero (cdr p)])\n    (if (string=? genero \"epica\")\n        (string-append \"Epica: \" titulo)\n        (if (string=? genero \"leyenda\")\n            (string-append \"Leyenda: \" titulo)\n            (string-append \"Mito: \" titulo)))))\n\n(define (mapear-resumenes lst)\n  (map generar-resumen lst))\n\n(define (resumen-largo? s)\n  (> (string-length s) 10))\n\n(define (filtrar-resumenes-largos lst)\n  (filter resumen-largo? lst))\n\n(define (contar-palabras lst)\n  (foldl (lambda (s acc)\n           (+ acc (length (string-split s))))\n         0 lst))\n\n(define (compuesta-seis lst)\n  (contar-palabras (filtrar-resumenes-largos (mapear-resumenes (filtrar-vocal-inicio lst)))))\n\n(compuesta-seis '((\"Odisea\" . \"epica\") (\"Iliada\" . \"epica\") (\"Beowulf\" . \"leyenda\") (\"Gilgamesh\" . \"mito\")))"
      },
      "ocaml": {
        "code": "let vocal_inicio s =\n  List.mem (Char.lowercase_ascii s.[0]) ['a'; 'e'; 'i'; 'o'; 'u']\n;;\n\nlet filtrar_vocal_inicio lst =\n  List.filter (fun (titulo, _) -> vocal_inicio titulo) lst\n;;\n\nlet generar_resumen (titulo, genero) =\n  if genero = \"epica\" then\n    \"Epica: \" ^ titulo\n  else if genero = \"leyenda\" then\n    \"Leyenda: \" ^ titulo\n  else\n    \"Mito: \" ^ titulo\n;;\n\nlet mapear_resumenes lst =\n  List.map generar_resumen lst\n;;\n\nlet resumen_largo s =\n  String.length s > 10\n;;\n\nlet filtrar_resumenes_largos lst =\n  List.filter resumen_largo lst\n;;\n\nlet contar_palabras lst =\n  List.fold_left (fun acc s ->\n    acc + (List.length (String.split_on_char ' ' s))\n  ) 0 lst\n;;\n\nlet compuesta_seis lst =\n  contar_palabras (filtrar_resumenes_largos (mapear_resumenes (filtrar_vocal_inicio lst)))\n;;\n\ncompuesta_seis [(\"Odisea\", \"epica\"); (\"Iliada\", \"epica\"); (\"Beowulf\", \"leyenda\"); (\"Gilgamesh\", \"mito\")]"
      },
      "answer": "8"
    },
    "ejercicio-7": {
      "description": "En una orquesta de sombras sobrenaturales, un director filtra instrumentos malditos con nombres terminando en vocal, mapea a frecuencias espectrales usando cond anidadas para tipos de instrumento, filtra frecuencias pares, mapea a notas musicales, y usa fold con cond anidadas para componer una melodía codificada como cadena acumulada. Define múltiples funciones con map y filter para procesar listas mixtas de instrumentos y tipos, agregando un giro macabro. Evalúa con ((\"violin\" . \"cuerda\") (\"flauta\" . \"viento\") (\"tambor\" . \"percusión\") (\"arpa\" . \"cuerda\") (\"oboe\" . \"viento\")). Esto culmina en un ejercicio robusto con temas oscuros y didácticos, como en un juego de horror donde construyes sinfonías malditas a partir de listas, saliendo de lo convencional con narrativas escalofriantes.",
      "racket": {
        "code": "(define (termina-vocal? s)\n  (let ([ultima (string-ref (string-downcase s) (- (string-length s) 1))])\n    (member ultima '(#\\a #\\e #\\i #\\o #\\u))))\n\n(define (filtrar-termina-vocal lst)\n  (filter (lambda (p) (termina-vocal? (car p))) lst))\n\n(define (asignar-frecuencia p)\n  (let ([instrumento (car p)] [tipo (cdr p)])\n    (cond [(string=? tipo \"cuerda\") (* (string-length instrumento) 10)]\n          [(string=? tipo \"viento\") (* (string-length instrumento) 15)]\n          [else (* (string-length instrumento) 20)])))\n\n(define (mapear-frecuencias lst)\n  (map asignar-frecuencia lst))\n\n(define (frecuencia-par? n)\n  (even? n))\n\n(define (filtrar-frecuencias-pares lst)\n  (filter frecuencia-par? lst))\n\n(define (mapear-notas lst)\n  (map (lambda (f)\n         (cond [(> f 100) \"DO\"]\n               [(> f 50) \"RE\"]\n               [else \"MI\"]))\n       lst))\n\n(define (componer-melodia lst)\n  (foldl (lambda (nota acc)\n           (let ([len (string-length nota)])\n             (if (> len 2)\n                 (string-append acc nota \"-\")\n                 (if (< len 2)\n                     (string-append acc nota \"!\")\n                     (string-append acc nota))))\n         \"\" lst))\n\n(define (compuesta-siete lst)\n  (componer-melodia (mapear-notas (filtrar-frecuencias-pares (mapear-frecuencias (filtrar-termina-vocal lst))))))\n\n(compuesta-siete '(\"violin\" . \"cuerda\") (\"flauta\" . \"viento\") (\"tambor\" . \"percusión\") (\"arpa\" . \"cuerda\") (\"oboe\" . \"viento\")))"
      },
      "ocaml": {
        "code": "let termina_vocal s =\n  let ultima = Char.lowercase_ascii s.[String.length s - 1] in\n  List.mem ultima ['a'; 'e'; 'i'; 'o'; 'u']\n;;\n\nlet filtrar_termina_vocal lst =\n  List.filter (fun (instrumento, _) -> termina_vocal instrumento) lst\n;;\n\nlet asignar_frecuencia (instrumento, tipo) =\n  match tipo with\n  | \"cuerda\" -> (String.length instrumento) * 10\n  | \"viento\" -> (String.length instrumento) * 15\n  | _ -> (String.length instrumento) * 20\n;;\n\nlet mapear_frecuencias lst =\n  List.map asignar_frecuencia lst\n;;\n\nlet frecuencia_par n =\n  n mod 2 = 0\n;;\n\nlet filtrar_frecuencias_pares lst =\n  List.filter frecuencia_par lst\n;;\n\nlet mapear_notas lst =\n  List.map (fun f ->\n    if f > 100 then \"DO\"\n    else if f > 50 then \"RE\"\n    else \"MI\"\n  ) lst\n;;\n\nlet componer_melodia lst =\n  List.fold_left (fun acc nota ->\n    let len = String.length nota in\n    if len > 2 then\n      acc ^ nota ^ \"-\"\n    else if len < 2 then\n      acc ^ nota ^ \"!\"\n    else\n      acc ^ nota\n  ) \"\" lst\n;;\n\nlet compuesta_siete lst =\n  componer_melodia (mapear_notas (filtrar_frecuencias_pares (mapear_frecuencias (filtrar_termina_vocal lst))))\n;;\n\ncompuesta_siete [(\"violin\", \"cuerda\"); (\"flauta\", \"viento\"); (\"tambor\", \"percusión\"); (\"arpa\", \"cuerda\"); (\"oboe\", \"viento\")]"
      },
      "answer": "RE-DO-REMI"
    }
  }
}
